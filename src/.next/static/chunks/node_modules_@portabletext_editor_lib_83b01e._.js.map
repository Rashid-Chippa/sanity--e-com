{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"selector.is-selection-collapsed.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.guards.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/selectors/selectors.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/selectors/selector.is-selection-collapsed.ts"],"sourcesContent":["import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const guards = createGuards(context)\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusBlock = getFocusTextBlock({context})\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[2])\n      ? context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = ({context}) => {\n  const focusChild = getFocusChild({context})\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[context.value.length - 1]\n    ? context.value[context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock({context})\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock({context})\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = ({context}) => {\n  return (\n    JSON.stringify(context.selection?.anchor.path) ===\n      JSON.stringify(context.selection?.focus.path) &&\n    context.selection?.anchor.offset === context.selection?.focus.offset\n  )\n}\n"],"names":["createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","getFocusBlock","context","key","selection","isKeySegment","focus","path","_key","undefined","node","value","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isPortableTextSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","anchor","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","isSelectionCollapsed","JSON","stringify","offset"],"mappings":"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","ignoreList":[0,1,2]}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"file":"util.is-keyed-segment.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.is-keyed-segment.ts"],"sourcesContent":["import type {KeyedSegment, PathSegment} from '@sanity/types'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: PathSegment): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n"],"names":["isKeyedSegment","segment"],"mappings":";;;AAKO,SAASA,eAAeC,OAAAA,EAA+C;IAC5E,OAAO,OAAOA,WAAY,YAAYA,YAAY,QAAQ,UAAUA;AACtE","ignoreList":[0]}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"file":"util.is-empty-text-block.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.block-offset.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.get-text-block-text.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.is-empty-text-block.ts"],"sourcesContent":["import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../behaviors/behavior.types'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint:\n    | {path: [KeyedSegment, 'children', KeyedSegment]; offset: number}\n    | undefined\n\n  for (const block of value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (offsetLeft === 0) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: 0,\n        }\n        break\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n        break\n      }\n\n      offsetLeft -= child.text.length\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const spanKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(block: PortableTextBlock) {\n  if (!isPortableTextTextBlock(block)) {\n    return false\n  }\n\n  const onlyText = block.children.every(isPortableTextSpan)\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n"],"names":["blockOffsetToSpanSelectionPoint","value","blockOffset","offsetLeft","offset","selectionPoint","block","_key","path","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","spanSelectionPointToBlockOffset","blockKey","isKeyedSegment","undefined","spanKey","getTextBlockText","map","join","isEmptyTextBlock","onlyText","every","blockText"],"mappings":";;;;;;;;;;AAaO,SAASA,gCAAgC,EAC9CC,KAAAA,EACAC,WAAAA,EAIF,EAAG;IACGC,IAAAA,aAAaD,YAAYE,MAAAA,EACzBC;IAIJ,KAAA,MAAWC,SAASL,MACdK,IAAAA,MAAMC,IAAAA,KAASL,YAAYM,IAAAA,CAAK,CAAC,CAAA,CAAED,IAAAA,8JAIlCE,0BAAAA,EAAwBH,KAAK,GAAA;QAIlC,KAAA,MAAWI,SAASJ,MAAMK,QAAAA,CACnBC,QAAAA,2KAAAA,EAAmBF,KAAK,GAI7B;YAAA,IAAIP,eAAe,GAAG;gBACH,iBAAA;oBACfK,MAAM,CAAC;2BAAGN,YAAYM,IAAAA;wBAAM;wBAAY;4BAACD,MAAMG,MAAMH,IAAAA;wBAAAA,CAAK;qBAAA;oBAC1DH,QAAQ;gBACV;gBACA;YAAA;YAGED,IAAAA,cAAcO,MAAMG,IAAAA,CAAKC,MAAAA,EAAQ;gBAClB,iBAAA;oBACfN,MAAM,CAAC;2BAAGN,YAAYM,IAAAA;wBAAM;wBAAY;4BAACD,MAAMG,MAAMH,IAAAA;wBAAAA,CAAK;qBAAA;oBAC1DH,QAAQD;gBACV;gBACA;YAAA;YAGFA,cAAcO,MAAMG,IAAAA,CAAKC,MAAAA;QAAAA;IAAAA;IAItBT,OAAAA;AACT;AAKO,SAASU,gCAAgC,EAC9Cd,KAAAA,EACAI,cAAAA,EAIF,EAA4B;IAC1B,IAAID,SAAS;IAEPY,MAAAA,YAAWC,0NAAAA,EAAeZ,eAAeG,IAAAA,CAAK,CAAC,CAAC,IAClDH,eAAeG,IAAAA,CAAK,CAAC,CAAA,CAAED,IAAAA,GACvBW,KAAAA,GACEC,oNAAUF,iBAAAA,EAAeZ,eAAeG,IAAAA,CAAK,CAAC,CAAC,IACjDH,eAAeG,IAAAA,CAAK,CAAC,CAAA,CAAED,IAAAA,GACvBW,KAAAA;IAEA,IAAA,CAAA,CAAA,CAACF,YAAY,CAACG,OAAAA,GAAAA;QAIlB,KAAA,MAAWb,SAASL,MAClB,IAAIK,MAAMC,IAAAA,KAASS,YAIdP,oLAAAA,EAAwBH,KAAK,GAAA;YAIlC,KAAA,MAAWI,SAASJ,MAAMK,QAAAA,CACnBC,KAAAA,8KAAAA,EAAmBF,KAAK,GAI7B;gBAAA,IAAIA,MAAMH,IAAAA,KAASY,SACV,OAAA;oBACLX,MAAM;wBAAC;4BAACD,MAAMD,MAAMC,IAAAA;wBAAAA,CAAK;qBAAA;oBACzBH,QAAQA,SAASC,eAAeD,MAAAA;gBAClC;gBAGFA,UAAUM,MAAMG,IAAAA,CAAKC,MAAAA;YAAAA;QAAAA;IAAAA;AAG3B;ACxGO,SAASM,iBAAiBd,KAAAA,EAA8B;IACtDA,OAAAA,MAAMK,QAAAA,CAASU,GAAAA,CAAKX,CAAAA,QAAUA,MAAMG,IAAAA,IAAQ,EAAE,EAAES,IAAAA,CAAK,EAAE;AAChE;ACGO,SAASC,iBAAiBjB,KAAAA,EAA0B;IACrD,IAAA,2JAACG,0BAAAA,EAAwBH,KAAK,GACzB,OAAA,CAAA;IAGHkB,MAAAA,WAAWlB,MAAMK,QAAAA,CAASc,KAAAA,uJAAMb,qBAAkB,GAClDc,YAAYN,iBAAiBd,KAAK;IAExC,OAAOkB,YAAYE,cAAc;AACnC","ignoreList":[0,1,2]}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"file":"behavior.core.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/is-hotkey.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.types.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.core.block-objects.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.core.decorators.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.core.lists.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.core.ts"],"sourcesContent":["export interface KeyboardEventLike {\n  key: string\n  keyCode?: number\n  altKey: boolean\n  ctrlKey: boolean\n  metaKey: boolean\n  shiftKey: boolean\n}\n\ninterface HotKey {\n  keyCode?: number | undefined\n  key?: string | undefined\n  altKey: boolean | null\n  ctrlKey: boolean | null\n  metaKey: boolean | null\n  shiftKey: boolean | null\n}\n\nconst IS_MAC =\n  typeof window !== 'undefined' &&\n  /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent)\n\ntype Modifier = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n\nconst modifiers: Record<string, Modifier | undefined> = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey',\n}\n\nconst aliases: Record<string, string | undefined> = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta',\n}\n\nconst keyCodes: Record<string, number | undefined> = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'control': 17,\n  'alt': 18,\n  'pause': 19,\n  'capslock': 20,\n  'escape': 27,\n  ' ': 32,\n  'pageup': 33,\n  'pagedown': 34,\n  'end': 35,\n  'home': 36,\n  'arrowleft': 37,\n  'arrowup': 38,\n  'arrowright': 39,\n  'arrowdown': 40,\n  'insert': 45,\n  'delete': 46,\n  'meta': 91,\n  'numlock': 144,\n  'scrolllock': 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  \"'\": 222,\n  'f1': 112,\n  'f2': 113,\n  'f3': 114,\n  'f4': 115,\n  'f5': 116,\n  'f6': 117,\n  'f7': 118,\n  'f8': 119,\n  'f9': 120,\n  'f10': 121,\n  'f11': 122,\n  'f12': 123,\n  'f13': 124,\n  'f14': 125,\n  'f15': 126,\n  'f16': 127,\n  'f17': 128,\n  'f18': 129,\n  'f19': 130,\n  'f20': 131,\n}\n\nexport function isHotkey(hotkey: string, event: KeyboardEventLike): boolean {\n  return compareHotkey(parseHotkey(hotkey), event)\n}\n\nfunction parseHotkey(hotkey: string): HotKey {\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n  const parsedHotkey: HotKey = {\n    altKey: false,\n    ctrlKey: false,\n    metaKey: false,\n    shiftKey: false,\n  }\n\n  // Special case to handle the `+` key since we use it as a separator.\n  const hotkeySegments = hotkey.replace('++', '+add').split('+')\n\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional =\n      rawHotkeySegment.endsWith('?') && rawHotkeySegment.length > 1\n    const hotkeySegment = optional\n      ? rawHotkeySegment.slice(0, -1)\n      : rawHotkeySegment\n    const keyName = toKeyName(hotkeySegment)\n    const modifier = modifiers[keyName]\n    const alias = aliases[hotkeySegment]\n    const code = keyCodes[keyName]\n\n    if (\n      hotkeySegment.length > 1 &&\n      modifier === undefined &&\n      alias === undefined &&\n      code === undefined\n    ) {\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`)\n    }\n\n    if (hotkeySegments.length === 1 || modifier === undefined) {\n      parsedHotkey.key = keyName\n      parsedHotkey.keyCode = toKeyCode(hotkeySegment)\n    }\n\n    if (modifier !== undefined) {\n      parsedHotkey[modifier] = optional ? null : true\n    }\n  }\n\n  return parsedHotkey\n}\n\nfunction compareHotkey(\n  parsedHotkey: HotKey,\n  event: KeyboardEventLike,\n): boolean {\n  const matchingModifiers =\n    (parsedHotkey.altKey != null\n      ? parsedHotkey.altKey === event.altKey\n      : true) &&\n    (parsedHotkey.ctrlKey != null\n      ? parsedHotkey.ctrlKey === event.ctrlKey\n      : true) &&\n    (parsedHotkey.metaKey != null\n      ? parsedHotkey.metaKey === event.metaKey\n      : true) &&\n    (parsedHotkey.shiftKey != null\n      ? parsedHotkey.shiftKey === event.shiftKey\n      : true)\n\n  if (!matchingModifiers) {\n    return false\n  }\n\n  if (parsedHotkey.keyCode !== undefined && event.keyCode !== undefined) {\n    if (parsedHotkey.keyCode === 91 && event.keyCode === 93) {\n      return true\n    }\n\n    return parsedHotkey.keyCode === event.keyCode\n  }\n\n  return (\n    parsedHotkey.keyCode === event.keyCode ||\n    parsedHotkey.key === event.key.toLowerCase()\n  )\n}\n\nfunction toKeyCode(name: string): number {\n  const keyName = toKeyName(name)\n  const keyCode = keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0)\n\n  return keyCode\n}\n\nfunction toKeyName(name: string): string {\n  const keyName = name.toLowerCase()\n\n  return aliases[keyName] ?? keyName\n}\n","import type {KeyedSegment, PortableTextTextBlock} from '@sanity/types'\nimport type {TextUnit} from 'slate'\nimport type {TextInsertTextOptions} from 'slate/dist/interfaces/transforms/text'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {OmitFromUnion, PickFromUnion} from '../type-utils'\nimport type {EditorSelection, PortableTextSlateEditor} from '../types/editor'\n\n/**\n * @beta\n */\nexport type SyntheticBehaviorEvent =\n  | {\n      type: 'annotation.add'\n      annotation: {\n        name: string\n        value: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: 'annotation.remove'\n      annotation: {\n        name: string\n      }\n    }\n  | {\n      type: 'blur'\n    }\n  | {\n      type: 'decorator.toggle'\n      decorator: string\n    }\n  | {\n      type: 'delete.backward'\n      unit: TextUnit\n    }\n  | {\n      type: 'delete.forward'\n      unit: TextUnit\n    }\n  | {\n      type: 'focus'\n    }\n  | {\n      type: 'insert.block object'\n      placement: 'auto' | 'after' | 'before'\n      blockObject: {\n        name: string\n        value?: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: 'insert.inline object'\n      inlineObject: {\n        name: string\n        value?: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: 'insert.break'\n    }\n  | {\n      type: 'insert.soft break'\n    }\n  | {\n      type: 'insert.text'\n      text: string\n      options?: TextInsertTextOptions\n    }\n  | {\n      type: 'list item.toggle'\n      listItem: string\n    }\n  | {\n      type: 'select'\n      selection: EditorSelection\n    }\n  | {\n      type: 'style.toggle'\n      style: string\n    }\n\n/**\n * @beta\n */\nexport type NativeBehaviorEvent =\n  | {\n      type: 'copy'\n      data: DataTransfer\n    }\n  | {\n      type: 'key.down'\n      keyboardEvent: Pick<\n        KeyboardEvent,\n        'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n      >\n    }\n  | {\n      type: 'key.up'\n      keyboardEvent: Pick<\n        KeyboardEvent,\n        'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n      >\n    }\n  | {\n      type: 'paste'\n      data: DataTransfer\n    }\n\n/**\n * @beta\n */\nexport type CustomBehaviorEvent<\n  TPayload extends Record<string, unknown> = Record<string, unknown>,\n  TType extends string = string,\n  TInternalType extends `custom.${TType}` = `custom.${TType}`,\n> = {\n  type: TInternalType\n} & TPayload\n\nexport function isCustomBehaviorEvent(\n  event: BehaviorEvent,\n): event is CustomBehaviorEvent {\n  return event.type.startsWith('custom.')\n}\n\n/**\n * @beta\n */\nexport type BehaviorActionIntend =\n  | SyntheticBehaviorEvent\n  | {\n      type: 'raise'\n      event: SyntheticBehaviorEvent | CustomBehaviorEvent\n    }\n  | {\n      type: 'annotation.toggle'\n      annotation: {\n        name: string\n        value: {[prop: string]: unknown}\n      }\n    }\n  | {\n      type: 'decorator.add'\n      decorator: string\n    }\n  | {\n      type: 'decorator.remove'\n      decorator: string\n    }\n  | {\n      type: 'insert.span'\n      text: string\n      annotations?: Array<{\n        name: string\n        value: {[prop: string]: unknown}\n      }>\n      decorators?: Array<string>\n    }\n  | {\n      type: 'insert.text block'\n      placement: 'auto' | 'after' | 'before'\n      textBlock?: {\n        children?: PortableTextTextBlock['children']\n      }\n    }\n  | {\n      type: 'list item.add'\n      listItem: string\n    }\n  | {\n      type: 'list item.remove'\n      listItem: string\n    }\n  | {\n      type: 'move.block'\n      at: [KeyedSegment]\n      to: [KeyedSegment]\n    }\n  | {\n      type: 'move.block down'\n      at: [KeyedSegment]\n    }\n  | {\n      type: 'move.block up'\n      at: [KeyedSegment]\n    }\n  | {\n      type: 'noop'\n    }\n  | {\n      type: 'delete.block'\n      blockPath: [KeyedSegment]\n    }\n  | {\n      type: 'delete.text'\n      anchor: BlockOffset\n      focus: BlockOffset\n    }\n  | {\n      type: 'effect'\n      effect: () => void\n    }\n  | {\n      type: 'select.previous block'\n    }\n  | {\n      type: 'select.next block'\n    }\n  | {\n      type: 'style.add'\n      style: string\n    }\n  | {\n      type: 'style.remove'\n      style: string\n    }\n  | {\n      type: 'text block.set'\n      at: [KeyedSegment]\n      level?: number\n      listItem?: string\n      style?: string\n    }\n  | {\n      type: 'text block.unset'\n      at: [KeyedSegment]\n      props: Array<'level' | 'listItem' | 'style'>\n    }\n\n/**\n * @beta\n */\nexport type BehaviorAction = OmitFromUnion<\n  BehaviorActionIntend,\n  'type',\n  'raise'\n> & {\n  editor: PortableTextSlateEditor\n}\n\n/**\n * @beta\n */\nexport function raise(\n  event: SyntheticBehaviorEvent | CustomBehaviorEvent,\n): PickFromUnion<BehaviorActionIntend, 'type', 'raise'> {\n  return {type: 'raise', event}\n}\n\n/**\n * @beta\n */\nexport type BehaviorEvent =\n  | SyntheticBehaviorEvent\n  | NativeBehaviorEvent\n  | CustomBehaviorEvent\n\n/**\n * @beta\n */\nexport type Behavior<\n  TBehaviorEventType extends BehaviorEvent['type'] = BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends BehaviorEvent = BehaviorEvent,\n> = {\n  /**\n   * The internal editor event that triggers this behavior.\n   */\n  on: TBehaviorEventType\n  /**\n   * Predicate function that determines if the behavior should be executed.\n   * Returning a non-nullable value from the guard will pass the value to the\n   * actions and execute them.\n   */\n  guard?: BehaviorGuard<TBehaviorEvent, TGuardResponse>\n  /**\n   * Array of behavior action sets.\n   */\n  actions: Array<BehaviorActionIntendSet<TBehaviorEvent, TGuardResponse>>\n}\n\n/**\n * @beta\n */\nexport type BehaviorGuard<TBehaviorEvent, TGuardResponse> = ({\n  context,\n  event,\n}: {\n  context: EditorContext\n  event: TBehaviorEvent\n}) => TGuardResponse | false\n\n/**\n * @beta\n */\nexport type BehaviorActionIntendSet<TBehaviorEvent, TGuardResponse> = (\n  {\n    context,\n    event,\n  }: {\n    context: EditorContext\n    event: TBehaviorEvent\n  },\n  guardResponse: TGuardResponse,\n) => Array<BehaviorActionIntend>\n\n/**\n * @beta\n *\n * @example\n *\n * ```tsx\n * const noLowerCaseA = defineBehavior({\n *   on: 'insert.text',\n *   guard: ({event, context}) => event.text === 'a',\n *   actions: [({event, context}) => [{type: 'insert.text', text: 'A'}]],\n * })\n * ```\n *\n *\n *\n *\n *\n */\nexport function defineBehavior<\n  TPayload extends Record<string, unknown>,\n  TBehaviorEventType extends\n    BehaviorEvent['type'] = CustomBehaviorEvent['type'],\n  TGuardResponse = true,\n>(\n  behavior: Behavior<\n    TBehaviorEventType,\n    TGuardResponse,\n    TBehaviorEventType extends `custom.${infer TType}`\n      ? CustomBehaviorEvent<TPayload, TType>\n      : PickFromUnion<BehaviorEvent, 'type', TBehaviorEventType>\n  >,\n): Behavior\nexport function defineBehavior<\n  TPayload extends never = never,\n  TBehaviorEventType extends BehaviorEvent['type'] = BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends\n    BehaviorEvent = TBehaviorEventType extends `custom.${infer TType}`\n    ? CustomBehaviorEvent<TPayload, TType>\n    : PickFromUnion<BehaviorEvent, 'type', TBehaviorEventType>,\n>(\n  behavior: Behavior<TBehaviorEventType, TGuardResponse, TBehaviorEvent>,\n): Behavior {\n  return behavior as unknown as Behavior\n}\n\n/**\n * @beta\n */\nexport type BlockOffset = {\n  path: [KeyedSegment]\n  offset: number\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport {isHotkey} from '../internal-utils/is-hotkey'\nimport * as selectors from '../selectors'\nimport {isEmptyTextBlock} from '../utils/util.is-empty-text-block'\nimport {defineBehavior} from './behavior.types'\n\nconst arrowDownOnLonelyBlockObject = defineBehavior({\n  on: 'key.down',\n  guard: ({context, event}) => {\n    const isArrowDown = isHotkey('ArrowDown', event.keyboardEvent)\n    const focusBlockObject = selectors.getFocusBlockObject({context})\n    const nextBlock = selectors.getNextBlock({context})\n\n    return isArrowDown && focusBlockObject && !nextBlock\n  },\n  actions: [() => [{type: 'insert.text block', placement: 'after'}]],\n})\n\nconst arrowUpOnLonelyBlockObject = defineBehavior({\n  on: 'key.down',\n  guard: ({context, event}) => {\n    const isArrowUp = isHotkey('ArrowUp', event.keyboardEvent)\n    const focusBlockObject = selectors.getFocusBlockObject({context})\n    const previousBlock = selectors.getPreviousBlock({context})\n\n    return isArrowUp && focusBlockObject && !previousBlock\n  },\n  actions: [\n    () => [\n      {type: 'insert.text block', placement: 'before'},\n      {type: 'select.previous block'},\n    ],\n  ],\n})\n\nconst breakingBlockObject = defineBehavior({\n  on: 'insert.break',\n  guard: ({context}) => {\n    const focusBlockObject = selectors.getFocusBlockObject({context})\n    const collapsedSelection = selectors.isSelectionCollapsed({context})\n\n    return collapsedSelection && focusBlockObject !== undefined\n  },\n  actions: [() => [{type: 'insert.text block', placement: 'after'}]],\n})\n\nconst deletingEmptyTextBlockAfterBlockObject = defineBehavior({\n  on: 'delete.backward',\n  guard: ({context}) => {\n    const focusTextBlock = selectors.getFocusTextBlock({context})\n    const selectionCollapsed = selectors.isSelectionCollapsed({context})\n    const previousBlock = selectors.getPreviousBlock({context})\n\n    if (!focusTextBlock || !selectionCollapsed || !previousBlock) {\n      return false\n    }\n\n    if (\n      isEmptyTextBlock(focusTextBlock.node) &&\n      !isPortableTextTextBlock(previousBlock.node)\n    ) {\n      return {focusTextBlock, previousBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, previousBlock}) => [\n      {\n        type: 'delete.block',\n        blockPath: focusTextBlock.path,\n      },\n      {\n        type: 'select',\n        selection: {\n          anchor: {path: previousBlock.path, offset: 0},\n          focus: {path: previousBlock.path, offset: 0},\n        },\n      },\n    ],\n  ],\n})\n\nconst deletingEmptyTextBlockBeforeBlockObject = defineBehavior({\n  on: 'delete.forward',\n  guard: ({context}) => {\n    const focusTextBlock = selectors.getFocusTextBlock({context})\n    const selectionCollapsed = selectors.isSelectionCollapsed({context})\n    const nextBlock = selectors.getNextBlock({context})\n\n    if (!focusTextBlock || !selectionCollapsed || !nextBlock) {\n      return false\n    }\n\n    if (\n      isEmptyTextBlock(focusTextBlock.node) &&\n      !isPortableTextTextBlock(nextBlock.node)\n    ) {\n      return {focusTextBlock, nextBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, nextBlock}) => [\n      {\n        type: 'delete.block',\n        blockPath: focusTextBlock.path,\n      },\n      {\n        type: 'select',\n        selection: {\n          anchor: {path: nextBlock.path, offset: 0},\n          focus: {path: nextBlock.path, offset: 0},\n        },\n      },\n    ],\n  ],\n})\n\nexport const coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject,\n}\n","import {isHotkey} from '../internal-utils/is-hotkey'\nimport {defineBehavior, raise} from './behavior.types'\n\nexport const coreDecoratorBehaviors = {\n  strongShortcut: defineBehavior({\n    on: 'key.down',\n    guard: ({context, event}) =>\n      isHotkey('mod+b', event.keyboardEvent) &&\n      context.schema.decorators.some(\n        (decorator) => decorator.value === 'strong',\n      ),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'strong'})]],\n  }),\n  emShortcut: defineBehavior({\n    on: 'key.down',\n    guard: ({context, event}) =>\n      isHotkey('mod+i', event.keyboardEvent) &&\n      context.schema.decorators.some((decorator) => decorator.value === 'em'),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'em'})]],\n  }),\n  underlineShortcut: defineBehavior({\n    on: 'key.down',\n    guard: ({context, event}) =>\n      isHotkey('mod+u', event.keyboardEvent) &&\n      context.schema.decorators.some(\n        (decorator) => decorator.value === 'underline',\n      ),\n    actions: [\n      () => [raise({type: 'decorator.toggle', decorator: 'underline'})],\n    ],\n  }),\n  codeShortcut: defineBehavior({\n    on: 'key.down',\n    guard: ({context, event}) =>\n      isHotkey(\"mod+'\", event.keyboardEvent) &&\n      context.schema.decorators.some((decorator) => decorator.value === 'code'),\n    actions: [() => [raise({type: 'decorator.toggle', decorator: 'code'})]],\n  }),\n}\n","import {createGuards} from '../behavior-actions/behavior.guards'\nimport {isHotkey} from '../internal-utils/is-hotkey'\nimport * as selectors from '../selectors'\nimport {isEmptyTextBlock} from '../utils/util.is-empty-text-block'\nimport {defineBehavior} from './behavior.types'\n\nconst MAX_LIST_LEVEL = 10\n\nconst clearListOnBackspace = defineBehavior({\n  on: 'delete.backward',\n  guard: ({context}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed({context})\n    const focusTextBlock = selectors.getFocusTextBlock({context})\n    const focusSpan = selectors.getFocusSpan({context})\n\n    if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n      return false\n    }\n\n    const atTheBeginningOfBLock =\n      focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n      context.selection?.focus.offset === 0\n\n    if (atTheBeginningOfBLock && focusTextBlock.node.level === 1) {\n      return {focusTextBlock}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock}) => [\n      {\n        type: 'text block.unset',\n        props: ['listItem', 'level'],\n        at: focusTextBlock.path,\n      },\n    ],\n  ],\n})\n\nconst unindentListOnBackspace = defineBehavior({\n  on: 'delete.backward',\n  guard: ({context}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed({context})\n    const focusTextBlock = selectors.getFocusTextBlock({context})\n    const focusSpan = selectors.getFocusSpan({context})\n\n    if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n      return false\n    }\n\n    const atTheBeginningOfBLock =\n      focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n      context.selection?.focus.offset === 0\n\n    if (\n      atTheBeginningOfBLock &&\n      focusTextBlock.node.level !== undefined &&\n      focusTextBlock.node.level > 1\n    ) {\n      return {focusTextBlock, level: focusTextBlock.node.level - 1}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {focusTextBlock, level}) => [\n      {\n        type: 'text block.set',\n        level,\n        at: focusTextBlock.path,\n      },\n    ],\n  ],\n})\n\nconst clearListOnEnter = defineBehavior({\n  on: 'insert.break',\n  guard: ({context}) => {\n    const selectionCollapsed = selectors.isSelectionCollapsed({context})\n    const focusListBlock = selectors.getFocusListBlock({context})\n\n    if (\n      !selectionCollapsed ||\n      !focusListBlock ||\n      !isEmptyTextBlock(focusListBlock.node)\n    ) {\n      return false\n    }\n\n    return {focusListBlock}\n  },\n  actions: [\n    (_, {focusListBlock}) => [\n      {\n        type: 'text block.unset',\n        props: ['listItem', 'level'],\n        at: focusListBlock.path,\n      },\n    ],\n  ],\n})\n\nconst indentListOnTab = defineBehavior({\n  on: 'key.down',\n  guard: ({context, event}) => {\n    const isTab = isHotkey('Tab', event.keyboardEvent)\n\n    if (!isTab) {\n      return false\n    }\n\n    const selectedBlocks = selectors.getSelectedBlocks({context})\n    const guards = createGuards(context)\n    const selectedListBlocks = selectedBlocks.flatMap((block) =>\n      guards.isListBlock(block.node)\n        ? [\n            {\n              node: block.node,\n              path: block.path,\n            },\n          ]\n        : [],\n    )\n\n    if (selectedListBlocks.length === selectedBlocks.length) {\n      return {selectedListBlocks}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {selectedListBlocks}) =>\n      selectedListBlocks.map((selectedListBlock) => ({\n        type: 'text block.set',\n        level: Math.min(\n          MAX_LIST_LEVEL,\n          Math.max(1, selectedListBlock.node.level + 1),\n        ),\n        at: selectedListBlock.path,\n      })),\n  ],\n})\n\nconst unindentListOnShiftTab = defineBehavior({\n  on: 'key.down',\n  guard: ({context, event}) => {\n    const isShiftTab = isHotkey('Shift+Tab', event.keyboardEvent)\n\n    if (!isShiftTab) {\n      return false\n    }\n\n    const selectedBlocks = selectors.getSelectedBlocks({context})\n    const guards = createGuards(context)\n    const selectedListBlocks = selectedBlocks.flatMap((block) =>\n      guards.isListBlock(block.node)\n        ? [\n            {\n              node: block.node,\n              path: block.path,\n            },\n          ]\n        : [],\n    )\n\n    if (selectedListBlocks.length === selectedBlocks.length) {\n      return {selectedListBlocks}\n    }\n\n    return false\n  },\n  actions: [\n    (_, {selectedListBlocks}) =>\n      selectedListBlocks.map((selectedListBlock) => ({\n        type: 'text block.set',\n        level: Math.min(\n          MAX_LIST_LEVEL,\n          Math.max(1, selectedListBlock.node.level - 1),\n        ),\n        at: selectedListBlock.path,\n      })),\n  ],\n})\n\nexport const coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab,\n}\n","import {coreBlockObjectBehaviors} from './behavior.core.block-objects'\nimport {coreDecoratorBehaviors} from './behavior.core.decorators'\nimport {coreListBehaviors} from './behavior.core.lists'\nimport {defineBehavior} from './behavior.types'\n\nconst softReturn = defineBehavior({\n  on: 'insert.soft break',\n  actions: [() => [{type: 'insert.text', text: '\\n'}]],\n})\n\n/**\n * @beta\n */\nexport const coreBehaviors = [\n  softReturn,\n  coreDecoratorBehaviors.strongShortcut,\n  coreDecoratorBehaviors.emShortcut,\n  coreDecoratorBehaviors.underlineShortcut,\n  coreDecoratorBehaviors.codeShortcut,\n  coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject,\n  coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject,\n  coreBlockObjectBehaviors.breakingBlockObject,\n  coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject,\n  coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject,\n  coreListBehaviors.clearListOnBackspace,\n  coreListBehaviors.unindentListOnBackspace,\n  coreListBehaviors.clearListOnEnter,\n  coreListBehaviors.indentListOnTab,\n  coreListBehaviors.unindentListOnShiftTab,\n]\n\n/**\n * @beta\n */\nexport const coreBehavior = {\n  softReturn,\n  decorators: coreDecoratorBehaviors,\n  blockObjects: coreBlockObjectBehaviors,\n  lists: coreListBehaviors,\n}\n"],"names":["IS_MAC","window","test","navigator","userAgent","modifiers","alt","control","meta","shift","aliases","add","break","cmd","command","ctl","ctrl","del","down","esc","ins","left","mod","opt","option","return","right","space","spacebar","up","win","windows","keyCodes","isHotkey","hotkey","event","compareHotkey","parseHotkey","parsedHotkey","altKey","ctrlKey","metaKey","shiftKey","hotkeySegments","replace","split","rawHotkeySegment","optional","endsWith","length","hotkeySegment","slice","keyName","toKeyName","modifier","alias","code","undefined","TypeError","key","keyCode","toKeyCode","toLowerCase","name","toUpperCase","charCodeAt","isCustomBehaviorEvent","type","startsWith","raise","defineBehavior","behavior","arrowDownOnLonelyBlockObject","on","guard","context","isArrowDown","keyboardEvent","focusBlockObject","selectors","nextBlock","actions","placement","arrowUpOnLonelyBlockObject","isArrowUp","previousBlock","breakingBlockObject","deletingEmptyTextBlockAfterBlockObject","focusTextBlock","selectionCollapsed","isEmptyTextBlock","node","isPortableTextTextBlock","_","blockPath","path","selection","anchor","offset","focus","deletingEmptyTextBlockBeforeBlockObject","coreBlockObjectBehaviors","coreDecoratorBehaviors","strongShortcut","schema","decorators","some","decorator","value","emShortcut","underlineShortcut","codeShortcut","MAX_LIST_LEVEL","clearListOnBackspace","focusSpan","children","_key","level","props","at","unindentListOnBackspace","clearListOnEnter","focusListBlock","indentListOnTab","selectedBlocks","guards","createGuards","selectedListBlocks","flatMap","block","isListBlock","map","selectedListBlock","Math","min","max","unindentListOnShiftTab","coreListBehaviors","softReturn","text","coreBehaviors","coreBehavior","blockObjects","lists"],"mappings":"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","ignoreList":[0,1,2,3,4,5]}},
    {"offset": {"line": 807, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 813, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/create-editor-schema.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/define-schema.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/debug.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/paths.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/ranges.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/selection.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/values.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/weakMaps.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/nodes/DefaultObject.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/components/DraggableBlock.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/components/Element.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/hooks/usePortableTextEditor.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/nodes/DefaultAnnotation.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/schema.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/mutation-machine.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/validateValue.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/withChanges.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/withoutPatching.ts","file://D%3A/e-com-hackathon/node_modules/node_modules/.pnpm/%40sanity%2Bdiff-match-patch%403.1.2/node_modules/%40sanity/diff-match-patch/dist/index.js","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/withUndoRedo.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithUndoRedo.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/sync-machine.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/components/Synchronizer.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/operationToPatches.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/with-applying-behavior-actions.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/create-with-event-listeners.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithMaxBlocks.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithObjectKeys.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/applyPatch.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithPatches.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithPlaceholderBlock.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithPortableTextBlockStyle.ts","file://D%3A/e-com-hackathon/node_modules/node_modules/.pnpm/%40portabletext%2Btoolkit%402.0.16/node_modules/%40portabletext/toolkit/dist/index.js","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/sibling-utils.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithPortableTextMarkModel.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithPortableTextSelections.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithSchemaTypes.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithUtils.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/with-plugins.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/create-slate-editor.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.list-item.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.style.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithEditableAPI.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action-utils.insert-block.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.insert-block-object.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.insert-break.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.insert-inline-object.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.insert-span.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.text-block.set.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.action.text-block.unset.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behavior-actions/behavior.actions.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/get-active-decorators.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-snapshot.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-machine.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/get-value.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-selector.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/key-generator.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/create-editor.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-actor-context.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/hooks/usePortableTextEditorSelection.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/PortableTextEditor.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/components/Leaf.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithHotKeys.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/plugins/createWithInsertData.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/withSyncRangeDecorations.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/Editable.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-provider.tsx","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/editor/editor-event-listener.tsx"],"sourcesContent":["import type {\n  ArraySchemaType,\n  BlockSchemaType,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\nimport type {EditorSchema} from './define-schema'\n\nexport function createEditorSchema(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): EditorSchema {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import {Schema as SanitySchema} from '@sanity/schema'\nimport {defineField, defineType, type ObjectSchemaType} from '@sanity/types'\nimport startCase from 'lodash.startcase'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport {createEditorSchema} from './create-editor-schema'\n\n/**\n * @public\n */\nexport type BaseDefinition = {\n  name: string\n  title?: string\n}\n\n/**\n * @public\n */\nexport type SchemaDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = {\n  decorators?: ReadonlyArray<TBaseDefinition>\n  blockObjects?: ReadonlyArray<TBaseDefinition>\n  inlineObjects?: ReadonlyArray<TBaseDefinition>\n  annotations?: ReadonlyArray<TBaseDefinition>\n  lists?: ReadonlyArray<TBaseDefinition>\n  styles?: ReadonlyArray<TBaseDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\n/**\n * @public\n */\nexport type EditorSchema = PortableTextMemberSchemaTypes\n\nexport function compileSchemaDefinition<\n  TSchemaDefinition extends SchemaDefinition,\n>(definition?: TSchemaDefinition) {\n  const blockObjects =\n    definition?.blockObjects?.map((blockObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with the name `image`\n        name: blockObject.name === 'image' ? 'tmp-image' : blockObject.name,\n        title:\n          blockObject.name === 'image' && blockObject.title === undefined\n            ? 'Image'\n            : blockObject.title,\n        fields: [],\n      }),\n    ) ?? []\n  const inlineObjects =\n    definition?.inlineObjects?.map((inlineObject) =>\n      defineType({\n        type: 'object',\n        name: inlineObject.name,\n        title: inlineObject.title,\n        fields: [],\n      }),\n    ) ?? []\n\n  const portableTextSchema = defineField({\n    type: 'array',\n    name: 'portable-text',\n    of: [\n      ...blockObjects.map((blockObject) => ({type: blockObject.name})),\n      {\n        type: 'block',\n        name: 'block',\n        of: inlineObjects.map((inlineObject) => ({type: inlineObject.name})),\n        marks: {\n          decorators:\n            definition?.decorators?.map((decorator) => ({\n              title: decorator.title ?? startCase(decorator.name),\n              value: decorator.name,\n            })) ?? [],\n          annotations:\n            definition?.annotations?.map((annotation) => ({\n              name: annotation.name,\n              type: 'object',\n              title: annotation.title,\n            })) ?? [],\n        },\n        lists:\n          definition?.lists?.map((list) => ({\n            value: list.name,\n            title: list.title ?? startCase(list.name),\n          })) ?? [],\n        styles:\n          definition?.styles?.map((style) => ({\n            value: style.name,\n            title: style.title ?? startCase(style.name),\n          })) ?? [],\n      },\n    ],\n  })\n\n  const schema = SanitySchema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects],\n  }).get('portable-text')\n\n  const pteSchema = createEditorSchema(schema)\n\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) =>\n      blockObject.name === 'tmp-image'\n        ? ({\n            ...blockObject,\n            name: 'image',\n            type: {\n              ...blockObject.type,\n              name: 'image',\n            },\n          } as ObjectSchemaType)\n        : blockObject,\n    ),\n  } satisfies EditorSchema\n}\n","import debug from 'debug'\n\nconst rootName = 'sanity-pte:'\n\nexport default debug(rootName)\nexport function debugWithName(name: string): debug.Debugger {\n  const namespace = `${rootName}${name}`\n  if (debug && debug.enabled(namespace)) {\n    return debug(namespace)\n  }\n  return debug(rootName)\n}\n","import {isKeySegment, type Path} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {\n  Editor,\n  Element,\n  type Descendant,\n  type Point,\n  type Path as SlatePath,\n} from 'slate'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\nimport type {ObjectWithKeyAndType} from './ranges'\n\nexport function createKeyedPath(\n  point: Point,\n  value: ObjectWithKeyAndType[] | undefined,\n  types: PortableTextMemberSchemaTypes,\n): Path | null {\n  const blockPath = [point.path[0]]\n  if (!value) {\n    return null\n  }\n  const block = value[blockPath[0]]\n  if (!block) {\n    return null\n  }\n  const keyedBlockPath = [{_key: block._key}]\n  if (block._type !== types.block.name) {\n    return keyedBlockPath as Path\n  }\n  let keyedChildPath: Path | undefined\n  const childPath = point.path.slice(0, 2)\n  const child = Array.isArray(block.children) && block.children[childPath[1]]\n  if (child) {\n    keyedChildPath = ['children', {_key: child._key}]\n  }\n  return (\n    keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath\n  ) as Path\n}\n\nexport function toSlatePath(path: Path, editor: Editor): SlatePath {\n  if (!editor) {\n    return []\n  }\n  const [block, blockPath] = Array.from(\n    Editor.nodes(editor, {\n      at: [],\n      match: (n) =>\n        isKeySegment(path[0]) && (n as Descendant)._key === path[0]._key,\n    }),\n  )[0] || [undefined, undefined]\n\n  if (!block || !Element.isElement(block)) {\n    return []\n  }\n\n  if (editor.isVoid(block)) {\n    return [blockPath[0], 0]\n  }\n\n  const childPath = [path[2]]\n  const childIndex = block.children.findIndex((child) =>\n    isEqual([{_key: child._key}], childPath),\n  )\n\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex]\n    if (Element.isElement(child) && editor.isVoid(child)) {\n      return blockPath.concat(childIndex).concat(0)\n    }\n    return blockPath.concat(childIndex)\n  }\n\n  return [blockPath[0], 0]\n}\n","import {Point, Range, type BaseRange, type Editor, type Operation} from 'slate'\nimport type {\n  EditorSelection,\n  EditorSelectionPoint,\n  PortableTextMemberSchemaTypes,\n} from '../types/editor'\nimport {createKeyedPath, toSlatePath} from './paths'\n\nexport interface ObjectWithKeyAndType {\n  _key: string\n  _type: string\n  children?: ObjectWithKeyAndType[]\n}\n\nexport function toPortableTextRange(\n  value: ObjectWithKeyAndType[] | undefined,\n  range: BaseRange | Partial<BaseRange> | null,\n  types: PortableTextMemberSchemaTypes,\n): EditorSelection {\n  if (!range) {\n    return null\n  }\n  let anchor: EditorSelectionPoint | null = null\n  let focus: EditorSelectionPoint | null = null\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types)\n  if (anchorPath && range.anchor) {\n    anchor = {\n      path: anchorPath,\n      offset: range.anchor.offset,\n    }\n  }\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types)\n  if (focusPath && range.focus) {\n    focus = {\n      path: focusPath,\n      offset: range.focus.offset,\n    }\n  }\n  const backward = Boolean(\n    Range.isRange(range) ? Range.isBackward(range) : undefined,\n  )\n  return anchor && focus ? {anchor, focus, backward} : null\n}\n\nexport function toSlateRange(\n  selection: EditorSelection,\n  editor: Editor,\n): Range | null {\n  if (!selection || !editor) {\n    return null\n  }\n  const anchor = {\n    path: toSlatePath(selection.anchor.path, editor),\n    offset: selection.anchor.offset,\n  }\n  const focus = {\n    path: toSlatePath(selection.focus.path, editor),\n    offset: selection.focus.offset,\n  }\n  if (focus.path.length === 0 || anchor.path.length === 0) {\n    return null\n  }\n  const range = anchor && focus ? {anchor, focus} : null\n  return range\n}\n\nexport function moveRangeByOperation(\n  range: Range,\n  operation: Operation,\n): Range | null {\n  const anchor = Point.transform(range.anchor, operation)\n  const focus = Point.transform(range.focus, operation)\n\n  if (anchor === null || focus === null) {\n    return null\n  }\n\n  if (Point.equals(anchor, range.anchor) && Point.equals(focus, range.focus)) {\n    return range\n  }\n\n  return {anchor, focus}\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import type {\n  PathSegment,\n  PortableTextBlock,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {Element, Text, type Descendant, type Node} from 'slate'\nimport type {PortableTextMemberSchemaTypes} from '../types/editor'\n\nexport const EMPTY_MARKDEFS: PortableTextObject[] = []\n\nexport const VOID_CHILD_KEY = 'void-child'\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\nfunction keepObjectEquality(\n  object: PortableTextBlock | PortableTextChild,\n  keyMap: Record<string, PortableTextBlock | PortableTextChild>,\n) {\n  const value = keyMap[object._key]\n  if (value && isEqual(object, value)) {\n    return value\n  }\n  keyMap[object._key] = object\n  return object\n}\n\nexport function toSlateValue(\n  value: PortableTextBlock[] | undefined,\n  {schemaTypes}: {schemaTypes: PortableTextMemberSchemaTypes},\n  keyMap: Record<string, any> = {},\n): Descendant[] {\n  if (value && Array.isArray(value)) {\n    return value.map((block) => {\n      const {_type, _key, ...rest} = block\n      const voidChildren = [\n        {_key: VOID_CHILD_KEY, _type: 'span', text: '', marks: []},\n      ]\n      const isPortableText = block && block._type === schemaTypes.block.name\n      if (isPortableText) {\n        const textBlock = block as PortableTextTextBlock\n        let hasInlines = false\n        const hasMissingStyle = typeof textBlock.style === 'undefined'\n        const hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined'\n        const hasMissingChildren = typeof textBlock.children === 'undefined'\n\n        const children = (textBlock.children || []).map((child) => {\n          const {_type: cType, _key: cKey, ...cRest} = child\n          // Return 'slate' version of inline object where the actual\n          // value is stored in the `value` property.\n          // In slate, inline objects are represented as regular\n          // children with actual text node in order to be able to\n          // be selected the same way as the rest of the (text) content.\n          if (cType !== 'span') {\n            hasInlines = true\n            return keepObjectEquality(\n              {\n                _type: cType,\n                _key: cKey,\n                children: voidChildren,\n                value: cRest,\n                __inline: true,\n              },\n              keyMap,\n            )\n          }\n          // Original child object (span)\n          return child\n        })\n        // Return original block\n        if (\n          !hasMissingStyle &&\n          !hasMissingMarkDefs &&\n          !hasMissingChildren &&\n          !hasInlines &&\n          Element.isElement(block)\n        ) {\n          // Original object\n          return block\n        }\n        // TODO: remove this when we have a better way to handle missing style\n        if (hasMissingStyle) {\n          rest.style = schemaTypes.styles[0].value\n        }\n        return keepObjectEquality({_type, _key, ...rest, children}, keyMap)\n      }\n      return keepObjectEquality(\n        {\n          _type,\n          _key,\n          children: voidChildren,\n          value: rest,\n        },\n        keyMap,\n      )\n    }) as Descendant[]\n  }\n  return []\n}\n\nexport function fromSlateValue(\n  value: Descendant[],\n  textBlockType: string,\n  keyMap: Record<string, PortableTextBlock | PortableTextChild> = {},\n): PortableTextBlock[] {\n  return value.map((block) => {\n    const {_key, _type} = block\n    if (!_key || !_type) {\n      throw new Error('Not a valid block')\n    }\n    if (\n      _type === textBlockType &&\n      'children' in block &&\n      Array.isArray(block.children) &&\n      _key\n    ) {\n      let hasInlines = false\n      const children = block.children.map((child) => {\n        const {_type: _cType} = child\n        if ('value' in child && _cType !== 'span') {\n          hasInlines = true\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child\n          return keepObjectEquality(\n            {...rest, ...v, _key: k as string, _type: t as string},\n            keyMap,\n          )\n        }\n        return child\n      })\n      if (!hasInlines) {\n        return block as PortableTextBlock // Original object\n      }\n      return keepObjectEquality(\n        {...block, children, _key, _type},\n        keyMap,\n      ) as PortableTextBlock\n    }\n    const blockValue = 'value' in block && block.value\n    return keepObjectEquality(\n      {_key, _type, ...(typeof blockValue === 'object' ? blockValue : {})},\n      keyMap,\n    ) as PortableTextBlock\n  })\n}\n\nexport function isEqualToEmptyEditor(\n  children: Descendant[] | PortableTextBlock[],\n  schemaTypes: PortableTextMemberSchemaTypes,\n): boolean {\n  return (\n    children === undefined ||\n    (children && Array.isArray(children) && children.length === 0) ||\n    (children &&\n      Array.isArray(children) &&\n      children.length === 1 &&\n      Element.isElement(children[0]) &&\n      children[0]._type === schemaTypes.block.name &&\n      'style' in children[0] &&\n      children[0].style === schemaTypes.styles[0].value &&\n      !('listItem' in children[0]) &&\n      Array.isArray(children[0].children) &&\n      children[0].children.length === 1 &&\n      Text.isText(children[0].children[0]) &&\n      children[0].children[0]._type === 'span' &&\n      !children[0].children[0].marks?.join('') &&\n      children[0].children[0].text === '')\n  )\n}\n\nexport function findBlockAndIndexFromPath(\n  firstPathSegment: PathSegment,\n  children: (Node | Partial<Node>)[],\n): [Element | undefined, number | undefined] {\n  let blockIndex = -1\n  const isNumber = Number.isInteger(Number(firstPathSegment))\n  if (isNumber) {\n    blockIndex = Number(firstPathSegment)\n  } else if (children) {\n    blockIndex = children.findIndex(\n      (blk) =>\n        Element.isElement(blk) && isEqual({_key: blk._key}, firstPathSegment),\n    )\n  }\n  if (blockIndex > -1) {\n    return [children[blockIndex] as Element, blockIndex]\n  }\n  return [undefined, -1]\n}\n\nexport function findChildAndIndexFromPath(\n  secondPathSegment: PathSegment,\n  block: Element,\n): [Element | Text | undefined, number] {\n  let childIndex = -1\n  const isNumber = Number.isInteger(Number(secondPathSegment))\n  if (isNumber) {\n    childIndex = Number(secondPathSegment)\n  } else {\n    childIndex = block.children.findIndex((child) =>\n      isEqual({_key: child._key}, secondPathSegment),\n    )\n  }\n  if (childIndex > -1) {\n    return [block.children[childIndex] as Element | Text, childIndex]\n  }\n  return [undefined, -1]\n}\n\nexport function getValueOrInitialValue(\n  value: unknown,\n  initialValue: PortableTextBlock[],\n): PortableTextBlock[] | undefined {\n  if (value && Array.isArray(value) && value.length > 0) {\n    return value\n  }\n  return initialValue\n}\n","import type {Editor, Element, Range} from 'slate'\nimport type {EditorSelection} from '..'\n\n// Is the editor currently receiving remote changes that are being applied to the content?\nexport const IS_PROCESSING_REMOTE_CHANGES: WeakMap<Editor, boolean> =\n  new WeakMap()\n\n// Is the editor dragging something?\nexport const IS_DRAGGING: WeakMap<Editor, boolean> = new WeakMap()\n// Is the editor dragging a element?\nexport const IS_DRAGGING_BLOCK_ELEMENT: WeakMap<Editor, Element> = new WeakMap()\n\n// When dragging elements, this will be the target element\nexport const IS_DRAGGING_ELEMENT_TARGET: WeakMap<Editor, Element> =\n  new WeakMap()\n// Target position for dragging over a block\nexport const IS_DRAGGING_BLOCK_TARGET_POSITION: WeakMap<\n  Editor,\n  'top' | 'bottom'\n> = new WeakMap()\n\nexport const KEY_TO_SLATE_ELEMENT: WeakMap<Editor, any | undefined> =\n  new WeakMap()\nexport const KEY_TO_VALUE_ELEMENT: WeakMap<Editor, any | undefined> =\n  new WeakMap()\n\n// Keep object relation to slate range in the portable-text-range\nexport const SLATE_TO_PORTABLE_TEXT_RANGE = new WeakMap<\n  Range,\n  EditorSelection\n>()\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\nimport type {JSX} from 'react'\n\ntype Props = {\n  value: PortableTextBlock | PortableTextChild\n}\n\nconst DefaultObject = (props: Props): JSX.Element => {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nDefaultObject.displayName = 'DefaultObject'\n\nexport default DefaultObject\n","import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type DragEvent,\n  type MutableRefObject,\n  type ReactNode,\n} from 'react'\nimport {Editor, Path, Transforms, type Element as SlateElement} from 'slate'\nimport {ReactEditor, useSlateStatic} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  IS_DRAGGING,\n  IS_DRAGGING_BLOCK_ELEMENT,\n  IS_DRAGGING_BLOCK_TARGET_POSITION,\n  IS_DRAGGING_ELEMENT_TARGET,\n} from '../../internal-utils/weakMaps'\n\nconst debug = debugWithName('components:DraggableBlock')\nconst debugRenders = false\n\n/**\n * @internal\n */\nexport interface DraggableBlockProps {\n  children: ReactNode\n  element: SlateElement\n  readOnly: boolean\n  blockRef: MutableRefObject<HTMLDivElement | null>\n}\n\n/**\n * Implements drag and drop functionality on editor block nodes\n * @internal\n */\nexport const DraggableBlock = ({\n  children,\n  element,\n  readOnly,\n  blockRef,\n}: DraggableBlockProps) => {\n  const editor = useSlateStatic()\n  const dragGhostRef = useRef<HTMLElement>(undefined)\n  const [isDragOver, setIsDragOver] = useState(false)\n  const isVoid = useMemo(\n    () => Editor.isVoid(editor, element),\n    [editor, element],\n  )\n  const isInline = useMemo(\n    () => Editor.isInline(editor, element),\n    [editor, element],\n  )\n\n  const [blockElement, setBlockElement] = useState<HTMLElement | null>(null)\n\n  useEffect(\n    () =>\n      setBlockElement(\n        blockRef ? blockRef.current : ReactEditor.toDOMNode(editor, element),\n      ),\n    [editor, element, blockRef],\n  )\n\n  // Note: this is called not for the dragging block, but for the targets when the block is dragged over them\n  const handleDragOver = useCallback(\n    (event: DragEvent) => {\n      const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor)\n      // debug('Drag over', blockElement)\n      if (!isMyDragOver || !blockElement) {\n        return\n      }\n      event.preventDefault()\n      event.dataTransfer.dropEffect = 'move'\n      IS_DRAGGING_ELEMENT_TARGET.set(editor, element)\n      const elementRect = blockElement.getBoundingClientRect()\n      const offset = elementRect.top\n      const height = elementRect.height\n      const Y = event.pageY\n      const loc = Math.abs(offset - Y)\n      let position: 'top' | 'bottom' = 'bottom'\n      if (element === editor.children[0]) {\n        position = 'top'\n      } else if (loc < height / 2) {\n        position = 'top'\n        IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)\n      } else {\n        position = 'bottom'\n        IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)\n      }\n      if (isMyDragOver === element) {\n        event.dataTransfer.dropEffect = 'none'\n        return\n      }\n      setIsDragOver(true)\n    },\n    [blockElement, editor, element],\n  )\n\n  // Note: this is called not for the dragging block, but for the targets when the block is dragged over them\n  const handleDragLeave = useCallback(() => {\n    setIsDragOver(false)\n  }, [])\n\n  // Note: this is called for the dragging block\n  const handleDragEnd = useCallback(\n    (event: DragEvent) => {\n      const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor)\n      if (targetBlock) {\n        IS_DRAGGING.set(editor, false)\n        event.preventDefault()\n        event.stopPropagation()\n        IS_DRAGGING_ELEMENT_TARGET.delete(editor)\n        if (dragGhostRef.current) {\n          debug('Removing drag ghost')\n          document.body.removeChild(dragGhostRef.current)\n        }\n        const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor)\n        IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor)\n        let targetPath = ReactEditor.findPath(editor, targetBlock)\n        const myPath = ReactEditor.findPath(editor, element)\n        const isBefore = Path.isBefore(myPath, targetPath)\n        if (dragPosition === 'bottom' && !isBefore) {\n          // If it is already at the bottom, don't do anything.\n          if (targetPath[0] >= editor.children.length - 1) {\n            debug('target is already at the bottom, not moving')\n            return\n          }\n          const originalPath = targetPath\n          targetPath = Path.next(targetPath)\n          debug(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath,\n            )}`,\n          )\n        }\n        if (\n          dragPosition === 'top' &&\n          isBefore &&\n          targetPath[0] !== editor.children.length - 1\n        ) {\n          const originalPath = targetPath\n          targetPath = Path.previous(targetPath)\n          debug(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath,\n            )}`,\n          )\n        }\n        if (Path.equals(targetPath, myPath)) {\n          event.preventDefault()\n          debug('targetPath and myPath is the same, not moving')\n          return\n        }\n        debug(\n          `Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(\n            targetPath,\n          )} (${dragPosition})`,\n        )\n        Transforms.moveNodes(editor, {at: myPath, to: targetPath})\n        editor.onChange()\n        return\n      }\n      debug('No target element, not doing anything')\n    },\n    [editor, element],\n  )\n  // Note: this is called not for the dragging block, but for the drop target\n  const handleDrop = useCallback(\n    (event: DragEvent) => {\n      if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {\n        debug('On drop (prevented)', element)\n        event.preventDefault()\n        event.stopPropagation()\n        setIsDragOver(false)\n      }\n    },\n    [editor, element],\n  )\n  // Note: this is called for the dragging block\n  const handleDrag = useCallback(\n    (event: DragEvent) => {\n      if (!isVoid) {\n        IS_DRAGGING_BLOCK_ELEMENT.delete(editor)\n        return\n      }\n      IS_DRAGGING.set(editor, true)\n      IS_DRAGGING_BLOCK_ELEMENT.set(editor, element)\n      event.stopPropagation() // Stop propagation so that leafs don't get this and take focus/selection!\n\n      const target = event.target\n\n      if (target instanceof HTMLElement) {\n        target.style.opacity = '1'\n      }\n    },\n    [editor, element, isVoid],\n  )\n\n  // Note: this is called for the dragging block\n  const handleDragStart = useCallback(\n    (event: DragEvent) => {\n      if (!isVoid || isInline) {\n        debug('Not dragging block')\n        IS_DRAGGING_BLOCK_ELEMENT.delete(editor)\n        IS_DRAGGING.set(editor, false)\n        return\n      }\n      debug('Drag start')\n      IS_DRAGGING.set(editor, true)\n      if (event.dataTransfer) {\n        event.dataTransfer.setData('application/portable-text', 'something')\n        event.dataTransfer.effectAllowed = 'move'\n      }\n      // Clone blockElement so that it will not be visually clipped by scroll-containers etc.\n      // The application that uses the portable-text-editor may indicate the element used as\n      // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.\n      if (blockElement && blockElement instanceof HTMLElement) {\n        let dragGhost = blockElement.cloneNode(true) as HTMLElement\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost = customGhost as HTMLElement\n        }\n\n        // Set the `data-dragged` attribute so the consumer can style the element while it’s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        if (document.body) {\n          dragGhostRef.current = dragGhost\n          dragGhost.style.position = 'absolute'\n          dragGhost.style.left = '-99999px'\n          dragGhost.style.boxSizing = 'border-box'\n          document.body.appendChild(dragGhost)\n          const rect = blockElement.getBoundingClientRect()\n          const x = event.clientX - rect.left\n          const y = event.clientY - rect.top\n          dragGhost.style.width = `${rect.width}px`\n          dragGhost.style.height = `${rect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      }\n      handleDrag(event)\n    },\n    [blockElement, editor, handleDrag, isInline, isVoid],\n  )\n\n  const isDraggingOverFirstBlock =\n    isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor)\n  const isDraggingOverLastBlock =\n    isDragOver &&\n    editor.children[editor.children.length - 1] ===\n      IS_DRAGGING_ELEMENT_TARGET.get(editor)\n  const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor)\n\n  const isDraggingOverTop =\n    isDraggingOverFirstBlock ||\n    (isDragOver &&\n      !isDraggingOverFirstBlock &&\n      !isDraggingOverLastBlock &&\n      dragPosition === 'top')\n  const isDraggingOverBottom =\n    isDraggingOverLastBlock ||\n    (isDragOver &&\n      !isDraggingOverFirstBlock &&\n      !isDraggingOverLastBlock &&\n      dragPosition === 'bottom')\n\n  const dropIndicator = useMemo(\n    () => (\n      <div\n        className=\"pt-drop-indicator\"\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: 1,\n          borderBottom: '1px solid currentColor',\n          zIndex: 5,\n        }}\n      />\n    ),\n    [],\n  )\n\n  if (readOnly) {\n    return <>{children}</>\n  }\n\n  if (debugRenders) {\n    debug('render')\n  }\n\n  return (\n    <div\n      draggable={isVoid}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDragEnd={handleDragEnd}\n      onDrop={handleDrop}\n    >\n      {isDraggingOverTop && dropIndicator}\n      {children}\n      {isDraggingOverBottom && dropIndicator}\n    </div>\n  )\n}\n\nDraggableBlock.displayName = 'DraggableBlock'\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useMemo,\n  useRef,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport ObjectNode from '../nodes/DefaultObject'\nimport {DraggableBlock} from './DraggableBlock'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected && editor.selection && Range.isCollapsed(editor.selection)) ||\n    false\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(editor),\n      )[0],\n    [editor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (editor.isInline(element)) {\n    const path = ReactEditor.findPath(editor, element)\n    const [block] = Editor.node(editor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <ObjectNode value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <ObjectNode value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        <DraggableBlock\n          element={element}\n          readOnly={readOnly}\n          blockRef={blockRef}\n        >\n          <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        </DraggableBlock>\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(editor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <ObjectNode value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div key={element._key} {...attributes} className={className}>\n      {children}\n      <DraggableBlock element={element} readOnly={readOnly} blockRef={blockRef}>\n        <div ref={blockRef} contentEditable={false}>\n          {renderedBlockFromProps ? (\n            renderedBlockFromProps\n          ) : (\n            <ObjectNode value={value} />\n          )}\n        </div>\n      </DraggableBlock>\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import {createContext, useContext} from 'react'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\n/**\n * A React context for sharing the editor object.\n */\nexport const PortableTextEditorContext =\n  createContext<PortableTextEditor | null>(null)\n\n/**\n * @deprecated Use `useEditor` to get the current editor instance.\n * @public\n * Get the current editor object from the React context.\n */\nexport const usePortableTextEditor = (): PortableTextEditor => {\n  const editor = useContext(PortableTextEditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`usePortableTextEditor\\` hook must be used inside the <PortableTextEditor> component's context.`,\n    )\n  }\n\n  return editor\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport {useCallback, type ReactNode} from 'react'\n\ntype Props = {\n  annotation: PortableTextObject\n  children: ReactNode\n}\nexport function DefaultAnnotation(props: Props) {\n  const handleClick = useCallback(\n    () => alert(JSON.stringify(props.annotation)),\n    [props.annotation],\n  )\n  return (\n    <span style={{color: 'blue'}} onClick={handleClick}>\n      {props.children}\n    </span>\n  )\n}\n\nDefaultAnnotation.displayName = 'DefaultAnnotation'\n","import {Schema} from '@sanity/schema'\n\nexport function compileType(rawType: any) {\n  return Schema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType],\n  }).get(rawType.name)\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {Editor} from 'slate'\nimport {assign, emit, setup} from 'xstate'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorSchema} from './define-schema'\n\nconst FLUSH_PATCHES_THROTTLED_MS = process.env.NODE_ENV === 'test' ? 500 : 1000\n\n/**\n * Makes sure editor mutation events are debounced\n */\nexport const mutationMachine = setup({\n  types: {\n    context: {} as {\n      pendingPatches: Array<Patch>\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as {type: 'patch'; patch: Patch},\n    input: {} as {\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n    },\n    emitted: {} as\n      | {\n          type: 'has pending patches'\n        }\n      | {\n          type: 'mutation'\n          patches: Array<Patch>\n          snapshot: Array<PortableTextBlock> | undefined\n        },\n  },\n  actions: {\n    'emit has pending patches': emit({type: 'has pending patches'}),\n    'emit mutation': emit(({context}) => ({\n      type: 'mutation' as const,\n      patches: context.pendingPatches,\n      snapshot: fromSlateValue(\n        context.slateEditor.children,\n        context.schema.block.name,\n        KEY_TO_VALUE_ELEMENT.get(context.slateEditor),\n      ),\n    })),\n    'clear pending patches': assign({\n      pendingPatches: [],\n    }),\n    'defer patch': assign({\n      pendingPatches: ({context, event}) => [\n        ...context.pendingPatches,\n        event.patch,\n      ],\n    }),\n  },\n  guards: {\n    'slate is normalizing': ({context}) =>\n      Editor.isNormalizing(context.slateEditor),\n  },\n}).createMachine({\n  id: 'mutation',\n  context: ({input}) => ({\n    pendingPatches: [],\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n  }),\n  initial: 'idle',\n  states: {\n    'idle': {\n      on: {\n        patch: {\n          actions: ['defer patch', 'emit has pending patches'],\n          target: 'has pending patches',\n        },\n      },\n    },\n    'has pending patches': {\n      after: {\n        [FLUSH_PATCHES_THROTTLED_MS]: [\n          {\n            guard: 'slate is normalizing',\n            target: 'idle',\n            actions: ['emit mutation', 'clear pending patches'],\n          },\n          {\n            reenter: true,\n          },\n        ],\n      },\n      on: {\n        patch: {\n          actions: ['defer patch'],\n          reenter: true,\n        },\n      },\n    },\n  },\n})\n","import {insert, set, setIfMissing, unset} from '@portabletext/patches'\nimport {\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {flatten, isPlainObject, uniq} from 'lodash'\nimport type {\n  InvalidValueResolution,\n  PortableTextMemberSchemaTypes,\n} from '../types/editor'\n\nexport interface Validation {\n  valid: boolean\n  resolution: InvalidValueResolution | null\n  value: PortableTextBlock[] | undefined\n}\n\nexport function validateValue(\n  value: PortableTextBlock[] | undefined,\n  types: PortableTextMemberSchemaTypes,\n  keyGenerator: () => string,\n): Validation {\n  let resolution: InvalidValueResolution | null = null\n  let valid = true\n  const validChildTypes = [\n    types.span.name,\n    ...types.inlineObjects.map((t) => t.name),\n  ]\n  const validBlockTypes = [\n    types.block.name,\n    ...types.blockObjects.map((t) => t.name),\n  ]\n\n  // Undefined is allowed\n  if (value === undefined) {\n    return {valid: true, resolution: null, value}\n  }\n  // Only lengthy arrays are allowed in the editor.\n  if (!Array.isArray(value) || value.length === 0) {\n    return {\n      valid: false,\n      resolution: {\n        patches: [unset([])],\n        description:\n          'Editor value must be an array of Portable Text blocks, or undefined.',\n        action: 'Unset the value',\n        item: value,\n\n        i18n: {\n          description:\n            'inputs.portable-text.invalid-value.not-an-array.description',\n          action: 'inputs.portable-text.invalid-value.not-an-array.action',\n        },\n      },\n      value,\n    }\n  }\n  if (\n    value.some((blk: PortableTextBlock, index: number): boolean => {\n      // Is the block an object?\n      if (!isPlainObject(blk)) {\n        resolution = {\n          patches: [unset([index])],\n          description: `Block must be an object, got ${String(blk)}`,\n          action: `Unset invalid item`,\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.not-an-object.description',\n            action: 'inputs.portable-text.invalid-value.not-an-object.action',\n            values: {index},\n          },\n        }\n        return true\n      }\n      // Test that every block has a _key prop\n      if (!blk._key || typeof blk._key !== 'string') {\n        resolution = {\n          patches: [set({...blk, _key: keyGenerator()}, [index])],\n          description: `Block at index ${index} is missing required _key.`,\n          action: 'Set the block with a random _key value',\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.missing-key.description',\n            action: 'inputs.portable-text.invalid-value.missing-key.action',\n            values: {index},\n          },\n        }\n        return true\n      }\n      // Test that every block has valid _type\n      if (!blk._type || !validBlockTypes.includes(blk._type)) {\n        // Special case where block type is set to default 'block', but the block type is named something else according to the schema.\n        if (blk._type === 'block') {\n          const currentBlockTypeName = types.block.name\n          resolution = {\n            patches: [\n              set({...blk, _type: currentBlockTypeName}, [{_key: blk._key}]),\n            ],\n            description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n            action: `Use type '${currentBlockTypeName}'`,\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.incorrect-block-type.description',\n              action:\n                'inputs.portable-text.invalid-value.incorrect-block-type.action',\n              values: {key: blk._key, expectedTypeName: currentBlockTypeName},\n            },\n          }\n          return true\n        }\n\n        // If the block has no `_type`, but aside from that is a valid Portable Text block\n        if (\n          !blk._type &&\n          isPortableTextTextBlock({...blk, _type: types.block.name})\n        ) {\n          resolution = {\n            patches: [\n              set({...blk, _type: types.block.name}, [{_key: blk._key}]),\n            ],\n            description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n            action: `Use type '${types.block.name}'`,\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-block-type.description',\n              action:\n                'inputs.portable-text.invalid-value.missing-block-type.action',\n              values: {key: blk._key, expectedTypeName: types.block.name},\n            },\n          }\n          return true\n        }\n\n        if (!blk._type) {\n          resolution = {\n            patches: [unset([{_key: blk._key}])],\n            description: `Block with _key '${blk._key}' is missing an _type property`,\n            action: 'Remove the block',\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-type.description',\n              action: 'inputs.portable-text.invalid-value.missing-type.action',\n              values: {key: blk._key},\n            },\n          }\n          return true\n        }\n\n        resolution = {\n          patches: [unset([{_key: blk._key}])],\n          description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n          action: 'Remove the block',\n          item: blk,\n\n          i18n: {\n            description:\n              'inputs.portable-text.invalid-value.disallowed-type.description',\n            action: 'inputs.portable-text.invalid-value.disallowed-type.action',\n            values: {key: blk._key, typeName: blk._type},\n          },\n        }\n        return true\n      }\n\n      // Test regular text blocks\n      if (blk._type === types.block.name) {\n        const textBlock = blk as PortableTextTextBlock\n        // Test that it has a valid children property (array)\n        if (textBlock.children && !Array.isArray(textBlock.children)) {\n          resolution = {\n            patches: [set({children: []}, [{_key: textBlock._key}])],\n            description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n            action: 'Reset the children property',\n            item: textBlock,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.missing-or-invalid-children.description',\n              action:\n                'inputs.portable-text.invalid-value.missing-or-invalid-children.action',\n              values: {key: textBlock._key},\n            },\n          }\n          return true\n        }\n        // Test that children is set and lengthy\n        if (\n          textBlock.children === undefined ||\n          (Array.isArray(textBlock.children) && textBlock.children.length === 0)\n        ) {\n          const newSpan = {\n            _type: types.span.name,\n            _key: keyGenerator(),\n            text: '',\n            marks: [],\n          }\n          resolution = {\n            autoResolve: true,\n            patches: [\n              setIfMissing([], [{_key: blk._key}, 'children']),\n              insert([newSpan], 'after', [{_key: blk._key}, 'children', 0]),\n            ],\n            description: `Children for text block with _key '${blk._key}' is empty.`,\n            action: 'Insert an empty text',\n            item: blk,\n\n            i18n: {\n              description:\n                'inputs.portable-text.invalid-value.empty-children.description',\n              action:\n                'inputs.portable-text.invalid-value.empty-children.action',\n              values: {key: blk._key},\n            },\n          }\n          return true\n        }\n\n        const allUsedMarks = uniq(\n          flatten(\n            textBlock.children\n              .filter((cld) => cld._type === types.span.name)\n              .map((cld) => cld.marks || []),\n          ) as string[],\n        )\n\n        // Test that all markDefs are in use (remove orphaned markDefs)\n        if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n          const unusedMarkDefs: string[] = uniq(\n            blk.markDefs\n              .map((def) => def._key)\n              .filter((key) => !allUsedMarks.includes(key)),\n          )\n          if (unusedMarkDefs.length > 0) {\n            resolution = {\n              autoResolve: true,\n              patches: unusedMarkDefs.map((markDefKey) =>\n                unset([{_key: blk._key}, 'markDefs', {_key: markDefKey}]),\n              ),\n              description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\n                ', ',\n              )}.`,\n              action: 'Remove unused mark definition item',\n              item: blk,\n              i18n: {\n                description:\n                  'inputs.portable-text.invalid-value.orphaned-mark-defs.description',\n                action:\n                  'inputs.portable-text.invalid-value.orphaned-mark-defs.action',\n                values: {\n                  key: blk._key,\n                  unusedMarkDefs: unusedMarkDefs.map((m) => m.toString()),\n                },\n              },\n            }\n            return true\n          }\n        }\n\n        // Test that every annotation mark used has a definition\n        const annotationMarks = allUsedMarks.filter(\n          (mark) => !types.decorators.map((dec) => dec.value).includes(mark),\n        )\n        const orphanedMarks = annotationMarks.filter(\n          (mark) =>\n            textBlock.markDefs === undefined ||\n            !textBlock.markDefs.find((def) => def._key === mark),\n        )\n        if (orphanedMarks.length > 0) {\n          const spanChildren = textBlock.children.filter(\n            (cld) =>\n              cld._type === types.span.name &&\n              Array.isArray(cld.marks) &&\n              cld.marks.some((mark) => orphanedMarks.includes(mark)),\n          ) as PortableTextSpan[]\n          if (spanChildren) {\n            const orphaned = orphanedMarks.join(', ')\n            resolution = {\n              autoResolve: true,\n              patches: spanChildren.map((child) => {\n                return set(\n                  (child.marks || []).filter(\n                    (cMrk) => !orphanedMarks.includes(cMrk),\n                  ),\n                  [{_key: blk._key}, 'children', {_key: child._key}, 'marks'],\n                )\n              }),\n              description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n              action: 'Remove invalid marks',\n              item: blk,\n\n              i18n: {\n                description:\n                  'inputs.portable-text.invalid-value.orphaned-marks.description',\n                action:\n                  'inputs.portable-text.invalid-value.orphaned-marks.action',\n                values: {\n                  key: blk._key,\n                  orphanedMarks: orphanedMarks.map((m) => m.toString()),\n                },\n              },\n            }\n            return true\n          }\n        }\n\n        // Test every child\n        if (\n          textBlock.children.some((child, cIndex: number) => {\n            if (!isPlainObject(child)) {\n              resolution = {\n                patches: [unset([{_key: blk._key}, 'children', cIndex])],\n                description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n                action: 'Remove the item',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.non-object-child.description',\n                  action:\n                    'inputs.portable-text.invalid-value.non-object-child.action',\n                  values: {key: blk._key, index: cIndex},\n                },\n              }\n              return true\n            }\n\n            if (!child._key || typeof child._key !== 'string') {\n              const newChild = {...child, _key: keyGenerator()}\n              resolution = {\n                autoResolve: true,\n                patches: [\n                  set(newChild, [{_key: blk._key}, 'children', cIndex]),\n                ],\n                description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n                action: 'Set a new random _key on the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.missing-child-key.description',\n                  action:\n                    'inputs.portable-text.invalid-value.missing-child-key.action',\n                  values: {key: blk._key, index: cIndex},\n                },\n              }\n              return true\n            }\n\n            // Verify that children have valid types\n            if (!child._type) {\n              resolution = {\n                patches: [\n                  unset([{_key: blk._key}, 'children', {_key: child._key}]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n                action: 'Remove the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.missing-child-type.description',\n                  action:\n                    'inputs.portable-text.invalid-value.missing-child-type.action',\n                  values: {key: blk._key, childKey: child._key},\n                },\n              }\n              return true\n            }\n\n            if (!validChildTypes.includes(child._type)) {\n              resolution = {\n                patches: [\n                  unset([{_key: blk._key}, 'children', {_key: child._key}]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n                action: 'Remove the object',\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.disallowed-child-type.description',\n                  action:\n                    'inputs.portable-text.invalid-value.disallowed-child-type.action',\n                  values: {\n                    key: blk._key,\n                    childKey: child._key,\n                    childType: child._type,\n                  },\n                },\n              }\n              return true\n            }\n\n            // Verify that spans have .text property that is a string\n            if (\n              child._type === types.span.name &&\n              typeof child.text !== 'string'\n            ) {\n              resolution = {\n                patches: [\n                  set({...child, text: ''}, [\n                    {_key: blk._key},\n                    'children',\n                    {_key: child._key},\n                  ]),\n                ],\n                description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n                action: `Write an empty text property to the object`,\n                item: blk,\n\n                i18n: {\n                  description:\n                    'inputs.portable-text.invalid-value.invalid-span-text.description',\n                  action:\n                    'inputs.portable-text.invalid-value.invalid-span-text.action',\n                  values: {key: blk._key, childKey: child._key},\n                },\n              }\n              return true\n            }\n            return false\n          })\n        ) {\n          valid = false\n        }\n      }\n      return false\n    })\n  ) {\n    valid = false\n  }\n  return {valid, resolution, value}\n}\n","import type {Editor} from 'slate'\nimport {IS_PROCESSING_REMOTE_CHANGES} from './weakMaps'\n\nexport function withRemoteChanges(editor: Editor, fn: () => void): void {\n  const prev = isChangingRemotely(editor) || false\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, true)\n  fn()\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, prev)\n}\n\nexport function isChangingRemotely(editor: Editor): boolean | undefined {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor)\n}\n","import type {Editor} from 'slate'\n\nexport const PATCHING: WeakMap<Editor, boolean | undefined> = new WeakMap()\n\nexport function withoutPatching(editor: Editor, fn: () => void): void {\n  const prev = isPatching(editor)\n  PATCHING.set(editor, false)\n  fn()\n  PATCHING.set(editor, prev)\n}\n\nexport function isPatching(editor: Editor): boolean | undefined {\n  return PATCHING.get(editor)\n}\n","function cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2]\n  ];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, { checkLines: !1, deadline }), diffsb = doDiff(text1b, text2b, { checkLines: !1, deadline });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [\n    bestLongTextA || \"\",\n    bestLongTextB || \"\",\n    bestShortTextA || \"\",\n    bestShortTextB || \"\",\n    bestCommon || \"\"\n  ] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return { chars1, chars2, lineArray };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2]\n    ];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n          0,\n          commonlength\n        ) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(\n      text,\n      text1.substring(text1.length - MAX_BITS),\n      expectedLoc + text1.length - MAX_BITS\n    ), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, { checkLines: !1 });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nvar __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTS = {\n  margin: 4\n};\nfunction getDefaultOpts(opts = {}) {\n  return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);\n}\nfunction make(a, b, options) {\n  if (typeof a == \"string\" && typeof b == \"string\") {\n    let diffs = diff(a, b, { checkLines: !0 });\n    return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));\n  }\n  if (a && Array.isArray(a) && typeof b > \"u\")\n    return _make(diffText1(a), a, getDefaultOpts(options));\n  if (typeof a == \"string\" && b && Array.isArray(b))\n    return _make(a, b, getDefaultOpts(options));\n  throw new Error(\"Unknown call format to make()\");\n}\nfunction _make(textA, diffs, options) {\n  if (diffs.length === 0)\n    return [];\n  const patches = [];\n  let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);\n    switch (!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);\n        break;\n      case DIFF_EQUAL:\n        diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);\n        break;\n      default:\n        throw new Error(\"Unknown diff type\");\n    }\n    diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);\n  }\n  return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;\n}\nfunction addContext(patch, text, opts) {\n  if (text.length === 0)\n    return;\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;\n  for (; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin; )\n    padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  padding += opts.margin;\n  let prefixStart = patch.start2 - padding;\n  prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;\n  const prefix = text.substring(prefixStart, patch.start2);\n  prefix && patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);\n  let suffixEnd = patch.start2 + patch.length1 + padding;\n  suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);\n  suffix && patch.diffs.push([DIFF_EQUAL, suffix]);\n  const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);\n  patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch (ex) {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nfunction stringify(patches) {\n  return patches.map(stringifyPatch).join(\"\");\n}\nfunction stringifyPatch(patch) {\n  const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;\n  let coords1;\n  utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;\n  let coords2;\n  utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;\n  const text = [`@@ -${coords1} +${coords2} @@\n`];\n  let op;\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = \"+\";\n        break;\n      case DIFF_DELETE:\n        op = \"-\";\n        break;\n      case DIFF_EQUAL:\n        op = \" \";\n        break;\n      default:\n        throw new Error(\"Unknown patch operation.\");\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\n`;\n  }\n  return text.join(\"\").replace(/%20/g, \" \");\n}\nexport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  adjustIndiciesToUcs2,\n  apply as applyPatches,\n  cleanupEfficiency,\n  cleanupSemantic,\n  diff as makeDiff,\n  make as makePatches,\n  match,\n  parse as parsePatch,\n  stringifyPatch,\n  stringify as stringifyPatches\n};\n//# sourceMappingURL=index.js.map\n","import type {Editor} from 'slate'\n\nconst IS_UDOING: WeakMap<Editor, boolean | undefined> = new WeakMap()\nconst IS_REDOING: WeakMap<Editor, boolean | undefined> = new WeakMap()\n\nexport function withUndoing(editor: Editor, fn: () => void) {\n  const prev = isUndoing(editor)\n  IS_UDOING.set(editor, true)\n  fn()\n  IS_UDOING.set(editor, prev)\n}\n\nexport function isUndoing(editor: Editor) {\n  return IS_UDOING.get(editor) ?? false\n}\n\nexport function setIsUndoing(editor: Editor, isUndoing: boolean) {\n  IS_UDOING.set(editor, isUndoing)\n}\n\nexport function withRedoing(editor: Editor, fn: () => void) {\n  const prev = isRedoing(editor)\n  IS_REDOING.set(editor, true)\n  fn()\n  IS_REDOING.set(editor, prev)\n}\n\nexport function isRedoing(editor: Editor) {\n  return IS_REDOING.get(editor) ?? false\n}\n\nexport function setIsRedoing(editor: Editor, isRedoing: boolean) {\n  IS_REDOING.set(editor, isRedoing)\n}\n","/**\n * This plugin will make the editor support undo/redo on the local state only.\n * The undo/redo steps are rebased against incoming patches since the step occurred.\n */\n\nimport type {Patch} from '@portabletext/patches'\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  parsePatch,\n} from '@sanity/diff-match-patch'\nimport type {ObjectSchemaType, PortableTextBlock} from '@sanity/types'\nimport {flatten, isEqual} from 'lodash'\nimport {\n  Editor,\n  Operation,\n  Path,\n  Transforms,\n  type Descendant,\n  type SelectionOperation,\n} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {\n  isRedoing,\n  isUndoing,\n  setIsRedoing,\n  setIsUndoing,\n  withRedoing,\n  withUndoing,\n} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withUndoRedo')\nconst debugVerbose = debug.enabled && false\n\nconst SAVING = new WeakMap<Editor, boolean | undefined>()\nconst REMOTE_PATCHES = new WeakMap<\n  Editor,\n  {\n    patch: Patch\n    time: Date\n    snapshot: PortableTextBlock[] | undefined\n    previousSnapshot: PortableTextBlock[] | undefined\n  }[]\n>()\nconst UNDO_STEP_LIMIT = 1000\n\nconst isSaving = (editor: Editor): boolean | undefined => {\n  const state = SAVING.get(editor)\n  return state === undefined ? true : state\n}\n\nexport interface Options {\n  editorActor: EditorActor\n  blockSchemaType: ObjectSchemaType\n  subscriptions: Array<() => () => void>\n}\n\nconst getRemotePatches = (editor: Editor) => {\n  if (!REMOTE_PATCHES.get(editor)) {\n    REMOTE_PATCHES.set(editor, [])\n  }\n  return REMOTE_PATCHES.get(editor) || []\n}\n\nexport function createWithUndoRedo(\n  options: Options,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  const {editorActor, blockSchemaType} = options\n\n  return (editor: PortableTextSlateEditor) => {\n    let previousSnapshot: PortableTextBlock[] | undefined = fromSlateValue(\n      editor.children,\n      blockSchemaType.name,\n    )\n    const remotePatches = getRemotePatches(editor)\n\n    options.subscriptions.push(() => {\n      debug('Subscribing to patches')\n      const sub = editorActor.on('patches', ({patches, snapshot}) => {\n        let reset = false\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== 'local' && remotePatches) {\n            if (patch.type === 'unset' && patch.path.length === 0) {\n              debug(\n                'Someone else cleared the content, resetting undo/redo history',\n              )\n              editor.history = {undos: [], redos: []}\n              remotePatches.splice(0, remotePatches.length)\n              SAVING.set(editor, true)\n              reset = true\n              return\n            }\n            remotePatches.push({\n              patch,\n              time: new Date(),\n              snapshot,\n              previousSnapshot,\n            })\n          }\n        })\n        previousSnapshot = snapshot\n      })\n      return () => {\n        debug('Unsubscribing to patches')\n        sub.unsubscribe()\n      }\n    })\n\n    editor.history = {undos: [], redos: []}\n    const {apply} = editor\n    editor.apply = (op: Operation) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      const {operations, history} = editor\n      const {undos} = history\n      const step = undos[undos.length - 1]\n      const lastOp =\n        step && step.operations && step.operations[step.operations.length - 1]\n      const overwrite = shouldOverwrite(op, lastOp)\n      const save = isSaving(editor)\n\n      let merge = true\n      if (save) {\n        if (!step) {\n          merge = false\n        } else if (operations.length === 0) {\n          merge = shouldMerge(op, lastOp) || overwrite\n        }\n\n        if (step && merge) {\n          step.operations.push(op)\n        } else {\n          const newStep = {\n            operations: [\n              ...(editor.selection === null\n                ? []\n                : [createSelectOperation(editor)]),\n              op,\n            ],\n            timestamp: new Date(),\n          }\n          undos.push(newStep)\n          debug('Created new undo step', step)\n        }\n\n        while (undos.length > UNDO_STEP_LIMIT) {\n          undos.shift()\n        }\n\n        if (shouldClear(op)) {\n          history.redos = []\n        }\n      }\n      apply(op)\n    }\n\n    editor.undo = () => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        return\n      }\n      const {undos} = editor.history\n      if (undos.length > 0) {\n        const step = undos[undos.length - 1]\n        debug('Undoing', step)\n        if (step.operations.length > 0) {\n          const otherPatches = remotePatches.filter(\n            (item) => item.time >= step.timestamp,\n          )\n          let transformedOperations = step.operations\n          otherPatches.forEach((item) => {\n            transformedOperations = flatten(\n              transformedOperations.map((op) =>\n                transformOperation(\n                  editor,\n                  item.patch,\n                  op,\n                  item.snapshot,\n                  item.previousSnapshot,\n                ),\n              ),\n            )\n          })\n          const reversedOperations = transformedOperations\n            .map(Operation.inverse)\n            .reverse()\n\n          try {\n            Editor.withoutNormalizing(editor, () => {\n              withUndoing(editor, () => {\n                withoutSaving(editor, () => {\n                  reversedOperations.forEach((op) => {\n                    editor.apply(op)\n                  })\n                })\n              })\n            })\n            editor.normalize()\n            editor.onChange()\n          } catch (err) {\n            debug('Could not perform undo step', err)\n            remotePatches.splice(0, remotePatches.length)\n            Transforms.deselect(editor)\n            editor.history = {undos: [], redos: []}\n            SAVING.set(editor, true)\n            setIsUndoing(editor, false)\n            editor.onChange()\n            return\n          }\n          editor.history.redos.push(step)\n          editor.history.undos.pop()\n        }\n      }\n    }\n\n    editor.redo = () => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        return\n      }\n      const {redos} = editor.history\n      if (redos.length > 0) {\n        const step = redos[redos.length - 1]\n        debug('Redoing', step)\n        if (step.operations.length > 0) {\n          const otherPatches = remotePatches.filter(\n            (item) => item.time >= step.timestamp,\n          )\n          let transformedOperations = step.operations\n          otherPatches.forEach((item) => {\n            transformedOperations = flatten(\n              transformedOperations.map((op) =>\n                transformOperation(\n                  editor,\n                  item.patch,\n                  op,\n                  item.snapshot,\n                  item.previousSnapshot,\n                ),\n              ),\n            )\n          })\n          try {\n            Editor.withoutNormalizing(editor, () => {\n              withRedoing(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.forEach((op) => {\n                    editor.apply(op)\n                  })\n                })\n              })\n            })\n            editor.normalize()\n            editor.onChange()\n          } catch (err) {\n            debug('Could not perform redo step', err)\n            remotePatches.splice(0, remotePatches.length)\n            Transforms.deselect(editor)\n            editor.history = {undos: [], redos: []}\n            SAVING.set(editor, true)\n            setIsRedoing(editor, false)\n            editor.onChange()\n            return\n          }\n          editor.history.undos.push(step)\n          editor.history.redos.pop()\n        }\n      }\n    }\n\n    // Plugin return\n    return editor\n  }\n}\n\n/**\n * This will adjust the operation paths and offsets according to the\n * remote patches by other editors since the step operations was performed.\n */\nfunction transformOperation(\n  editor: PortableTextSlateEditor,\n  patch: Patch,\n  operation: Operation,\n  snapshot: PortableTextBlock[] | undefined,\n  previousSnapshot: PortableTextBlock[] | undefined,\n): Operation[] {\n  if (debugVerbose) {\n    debug(\n      `Adjusting '${operation.type}' operation paths for '${patch.type}' patch`,\n    )\n    debug(`Operation ${JSON.stringify(operation)}`)\n    debug(`Patch ${JSON.stringify(patch)}`)\n  }\n\n  const transformedOperation = {...operation}\n\n  if (patch.type === 'insert' && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) =>\n      isEqual({_key: blk._key}, patch.path[0]),\n    )\n    debug(\n      `Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`,\n    )\n    return [\n      adjustBlockPath(\n        transformedOperation,\n        patch.items.length,\n        insertBlockIndex,\n      ),\n    ]\n  }\n\n  if (patch.type === 'unset' && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) =>\n      isEqual({_key: blk._key}, patch.path[0]),\n    )\n    // If this operation is targeting the same block that got removed, return empty\n    if (\n      'path' in transformedOperation &&\n      Array.isArray(transformedOperation.path) &&\n      transformedOperation.path[0] === unsetBlockIndex\n    ) {\n      debug('Skipping transformation that targeted removed block')\n      return []\n    }\n    if (debugVerbose) {\n      debug(`Selection ${JSON.stringify(editor.selection)}`)\n      debug(\n        `Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`,\n      )\n    }\n    return [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]\n  }\n\n  // Someone reset the whole value\n  if (patch.type === 'unset' && patch.path.length === 0) {\n    debug(\n      `Adjusting selection for unset everything patch and ${operation.type} operation`,\n    )\n    return []\n  }\n\n  if (patch.type === 'diffMatchPatch') {\n    const operationTargetBlock = findOperationTargetBlock(\n      editor,\n      transformedOperation,\n    )\n    if (\n      !operationTargetBlock ||\n      !isEqual({_key: operationTargetBlock._key}, patch.path[0])\n    ) {\n      return [transformedOperation]\n    }\n    const diffPatches = parsePatch(patch.value)\n    diffPatches.forEach((diffPatch) => {\n      let adjustOffsetBy = 0\n      let changedOffset = diffPatch.utf8Start1\n      const {diffs} = diffPatch\n      diffs.forEach((diff, index) => {\n        const [diffType, text] = diff\n        if (diffType === DIFF_INSERT) {\n          adjustOffsetBy += text.length\n          changedOffset += text.length\n        } else if (diffType === DIFF_DELETE) {\n          adjustOffsetBy -= text.length\n          changedOffset -= text.length\n        } else if (diffType === DIFF_EQUAL) {\n          // Only up to the point where there are no other changes\n          if (!diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL)) {\n            changedOffset += text.length\n          }\n        }\n      })\n      // Adjust accordingly if someone inserted text in the same node before us\n      if (transformedOperation.type === 'insert_text') {\n        if (changedOffset < transformedOperation.offset) {\n          transformedOperation.offset += adjustOffsetBy\n        }\n      }\n      // Adjust accordingly if someone removed text in the same node before us\n      if (transformedOperation.type === 'remove_text') {\n        if (\n          changedOffset <=\n          transformedOperation.offset - transformedOperation.text.length\n        ) {\n          transformedOperation.offset += adjustOffsetBy\n        }\n      }\n      // Adjust set_selection operation's points to new offset\n      if (transformedOperation.type === 'set_selection') {\n        const currentFocus = transformedOperation.properties?.focus\n          ? {...transformedOperation.properties.focus}\n          : undefined\n        const currentAnchor = transformedOperation?.properties?.anchor\n          ? {...transformedOperation.properties.anchor}\n          : undefined\n        const newFocus = transformedOperation?.newProperties?.focus\n          ? {...transformedOperation.newProperties.focus}\n          : undefined\n        const newAnchor = transformedOperation?.newProperties?.anchor\n          ? {...transformedOperation.newProperties.anchor}\n          : undefined\n        if ((currentFocus && currentAnchor) || (newFocus && newAnchor)) {\n          const points = [currentFocus, currentAnchor, newFocus, newAnchor]\n          points.forEach((point) => {\n            if (point && changedOffset < point.offset) {\n              point.offset += adjustOffsetBy\n            }\n          })\n          if (currentFocus && currentAnchor) {\n            transformedOperation.properties = {\n              focus: currentFocus,\n              anchor: currentAnchor,\n            }\n          }\n          if (newFocus && newAnchor) {\n            transformedOperation.newProperties = {\n              focus: newFocus,\n              anchor: newAnchor,\n            }\n          }\n        }\n      }\n    })\n    return [transformedOperation]\n  }\n  return [transformedOperation]\n}\n/**\n * Adjust the block path for a operation\n */\nfunction adjustBlockPath(\n  operation: Operation,\n  level: number,\n  blockIndex: number,\n): Operation {\n  const transformedOperation = {...operation}\n  if (\n    blockIndex >= 0 &&\n    transformedOperation.type !== 'set_selection' &&\n    Array.isArray(transformedOperation.path) &&\n    transformedOperation.path[0] >= blockIndex + level &&\n    transformedOperation.path[0] + level > -1\n  ) {\n    const newPath = [\n      transformedOperation.path[0] + level,\n      ...transformedOperation.path.slice(1),\n    ]\n    transformedOperation.path = newPath\n  }\n  if (transformedOperation.type === 'set_selection') {\n    const currentFocus = transformedOperation.properties?.focus\n      ? {...transformedOperation.properties.focus}\n      : undefined\n    const currentAnchor = transformedOperation?.properties?.anchor\n      ? {...transformedOperation.properties.anchor}\n      : undefined\n    const newFocus = transformedOperation?.newProperties?.focus\n      ? {...transformedOperation.newProperties.focus}\n      : undefined\n    const newAnchor = transformedOperation?.newProperties?.anchor\n      ? {...transformedOperation.newProperties.anchor}\n      : undefined\n    if ((currentFocus && currentAnchor) || (newFocus && newAnchor)) {\n      const points = [currentFocus, currentAnchor, newFocus, newAnchor]\n      points.forEach((point) => {\n        if (\n          point &&\n          point.path[0] >= blockIndex + level &&\n          point.path[0] + level > -1\n        ) {\n          point.path = [point.path[0] + level, ...point.path.slice(1)]\n        }\n      })\n      if (currentFocus && currentAnchor) {\n        transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor,\n        }\n      }\n      if (newFocus && newAnchor) {\n        transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor,\n        }\n      }\n    }\n  }\n  //   // Assign fresh point objects (we don't want to mutate the original ones)\n  return transformedOperation\n}\n\n// Helper functions for editor.apply above\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  // Text input\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path) &&\n    op.text !== ' ' // Tokenize between words\n  ) {\n    return true\n  }\n\n  // Text deletion\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  // Don't merge\n  return false\n}\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined,\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n\nexport function withoutSaving(editor: Editor, fn: () => void): void {\n  const prev = isSaving(editor)\n  SAVING.set(editor, false)\n  fn()\n  SAVING.set(editor, prev)\n}\n\nfunction createSelectOperation(editor: Editor): SelectionOperation {\n  return {\n    type: 'set_selection',\n    properties: {...editor.selection},\n    newProperties: {...editor.selection},\n  }\n}\n\nfunction findOperationTargetBlock(\n  editor: PortableTextSlateEditor,\n  operation: Operation,\n): Descendant | undefined {\n  let block: Descendant | undefined\n  if (operation.type === 'set_selection' && editor.selection) {\n    block = editor.children[editor.selection.focus.path[0]]\n  } else if ('path' in operation) {\n    block = editor.children[operation.path[0]]\n  }\n  return block\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {Editor, Text, Transforms, type Descendant, type Node} from 'slate'\nimport {\n  assertEvent,\n  assign,\n  emit,\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {debugWithName} from '../internal-utils/debug'\nimport {validateValue} from '../internal-utils/validateValue'\nimport {toSlateValue, VOID_CHILD_KEY} from '../internal-utils/values'\nimport {\n  isChangingRemotely,\n  withRemoteChanges,\n} from '../internal-utils/withChanges'\nimport {withoutPatching} from '../internal-utils/withoutPatching'\nimport type {PickFromUnion} from '../type-utils'\nimport type {\n  InvalidValueResolution,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport type {EditorSchema} from './define-schema'\nimport {withoutSaving} from './plugins/createWithUndoRedo'\n\ntype SyncValueEvent =\n  | {\n      type: 'patch'\n      patch: Patch\n    }\n  | {\n      type: 'invalid value'\n      resolution: InvalidValueResolution | null\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'value changed'\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'done syncing'\n      value: Array<PortableTextBlock> | undefined\n    }\n\nconst syncValueCallback: CallbackLogicFunction<\n  AnyEventObject,\n  SyncValueEvent,\n  {\n    context: {\n      keyGenerator: () => string\n      previousValue: Array<PortableTextBlock> | undefined\n      readOnly: boolean\n      schema: EditorSchema\n    }\n    slateEditor: PortableTextSlateEditor\n    streamBlocks: boolean\n    value: Array<PortableTextBlock> | undefined\n  }\n> = ({sendBack, input}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks,\n  })\n}\n\nconst syncValueLogic = fromCallback(syncValueCallback)\n\n/**\n * Sync value with the editor state\n *\n * Normally nothing here should apply, and the editor and the real world are perfectly aligned.\n *\n * Inconsistencies could happen though, so we need to check the editor state when the value changes.\n *\n * For performance reasons, it makes sense to also do the content validation here, as we already\n * iterate over the value and can validate only the new content that is actually changed.\n *\n * @internal\n */\nexport const syncMachine = setup({\n  types: {\n    context: {} as {\n      initialValueSynced: boolean\n      isProcessingLocalChanges: boolean\n      keyGenerator: () => string\n      schema: EditorSchema\n      readOnly: boolean\n      slateEditor: PortableTextSlateEditor\n      pendingValue: Array<PortableTextBlock> | undefined\n      previousValue: Array<PortableTextBlock> | undefined\n    },\n    input: {} as {\n      keyGenerator: () => string\n      schema: EditorSchema\n      readOnly: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'has pending patches'\n        }\n      | {\n          type: 'mutation'\n        }\n      | {\n          type: 'update value'\n          value: Array<PortableTextBlock> | undefined\n        }\n      | {\n          type: 'update readOnly'\n          readOnly: boolean\n        }\n      | SyncValueEvent,\n    emitted: {} as\n      | PickFromUnion<\n          SyncValueEvent,\n          'type',\n          'invalid value' | 'patch' | 'value changed'\n        >\n      | {type: 'done syncing initial value'},\n  },\n  actions: {\n    'assign initial value synced': assign({\n      initialValueSynced: true,\n    }),\n    'assign readOnly': assign({\n      readOnly: ({event}) => {\n        assertEvent(event, 'update readOnly')\n        return event.readOnly\n      },\n    }),\n    'assign pending value': assign({\n      pendingValue: ({event}) => {\n        assertEvent(event, 'update value')\n        return event.value\n      },\n    }),\n    'clear pending value': assign({\n      pendingValue: undefined,\n    }),\n    'assign previous value': assign({\n      previousValue: ({event}) => {\n        assertEvent(event, 'done syncing')\n        return event.value\n      },\n    }),\n    'emit done syncing initial value': emit({\n      type: 'done syncing initial value',\n    }),\n  },\n  guards: {\n    'initial value synced': ({context}) => context.initialValueSynced,\n    'is busy': ({context}) => {\n      return (\n        !context.readOnly &&\n        (context.isProcessingLocalChanges ||\n          (isChangingRemotely(context.slateEditor) ?? false))\n      )\n    },\n    'value changed while syncing': ({context, event}) => {\n      assertEvent(event, 'done syncing')\n      return context.pendingValue !== event.value\n    },\n    'pending value equals previous value': ({context}) =>\n      !(\n        context.previousValue === undefined &&\n        context.pendingValue === undefined\n      ) && isEqual(context.pendingValue, context.previousValue),\n  },\n  actors: {\n    'sync value': syncValueLogic,\n  },\n}).createMachine({\n  id: 'sync',\n  context: ({input}) => ({\n    initialValueSynced: false,\n    isProcessingLocalChanges: false,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: undefined,\n    previousValue: undefined,\n  }),\n  on: {\n    'has pending patches': {\n      actions: assign({\n        isProcessingLocalChanges: true,\n      }),\n    },\n    'mutation': {\n      actions: assign({\n        isProcessingLocalChanges: false,\n      }),\n    },\n    'update readOnly': {\n      actions: ['assign readOnly'],\n    },\n  },\n  type: 'parallel',\n  states: {\n    'setting up': {\n      initial: 'syncing initial value',\n      states: {\n        'syncing initial value': {\n          always: {\n            guard: 'initial value synced',\n            target: 'done syncing initial value',\n          },\n        },\n        'done syncing initial value': {\n          entry: ['emit done syncing initial value'],\n          type: 'final',\n        },\n      },\n    },\n    'syncing': {\n      initial: 'idle',\n      states: {\n        idle: {\n          on: {\n            'update value': [\n              {\n                guard: 'is busy',\n                target: 'busy',\n                actions: ['assign pending value'],\n              },\n              {\n                target: 'syncing',\n                actions: ['assign pending value'],\n              },\n            ],\n          },\n        },\n        busy: {\n          after: {\n            1000: [\n              {\n                guard: 'is busy',\n                reenter: true,\n              },\n              {\n                target: 'syncing',\n              },\n            ],\n          },\n          on: {\n            'update value': [\n              {\n                actions: ['assign pending value'],\n              },\n            ],\n          },\n        },\n        syncing: {\n          always: {\n            guard: 'pending value equals previous value',\n            target: 'idle',\n            actions: ['clear pending value', 'assign initial value synced'],\n          },\n          invoke: {\n            src: 'sync value',\n            id: 'sync value',\n            input: ({context}) => {\n              return {\n                context: {\n                  keyGenerator: context.keyGenerator,\n                  previousValue: context.previousValue,\n                  readOnly: context.readOnly,\n                  schema: context.schema,\n                },\n                slateEditor: context.slateEditor,\n                streamBlocks: !context.initialValueSynced,\n                value: context.pendingValue,\n              }\n            },\n          },\n          on: {\n            'update value': {\n              actions: ['assign pending value'],\n            },\n            'patch': {\n              actions: [emit(({event}) => event)],\n            },\n            'invalid value': {\n              actions: [emit(({event}) => event)],\n            },\n            'value changed': {\n              actions: [emit(({event}) => event)],\n            },\n            'done syncing': [\n              {\n                guard: 'value changed while syncing',\n                actions: [\n                  'assign previous value',\n                  'assign initial value synced',\n                ],\n                reenter: true,\n              },\n              {\n                target: 'idle',\n                actions: [\n                  'clear pending value',\n                  'assign previous value',\n                  'assign initial value synced',\n                ],\n              },\n            ],\n          },\n        },\n      },\n    },\n  },\n})\n\nconst debug = debugWithName('hook:useSyncValue')\n\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value,\n}: {\n  context: {\n    keyGenerator: () => string\n    previousValue: Array<PortableTextBlock> | undefined\n    readOnly: boolean\n    schema: EditorSchema\n  }\n  sendBack: (event: SyncValueEvent) => void\n  slateEditor: PortableTextSlateEditor\n  streamBlocks: boolean\n  value: PortableTextBlock[] | undefined\n}) {\n  let isChanged = false\n  let isValid = true\n\n  const hadSelection = !!slateEditor.selection\n\n  // If empty value, remove everything in the editor and insert a placeholder block\n  if (!value || value.length === 0) {\n    debug('Value is empty')\n    Editor.withoutNormalizing(slateEditor, () => {\n      withoutSaving(slateEditor, () => {\n        withoutPatching(slateEditor, () => {\n          if (hadSelection) {\n            Transforms.deselect(slateEditor)\n          }\n          const childrenLength = slateEditor.children.length\n          slateEditor.children.forEach((_, index) => {\n            Transforms.removeNodes(slateEditor, {\n              at: [childrenLength - 1 - index],\n            })\n          })\n          Transforms.insertNodes(\n            slateEditor,\n            slateEditor.pteCreateTextBlock({decorators: []}),\n            {at: [0]},\n          )\n          // Add a new selection in the top of the document\n          if (hadSelection) {\n            Transforms.select(slateEditor, [0, 0])\n          }\n        })\n      })\n    })\n    isChanged = true\n  }\n  // Remove, replace or add nodes according to what is changed.\n  if (value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema,\n    })\n\n    await new Promise<void>((resolve) => {\n      Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, async () => {\n            const childrenLength = slateEditor.children.length\n\n            // Remove blocks that have become superfluous\n            if (slateValueFromProps.length < childrenLength) {\n              for (\n                let i = childrenLength - 1;\n                i > slateValueFromProps.length - 1;\n                i--\n              ) {\n                Transforms.removeNodes(slateEditor, {\n                  at: [i],\n                })\n              }\n              isChanged = true\n            }\n\n            for await (const [currentBlock, currentBlockIndex] of getBlocks({\n              slateValue: slateValueFromProps,\n              streamBlocks,\n            })) {\n              // Go through all of the blocks and see if they need to be updated\n              const {blockChanged, blockValid} = syncBlock({\n                context,\n                sendBack,\n                block: currentBlock,\n                index: currentBlockIndex,\n                slateEditor,\n                value,\n              })\n              isChanged = blockChanged || isChanged\n              isValid = isValid && blockValid\n            }\n\n            resolve()\n          })\n        })\n      })\n    })\n  }\n\n  if (!isValid) {\n    debug('Invalid value, returning')\n    sendBack({type: 'done syncing', value})\n    return\n  }\n\n  if (isChanged) {\n    debug('Server value changed, syncing editor')\n    try {\n      slateEditor.onChange()\n    } catch (err) {\n      console.error(err)\n      sendBack({\n        type: 'invalid value',\n        resolution: null,\n        value,\n      })\n      sendBack({type: 'done syncing', value})\n      return\n    }\n    if (hadSelection && !slateEditor.selection) {\n      Transforms.select(slateEditor, {\n        anchor: {path: [0, 0], offset: 0},\n        focus: {path: [0, 0], offset: 0},\n      })\n      slateEditor.onChange()\n    }\n    sendBack({type: 'value changed', value})\n  } else {\n    debug('Server value and editor value is equal, no need to sync.')\n  }\n\n  sendBack({type: 'done syncing', value})\n}\n\nasync function* getBlocks({\n  slateValue,\n  streamBlocks,\n}: {\n  slateValue: Array<Descendant>\n  streamBlocks: boolean\n}) {\n  let index = 0\n  for await (const block of slateValue) {\n    if (streamBlocks) {\n      await new Promise<void>((resolve) => setTimeout(resolve, 0))\n    }\n    yield [block, index] as const\n    index++\n  }\n}\n\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value,\n}: {\n  context: {\n    keyGenerator: () => string\n    previousValue: Array<PortableTextBlock> | undefined\n    readOnly: boolean\n    schema: EditorSchema\n  }\n  sendBack: (event: SyncValueEvent) => void\n  block: Descendant\n  index: number\n  slateEditor: PortableTextSlateEditor\n  value: Array<PortableTextBlock>\n}) {\n  let blockChanged = false\n  let blockValid = true\n  const currentBlock = block\n  const currentBlockIndex = index\n  const oldBlock = slateEditor.children[currentBlockIndex]\n  const hasChanges = oldBlock && !isEqual(currentBlock, oldBlock)\n\n  Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]]\n          const validation = validateValue(\n            validationValue,\n            context.schema,\n            context.keyGenerator,\n          )\n          // Resolve validations that can be resolved automatically, without involving the user (but only if the value was changed)\n          if (\n            !validation.valid &&\n            validation.resolution?.autoResolve &&\n            validation.resolution?.patches.length > 0\n          ) {\n            // Only apply auto resolution if the value has been populated before and is different from the last one.\n            if (\n              !context.readOnly &&\n              context.previousValue &&\n              context.previousValue !== value\n            ) {\n              // Give a console warning about the fact that it did an auto resolution\n              console.warn(\n                `${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`,\n              )\n              validation.resolution.patches.forEach((patch) => {\n                sendBack({type: 'patch', patch})\n              })\n            }\n          }\n          if (validation.valid || validation.resolution?.autoResolve) {\n            if (oldBlock._key === currentBlock._key) {\n              if (debug.enabled) debug('Updating block', oldBlock, currentBlock)\n              _updateBlock(\n                slateEditor,\n                currentBlock,\n                oldBlock,\n                currentBlockIndex,\n              )\n            } else {\n              if (debug.enabled)\n                debug('Replacing block', oldBlock, currentBlock)\n              _replaceBlock(slateEditor, currentBlock, currentBlockIndex)\n            }\n            blockChanged = true\n          } else {\n            sendBack({\n              type: 'invalid value',\n              resolution: validation.resolution,\n              value,\n            })\n            blockValid = false\n          }\n        }\n\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]]\n          const validation = validateValue(\n            validationValue,\n            context.schema,\n            context.keyGenerator,\n          )\n          if (debug.enabled)\n            debug(\n              'Validating and inserting new block in the end of the value',\n              currentBlock,\n            )\n          if (validation.valid || validation.resolution?.autoResolve) {\n            Transforms.insertNodes(slateEditor, currentBlock, {\n              at: [currentBlockIndex],\n            })\n          } else {\n            debug('Invalid', validation)\n            sendBack({\n              type: 'invalid value',\n              resolution: validation.resolution,\n              value,\n            })\n            blockValid = false\n          }\n        }\n      })\n    })\n  })\n\n  return {blockChanged, blockValid}\n}\n\n/**\n * This code is moved out of the above algorithm to keep complexity down.\n * @internal\n */\nfunction _replaceBlock(\n  slateEditor: PortableTextSlateEditor,\n  currentBlock: Descendant,\n  currentBlockIndex: number,\n) {\n  // While replacing the block and the current selection focus is on the replaced block,\n  // temporarily deselect the editor then optimistically try to restore the selection afterwards.\n  const currentSelection = slateEditor.selection\n  const selectionFocusOnBlock =\n    currentSelection && currentSelection.focus.path[0] === currentBlockIndex\n  if (selectionFocusOnBlock) {\n    Transforms.deselect(slateEditor)\n  }\n  Transforms.removeNodes(slateEditor, {at: [currentBlockIndex]})\n  Transforms.insertNodes(slateEditor, currentBlock, {at: [currentBlockIndex]})\n  slateEditor.onChange()\n  if (selectionFocusOnBlock) {\n    Transforms.select(slateEditor, currentSelection)\n  }\n}\n\n/**\n * This code is moved out of the above algorithm to keep complexity down.\n * @internal\n */\nfunction _updateBlock(\n  slateEditor: PortableTextSlateEditor,\n  currentBlock: Descendant,\n  oldBlock: Descendant,\n  currentBlockIndex: number,\n) {\n  // Update the root props on the block\n  Transforms.setNodes(slateEditor, currentBlock as Partial<Node>, {\n    at: [currentBlockIndex],\n  })\n  // Text block's need to have their children updated as well (setNode does not target a node's children)\n  if (\n    slateEditor.isTextBlock(currentBlock) &&\n    slateEditor.isTextBlock(oldBlock)\n  ) {\n    const oldBlockChildrenLength = oldBlock.children.length\n    if (currentBlock.children.length < oldBlockChildrenLength) {\n      // Remove any children that have become superfluous\n      Array.from(\n        Array(oldBlockChildrenLength - currentBlock.children.length),\n      ).forEach((_, index) => {\n        const childIndex = oldBlockChildrenLength - 1 - index\n        if (childIndex > 0) {\n          debug('Removing child')\n          Transforms.removeNodes(slateEditor, {\n            at: [currentBlockIndex, childIndex],\n          })\n        }\n      })\n    }\n    currentBlock.children.forEach(\n      (currentBlockChild, currentBlockChildIndex) => {\n        const oldBlockChild = oldBlock.children[currentBlockChildIndex]\n        const isChildChanged = !isEqual(currentBlockChild, oldBlockChild)\n        const isTextChanged = !isEqual(\n          currentBlockChild.text,\n          oldBlockChild?.text,\n        )\n        const path = [currentBlockIndex, currentBlockChildIndex]\n        if (isChildChanged) {\n          // Update if this is the same child\n          if (currentBlockChild._key === oldBlockChild?._key) {\n            debug('Updating changed child', currentBlockChild, oldBlockChild)\n            Transforms.setNodes(\n              slateEditor,\n              currentBlockChild as Partial<Node>,\n              {\n                at: path,\n              },\n            )\n            const isSpanNode =\n              Text.isText(currentBlockChild) &&\n              currentBlockChild._type === 'span' &&\n              Text.isText(oldBlockChild) &&\n              oldBlockChild._type === 'span'\n            if (isSpanNode && isTextChanged) {\n              Transforms.delete(slateEditor, {\n                at: {\n                  focus: {path, offset: 0},\n                  anchor: {path, offset: oldBlockChild.text.length},\n                },\n              })\n              Transforms.insertText(slateEditor, currentBlockChild.text, {\n                at: path,\n              })\n              slateEditor.onChange()\n            } else if (!isSpanNode) {\n              // If it's a inline block, also update the void text node key\n              debug('Updating changed inline object child', currentBlockChild)\n              Transforms.setNodes(\n                slateEditor,\n                {_key: VOID_CHILD_KEY},\n                {\n                  at: [...path, 0],\n                  voids: true,\n                },\n              )\n            }\n            // Replace the child if _key's are different\n          } else if (oldBlockChild) {\n            debug('Replacing child', currentBlockChild)\n            Transforms.removeNodes(slateEditor, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            Transforms.insertNodes(slateEditor, currentBlockChild as Node, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            slateEditor.onChange()\n            // Insert it if it didn't exist before\n          } else if (!oldBlockChild) {\n            debug('Inserting new child', currentBlockChild)\n            Transforms.insertNodes(slateEditor, currentBlockChild as Node, {\n              at: [currentBlockIndex, currentBlockChildIndex],\n            })\n            slateEditor.onChange()\n          }\n        }\n      },\n    )\n  }\n}\n","import {useActorRef, useSelector} from '@xstate/react'\nimport {useEffect} from 'react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {mutationMachine} from '../mutation-machine'\nimport {syncMachine} from '../sync-machine'\n\nconst debug = debugWithName('component:PortableTextEditor:Synchronizer')\n\n/**\n * @internal\n */\nexport interface SynchronizerProps {\n  editorActor: EditorActor\n  slateEditor: PortableTextSlateEditor\n}\n\n/**\n * Synchronizes the server value with the editor, and provides various contexts for the editor state.\n * @internal\n */\nexport function Synchronizer(props: SynchronizerProps) {\n  const {editorActor, slateEditor} = props\n\n  const value = useSelector(props.editorActor, (s) => s.context.value)\n  const readOnly = useSelector(props.editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const syncActorRef = useActorRef(syncMachine, {\n    input: {\n      keyGenerator: props.editorActor.getSnapshot().context.keyGenerator,\n      readOnly: props.editorActor\n        .getSnapshot()\n        .matches({'edit mode': 'read only'}),\n      schema: props.editorActor.getSnapshot().context.schema,\n      slateEditor,\n    },\n  })\n  const mutationActorRef = useActorRef(mutationMachine, {\n    input: {\n      schema: editorActor.getSnapshot().context.schema,\n      slateEditor,\n    },\n  })\n\n  useEffect(() => {\n    const subscription = mutationActorRef.on('*', (event) => {\n      if (event.type === 'has pending patches') {\n        syncActorRef.send({type: 'has pending patches'})\n      }\n      if (event.type === 'mutation') {\n        syncActorRef.send({type: 'mutation'})\n        editorActor.send({\n          type: 'mutation',\n          patches: event.patches,\n          snapshot: event.snapshot,\n          value: event.snapshot,\n        })\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [mutationActorRef, syncActorRef, editorActor])\n\n  useEffect(() => {\n    const subscription = syncActorRef.on('*', (event) => {\n      props.editorActor.send(event)\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [props.editorActor, syncActorRef])\n\n  useEffect(() => {\n    syncActorRef.send({type: 'update readOnly', readOnly})\n  }, [syncActorRef, readOnly])\n\n  useEffect(() => {\n    debug('Value from props changed, syncing new value')\n    syncActorRef.send({type: 'update value', value})\n  }, [syncActorRef, value])\n\n  // Subscribe to, and handle changes from the editor\n  useEffect(() => {\n    debug('Subscribing to patch events')\n    const sub = editorActor.on('patch', (event) => {\n      mutationActorRef.send(event)\n    })\n    return () => {\n      debug('Unsubscribing to patch events')\n      sub.unsubscribe()\n    }\n  }, [editorActor, mutationActorRef, slateEditor])\n\n  return null\n}\n\nSynchronizer.displayName = 'Synchronizer'\n","import {\n  diffMatchPatch,\n  insert,\n  set,\n  setIfMissing,\n  unset,\n  type InsertPosition,\n  type Patch,\n} from '@portabletext/patches'\nimport type {Path, PortableTextSpan, PortableTextTextBlock} from '@sanity/types'\nimport {get, isUndefined, omitBy} from 'lodash'\nimport {\n  Text,\n  type Descendant,\n  type InsertNodeOperation,\n  type InsertTextOperation,\n  type MergeNodeOperation,\n  type MoveNodeOperation,\n  type RemoveNodeOperation,\n  type RemoveTextOperation,\n  type SetNodeOperation,\n  type SplitNodeOperation,\n} from 'slate'\nimport type {PatchFunctions} from '../editor/plugins/createWithPatches'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport {debugWithName} from './debug'\nimport {fromSlateValue} from './values'\n\nconst debug = debugWithName('operationToPatches')\n\nexport function createOperationToPatches(\n  types: PortableTextMemberSchemaTypes,\n): PatchFunctions {\n  const textBlockName = types.block.name\n  function insertTextPatch(\n    editor: PortableTextSlateEditor,\n    operation: InsertTextOperation,\n    beforeValue: Descendant[],\n  ) {\n    if (debug.enabled) {\n      debug('Operation', JSON.stringify(operation, null, 2))\n    }\n    const block =\n      editor.isTextBlock(editor.children[operation.path[0]]) &&\n      editor.children[operation.path[0]]\n    if (!block) {\n      throw new Error('Could not find block')\n    }\n    const textChild =\n      editor.isTextBlock(block) &&\n      editor.isTextSpan(block.children[operation.path[1]]) &&\n      (block.children[operation.path[1]] as PortableTextSpan)\n    if (!textChild) {\n      throw new Error('Could not find child')\n    }\n    const path: Path = [\n      {_key: block._key},\n      'children',\n      {_key: textChild._key},\n      'text',\n    ]\n    const prevBlock = beforeValue[operation.path[0]]\n    const prevChild =\n      editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]]\n    const prevText = editor.isTextSpan(prevChild) ? prevChild.text : ''\n    const patch = diffMatchPatch(prevText, textChild.text, path)\n    return patch.value.length ? [patch] : []\n  }\n\n  function removeTextPatch(\n    editor: PortableTextSlateEditor,\n    operation: RemoveTextOperation,\n    beforeValue: Descendant[],\n  ) {\n    const block = editor && editor.children[operation.path[0]]\n    if (!block) {\n      throw new Error('Could not find block')\n    }\n    const child =\n      (editor.isTextBlock(block) && block.children[operation.path[1]]) ||\n      undefined\n    const textChild: PortableTextSpan | undefined = editor.isTextSpan(child)\n      ? child\n      : undefined\n    if (child && !textChild) {\n      throw new Error('Expected span')\n    }\n    if (!textChild) {\n      throw new Error('Could not find child')\n    }\n    const path: Path = [\n      {_key: block._key},\n      'children',\n      {_key: textChild._key},\n      'text',\n    ]\n    const beforeBlock = beforeValue[operation.path[0]]\n    const prevTextChild =\n      editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]]\n    const prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text\n    const patch = diffMatchPatch(prevText || '', textChild.text, path)\n    return patch.value ? [patch] : []\n  }\n\n  function setNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: SetNodeOperation,\n  ) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]]\n      if (typeof block._key !== 'string') {\n        throw new Error('Expected block to have a _key')\n      }\n      const setNode = omitBy(\n        {...editor.children[operation.path[0]], ...operation.newProperties},\n        isUndefined,\n      ) as unknown as Descendant\n      return [\n        set(fromSlateValue([setNode], textBlockName)[0], [{_key: block._key}]),\n      ]\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]]\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]]\n        if (child) {\n          const blockKey = block._key\n          const childKey = child._key\n          const patches: Patch[] = []\n          const keys = Object.keys(operation.newProperties)\n          keys.forEach((keyName) => {\n            // Special case for setting _key on a child. We have to target it by index and not the _key.\n            if (keys.length === 1 && keyName === '_key') {\n              const val = get(operation.newProperties, keyName)\n              patches.push(\n                set(val, [\n                  {_key: blockKey},\n                  'children',\n                  block.children.indexOf(child),\n                  keyName,\n                ]),\n              )\n            } else {\n              const val = get(operation.newProperties, keyName)\n              patches.push(\n                set(val, [\n                  {_key: blockKey},\n                  'children',\n                  {_key: childKey},\n                  keyName,\n                ]),\n              )\n            }\n          })\n          return patches\n        }\n        throw new Error('Could not find a valid child')\n      }\n      throw new Error('Could not find a valid block')\n    } else {\n      throw new Error(\n        `Unexpected path encountered: ${JSON.stringify(operation.path)}`,\n      )\n    }\n  }\n\n  function insertNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: InsertNodeOperation,\n    beforeValue: Descendant[],\n  ): Patch[] {\n    const block = beforeValue[operation.path[0]]\n    const isTextBlock = editor.isTextBlock(block)\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? 'before' : 'after'\n      const beforeBlock = beforeValue[operation.path[0] - 1]\n      const targetKey =\n        operation.path[0] === 0 ? block?._key : beforeBlock?._key\n      if (targetKey) {\n        return [\n          insert(\n            [fromSlateValue([operation.node as Descendant], textBlockName)[0]],\n            position,\n            [{_key: targetKey}],\n          ),\n        ]\n      }\n      return [\n        setIfMissing(beforeValue, []),\n        insert(\n          [fromSlateValue([operation.node as Descendant], textBlockName)[0]],\n          'before',\n          [operation.path[0]],\n        ),\n      ]\n    } else if (\n      isTextBlock &&\n      operation.path.length === 2 &&\n      editor.children[operation.path[0]]\n    ) {\n      const position =\n        block.children.length === 0 || !block.children[operation.path[1] - 1]\n          ? 'before'\n          : 'after'\n      const node = {...operation.node} as Descendant\n      if (!node._type && Text.isText(node)) {\n        node._type = 'span'\n        node.marks = []\n      }\n      const blk = fromSlateValue(\n        [\n          {\n            _key: 'bogus',\n            _type: textBlockName,\n            children: [node],\n          },\n        ],\n        textBlockName,\n      )[0] as PortableTextTextBlock\n      const child = blk.children[0]\n      return [\n        insert([child], position, [\n          {_key: block._key},\n          'children',\n          block.children.length <= 1 || !block.children[operation.path[1] - 1]\n            ? 0\n            : {_key: block.children[operation.path[1] - 1]._key},\n        ]),\n      ]\n    }\n    debug(\n      'Something was inserted into a void block. Not producing editor patches.',\n    )\n    return []\n  }\n\n  function splitNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: SplitNodeOperation,\n    beforeValue: Descendant[],\n  ) {\n    const patches: Patch[] = []\n    const splitBlock = editor.children[operation.path[0]]\n    if (!editor.isTextBlock(splitBlock)) {\n      throw new Error(\n        `Block with path ${JSON.stringify(\n          operation.path[0],\n        )} is not a text block and can't be split`,\n      )\n    }\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]]\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue(\n          [editor.children[operation.path[0] + 1]],\n          textBlockName,\n        )[0]\n        if (targetValue) {\n          patches.push(\n            insert([targetValue], 'after', [{_key: splitBlock._key}]),\n          )\n          const spansToUnset = oldBlock.children.slice(operation.position)\n          spansToUnset.forEach((span) => {\n            const path = [{_key: oldBlock._key}, 'children', {_key: span._key}]\n            patches.push(unset(path))\n          })\n        }\n      }\n      return patches\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]]\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = (\n          fromSlateValue(\n            [\n              {\n                ...splitBlock,\n                children: splitBlock.children.slice(\n                  operation.path[1] + 1,\n                  operation.path[1] + 2,\n                ),\n              } as Descendant,\n            ],\n            textBlockName,\n          )[0] as PortableTextTextBlock\n        ).children\n\n        patches.push(\n          insert(targetSpans, 'after', [\n            {_key: splitBlock._key},\n            'children',\n            {_key: splitSpan._key},\n          ]),\n        )\n        patches.push(\n          set(splitSpan.text, [\n            {_key: splitBlock._key},\n            'children',\n            {_key: splitSpan._key},\n            'text',\n          ]),\n        )\n      }\n      return patches\n    }\n    return patches\n  }\n\n  function removeNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: RemoveNodeOperation,\n    beforeValue: Descendant[],\n  ) {\n    const block = beforeValue[operation.path[0]]\n    if (operation.path.length === 1) {\n      // Remove a single block\n      if (block && block._key) {\n        return [unset([{_key: block._key}])]\n      }\n      throw new Error('Block not found')\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]]\n\n      if (spanToRemove) {\n        const spansMatchingKey = block.children.filter(\n          (span) => span._key === operation.node._key,\n        )\n\n        if (spansMatchingKey.length > 1) {\n          console.warn(\n            `Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`,\n            JSON.stringify(block, null, 2),\n          )\n          return []\n        }\n\n        return [\n          unset([{_key: block._key}, 'children', {_key: spanToRemove._key}]),\n        ]\n      }\n      debug('Span not found in editor trying to remove node')\n      return []\n    } else {\n      debug('Not creating patch inside object block')\n      return []\n    }\n  }\n\n  function mergeNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: MergeNodeOperation,\n    beforeValue: Descendant[],\n  ) {\n    const patches: Patch[] = []\n\n    const block = beforeValue[operation.path[0]]\n    const updatedBlock = editor.children[operation.path[0]]\n\n    if (operation.path.length === 1) {\n      if (block?._key) {\n        const newBlock = fromSlateValue(\n          [editor.children[operation.path[0] - 1]],\n          textBlockName,\n        )[0]\n        patches.push(set(newBlock, [{_key: newBlock._key}]))\n        patches.push(unset([{_key: block._key}]))\n      } else {\n        throw new Error('Target key not found!')\n      }\n    } else if (\n      editor.isTextBlock(block) &&\n      editor.isTextBlock(updatedBlock) &&\n      operation.path.length === 2\n    ) {\n      const updatedSpan =\n        updatedBlock.children[operation.path[1] - 1] &&\n        editor.isTextSpan(updatedBlock.children[operation.path[1] - 1])\n          ? updatedBlock.children[operation.path[1] - 1]\n          : undefined\n      const removedSpan =\n        block.children[operation.path[1]] &&\n        editor.isTextSpan(block.children[operation.path[1]])\n          ? block.children[operation.path[1]]\n          : undefined\n\n      if (updatedSpan) {\n        const spansMatchingKey = block.children.filter(\n          (span) => span._key === updatedSpan._key,\n        )\n\n        if (spansMatchingKey.length === 1) {\n          patches.push(\n            set(updatedSpan.text, [\n              {_key: block._key},\n              'children',\n              {_key: updatedSpan._key},\n              'text',\n            ]),\n          )\n        } else {\n          console.warn(\n            `Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`,\n            JSON.stringify(block, null, 2),\n          )\n        }\n      }\n\n      if (removedSpan) {\n        const spansMatchingKey = block.children.filter(\n          (span) => span._key === removedSpan._key,\n        )\n\n        if (spansMatchingKey.length === 1) {\n          patches.push(\n            unset([{_key: block._key}, 'children', {_key: removedSpan._key}]),\n          )\n        } else {\n          console.warn(\n            `Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`,\n            JSON.stringify(block, null, 2),\n          )\n        }\n      }\n    } else {\n      debug(\"Void nodes can't be merged, not creating any patches\")\n    }\n    return patches\n  }\n\n  function moveNodePatch(\n    editor: PortableTextSlateEditor,\n    operation: MoveNodeOperation,\n    beforeValue: Descendant[],\n  ) {\n    const patches: Patch[] = []\n    const block = beforeValue[operation.path[0]]\n    const targetBlock = beforeValue[operation.newPath[0]]\n\n    if (!targetBlock) {\n      return patches\n    }\n\n    if (operation.path.length === 1) {\n      const position: InsertPosition =\n        operation.path[0] > operation.newPath[0] ? 'before' : 'after'\n      patches.push(unset([{_key: block._key}]))\n      patches.push(\n        insert([fromSlateValue([block], textBlockName)[0]], position, [\n          {_key: targetBlock._key},\n        ]),\n      )\n    } else if (\n      operation.path.length === 2 &&\n      editor.isTextBlock(block) &&\n      editor.isTextBlock(targetBlock)\n    ) {\n      const child = block.children[operation.path[1]]\n      const targetChild = targetBlock.children[operation.newPath[1]]\n      const position =\n        operation.newPath[1] === targetBlock.children.length\n          ? 'after'\n          : 'before'\n      const childToInsert = (\n        fromSlateValue([block], textBlockName)[0] as PortableTextTextBlock\n      ).children[operation.path[1]]\n      patches.push(unset([{_key: block._key}, 'children', {_key: child._key}]))\n      patches.push(\n        insert([childToInsert], position, [\n          {_key: targetBlock._key},\n          'children',\n          {_key: targetChild._key},\n        ]),\n      )\n    }\n    return patches\n  }\n\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch,\n  }\n}\n","import type {Editor} from 'slate'\n\nconst IS_APPLYING_BEHAVIOR_ACTIONS: WeakMap<Editor, boolean | undefined> =\n  new WeakMap()\n\nexport function withApplyingBehaviorActions(editor: Editor, fn: () => void) {\n  const prev = isApplyingBehaviorActions(editor)\n  IS_APPLYING_BEHAVIOR_ACTIONS.set(editor, true)\n  fn()\n  IS_APPLYING_BEHAVIOR_ACTIONS.set(editor, prev)\n}\n\nexport function isApplyingBehaviorActions(editor: Editor) {\n  return IS_APPLYING_BEHAVIOR_ACTIONS.get(editor) ?? false\n}\n","import {Editor} from 'slate'\nimport {toPortableTextRange} from '../../internal-utils/ranges'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport type {EditorActor} from '../editor-machine'\nimport {isApplyingBehaviorActions} from '../with-applying-behavior-actions'\n\nexport function createWithEventListeners(\n  editorActor: EditorActor,\n  subscriptions: Array<() => () => void>,\n) {\n  return function withEventListeners(editor: Editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== undefined) {\n      return editor\n    }\n\n    subscriptions.push(() => {\n      const subscription = editorActor.on('*', (event) => {\n        switch (event.type) {\n          case 'annotation.add': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'annotation.add',\n                annotation: event.annotation,\n              },\n              editor,\n            })\n            break\n          }\n          case 'annotation.remove': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'annotation.remove',\n                annotation: event.annotation,\n              },\n              editor,\n            })\n            break\n          }\n          case 'blur': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'blur',\n              },\n              editor,\n            })\n            break\n          }\n          case 'custom.*': {\n            editorActor.send({\n              type: 'custom behavior event',\n              behaviorEvent: event.event,\n              editor,\n            })\n            break\n          }\n          case 'decorator.toggle': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'decorator.toggle',\n                decorator: event.decorator,\n              },\n              editor,\n            })\n            break\n          }\n          case 'focus': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'focus',\n              },\n              editor,\n            })\n            break\n          }\n          case 'insert.block object': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'insert.block object',\n                placement: event.placement,\n                blockObject: event.blockObject,\n              },\n              editor,\n            })\n            break\n          }\n          case 'insert.inline object': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'insert.inline object',\n                inlineObject: event.inlineObject,\n              },\n              editor,\n            })\n            break\n          }\n          case 'list item.toggle': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'list item.toggle',\n                listItem: event.listItem,\n              },\n              editor,\n            })\n            break\n          }\n          case 'select': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'select',\n                selection: event.selection,\n              },\n              editor,\n            })\n            break\n          }\n          case 'style.toggle': {\n            editorActor.send({\n              type: 'behavior event',\n              behaviorEvent: {\n                type: 'style.toggle',\n                style: event.style,\n              },\n              editor,\n            })\n            break\n          }\n        }\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n\n    const {\n      deleteBackward,\n      deleteForward,\n      insertBreak,\n      insertSoftBreak,\n      insertText,\n      select,\n    } = editor\n\n    editor.deleteBackward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteBackward(unit)\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'delete.backward',\n          unit,\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.deleteForward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteForward(unit)\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'delete.forward',\n          unit,\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertBreak()\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.break',\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertSoftBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertSoftBreak()\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.soft break',\n        },\n        editor,\n      })\n      return\n    }\n\n    editor.insertText = (text, options) => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertText(text, options)\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.text',\n          text,\n          options,\n        },\n        editor,\n        defaultActionCallback: () => {\n          insertText(text, options)\n        },\n      })\n      return\n    }\n\n    editor.select = (location) => {\n      if (isApplyingBehaviorActions(editor)) {\n        select(location)\n        return\n      }\n\n      const range = Editor.range(editor, location)\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          selection: toPortableTextRange(\n            fromSlateValue(\n              editor.children,\n              editorActor.getSnapshot().context.schema.block.name,\n              KEY_TO_VALUE_ELEMENT.get(editor),\n            ),\n            range,\n            editorActor.getSnapshot().context.schema,\n          ),\n        },\n        editor,\n        defaultActionCallback: () => {\n          select(location)\n        },\n      })\n      return\n    }\n\n    return editor\n  }\n}\n","import {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * This plugin makes sure that the PTE maxBlocks prop is respected\n *\n */\nexport function createWithMaxBlocks(editorActor: EditorActor) {\n  return function withMaxBlocks(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply} = editor\n    editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(operation)\n        return\n      }\n\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1\n      if (rows > 0 && editor.children.length >= rows) {\n        if (\n          (operation.type === 'insert_node' ||\n            operation.type === 'split_node') &&\n          operation.path.length === 1\n        ) {\n          return\n        }\n      }\n      apply(operation)\n    }\n    return editor\n  }\n}\n","import {Editor, Element, Node, Transforms} from 'slate'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * This plugin makes sure that every new node in the editor get a new _key prop when created\n *\n */\nexport function createWithObjectKeys(\n  editorActor: EditorActor,\n  schemaTypes: PortableTextMemberSchemaTypes,\n) {\n  return function withKeys(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply, normalizeNode} = editor\n\n    // The default behavior is to always generate a new key here.\n    // For example, when undoing and redoing we want to retain the keys, but\n    // when we create a new bold span by splitting a non-bold-span we want the produced node to get a new key.\n    editor.apply = (operation) => {\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(operation)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(operation)\n        return\n      }\n\n      if (operation.type === 'split_node') {\n        apply({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n          },\n        })\n\n        return\n      }\n\n      if (operation.type === 'insert_node') {\n        if (!Editor.isEditor(operation.node)) {\n          apply({\n            ...operation,\n            node: {\n              ...operation.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n            },\n          })\n\n          return\n        }\n      }\n\n      apply(operation)\n    }\n\n    editor.normalizeNode = (entry) => {\n      const [node, path] = entry\n      if (Element.isElement(node) && node._type === schemaTypes.block.name) {\n        // Set key on block itself\n        if (!node._key) {\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(\n            editor,\n            {_key: editorActor.getSnapshot().context.keyGenerator()},\n            {at: path},\n          )\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n        // Set keys on it's children\n        for (const [child, childPath] of Node.children(editor, path)) {\n          if (!child._key) {\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {_key: editorActor.getSnapshot().context.keyGenerator()},\n              {at: childPath},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n      normalizeNode(entry)\n    }\n\n    return editor\n  }\n}\n","import {\n  applyAll,\n  type DiffMatchPatch,\n  type InsertPatch,\n  type Patch,\n  type SetPatch,\n  type UnsetPatch,\n} from '@portabletext/patches'\nimport {\n  cleanupEfficiency,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  applyPatches as diffMatchPatchApplyPatches,\n  makeDiff,\n  parsePatch,\n} from '@sanity/diff-match-patch'\nimport type {\n  KeyedSegment,\n  Path,\n  PathSegment,\n  PortableTextBlock,\n  PortableTextChild,\n} from '@sanity/types'\nimport {\n  Element,\n  Text,\n  Transforms,\n  type Descendant,\n  type Node,\n  type Path as SlatePath,\n} from 'slate'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport {debugWithName} from './debug'\nimport {toSlateValue} from './values'\nimport {KEY_TO_SLATE_ELEMENT} from './weakMaps'\n\nconst debug = debugWithName('applyPatches')\nconst debugVerbose = debug.enabled && true\n\n/**\n * Creates a function that can apply a patch onto a PortableTextSlateEditor.\n */\nexport function createApplyPatch(\n  schemaTypes: PortableTextMemberSchemaTypes,\n): (editor: PortableTextSlateEditor, patch: Patch) => boolean {\n  return (editor: PortableTextSlateEditor, patch: Patch): boolean => {\n    let changed = false\n\n    // Save some CPU cycles by not stringifying unless enabled\n    if (debugVerbose) {\n      debug(\n        '\\n\\nNEW PATCH =============================================================',\n      )\n      debug(JSON.stringify(patch, null, 2))\n    }\n\n    try {\n      switch (patch.type) {\n        case 'insert':\n          changed = insertPatch(editor, patch, schemaTypes)\n          break\n        case 'unset':\n          changed = unsetPatch(editor, patch)\n          break\n        case 'set':\n          changed = setPatch(editor, patch)\n          break\n        case 'diffMatchPatch':\n          changed = diffMatchPatch(editor, patch)\n          break\n        default:\n          debug('Unhandled patch', patch.type)\n      }\n    } catch (err) {\n      console.error(err)\n    }\n\n    return changed\n  }\n}\n\n/**\n * Apply a remote diff match patch to the current PTE instance.\n * Note meant for external consumption, only exported for testing purposes.\n *\n * @param editor - Portable text slate editor instance\n * @param patch - The PTE diff match patch operation to apply\n * @returns true if the patch was applied, false otherwise\n * @internal\n */\nexport function diffMatchPatch(\n  editor: Pick<\n    PortableTextSlateEditor,\n    'children' | 'isTextBlock' | 'apply' | 'selection' | 'onChange'\n  >,\n  patch: DiffMatchPatch,\n): boolean {\n  const {block, child, childPath} = findBlockAndChildFromPath(\n    editor,\n    patch.path,\n  )\n  if (!block) {\n    debug('Block not found')\n    return false\n  }\n  if (!child || !childPath) {\n    debug('Child not found')\n    return false\n  }\n  const isSpanTextDiffMatchPatch =\n    block &&\n    editor.isTextBlock(block) &&\n    patch.path.length === 4 &&\n    patch.path[1] === 'children' &&\n    patch.path[3] === 'text'\n\n  if (!isSpanTextDiffMatchPatch || !Text.isText(child)) {\n    return false\n  }\n\n  const patches = parsePatch(patch.value)\n  const [newValue] = diffMatchPatchApplyPatches(patches, child.text, {\n    allowExceedingIndices: true,\n  })\n  const diff = cleanupEfficiency(makeDiff(child.text, newValue), 5)\n\n  debugState(editor, 'before')\n  let offset = 0\n  for (const [op, text] of diff) {\n    if (op === DIFF_INSERT) {\n      editor.apply({type: 'insert_text', path: childPath, offset, text})\n      offset += text.length\n    } else if (op === DIFF_DELETE) {\n      editor.apply({type: 'remove_text', path: childPath, offset: offset, text})\n    } else if (op === DIFF_EQUAL) {\n      offset += text.length\n    }\n  }\n  debugState(editor, 'after')\n\n  return true\n}\n\nfunction insertPatch(\n  editor: PortableTextSlateEditor,\n  patch: InsertPatch,\n  schemaTypes: PortableTextMemberSchemaTypes,\n) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath,\n  } = findBlockAndChildFromPath(editor, patch.path)\n  if (!targetBlock || !targetBlockPath) {\n    debug('Block not found')\n    return false\n  }\n  if (patch.path.length > 1 && patch.path[1] !== 'children') {\n    debug('Ignoring patch targeting void value')\n    return false\n  }\n  // Insert blocks\n  if (patch.path.length === 1) {\n    const {items, position} = patch\n    const blocksToInsert = toSlateValue(\n      items as PortableTextBlock[],\n      {schemaTypes},\n      KEY_TO_SLATE_ELEMENT.get(editor),\n    ) as Descendant[]\n    const targetBlockIndex = targetBlockPath[0]\n    const normalizedIdx =\n      position === 'after' ? targetBlockIndex + 1 : targetBlockIndex\n    debug(`Inserting blocks at path [${normalizedIdx}]`)\n    debugState(editor, 'before')\n    Transforms.insertNodes(editor, blocksToInsert, {at: [normalizedIdx]})\n    debugState(editor, 'after')\n    return true\n  }\n  // Insert children\n  const {items, position} = patch\n  if (!targetChild || !targetChildPath) {\n    debug('Child not found')\n    return false\n  }\n  const childrenToInsert =\n    targetBlock &&\n    toSlateValue(\n      [{...targetBlock, children: items as PortableTextChild[]}],\n      {schemaTypes},\n      KEY_TO_SLATE_ELEMENT.get(editor),\n    )\n  const targetChildIndex = targetChildPath[1]\n  const normalizedIdx =\n    position === 'after' ? targetChildIndex + 1 : targetChildIndex\n  const childInsertPath = [targetChildPath[0], normalizedIdx]\n  debug(`Inserting children at path ${childInsertPath}`)\n  debugState(editor, 'before')\n  if (childrenToInsert && Element.isElement(childrenToInsert[0])) {\n    Transforms.insertNodes(editor, childrenToInsert[0].children, {\n      at: childInsertPath,\n    })\n  }\n  debugState(editor, 'after')\n  return true\n}\n\nfunction setPatch(editor: PortableTextSlateEditor, patch: SetPatch) {\n  let value = patch.value\n  if (typeof patch.path[3] === 'string') {\n    value = {}\n    value[patch.path[3]] = patch.value\n  }\n  const {block, blockPath, child, childPath} = findBlockAndChildFromPath(\n    editor,\n    patch.path,\n  )\n\n  if (!block) {\n    debug('Block not found')\n    return false\n  }\n  const isTextBlock = editor.isTextBlock(block)\n\n  // Ignore patches targeting nested void data, like 'markDefs'\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== 'children') {\n    debug('Ignoring setting void value')\n    return false\n  }\n\n  debugState(editor, 'before')\n\n  // If this is targeting a text block child\n  if (isTextBlock && child && childPath) {\n    if (Text.isText(value) && Text.isText(child)) {\n      const newText = child.text\n      const oldText = value.text\n      if (oldText !== newText) {\n        debug('Setting text property')\n        editor.apply({\n          type: 'remove_text',\n          path: childPath,\n          offset: 0,\n          text: newText,\n        })\n        editor.apply({\n          type: 'insert_text',\n          path: childPath,\n          offset: 0,\n          text: value.text,\n        })\n        // call OnChange here to emit the new selection\n        // the user's selection might be interfering with\n        editor.onChange()\n      }\n    } else {\n      debug('Setting non-text property')\n      editor.apply({\n        type: 'set_node',\n        path: childPath,\n        properties: {},\n        newProperties: value as Partial<Node>,\n      })\n    }\n    return true\n  } else if (Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug('Setting block property')\n    const {children, ...nextRest} = value as unknown as PortableTextBlock\n    const {children: prevChildren, ...prevRest} = block || {children: undefined}\n    // Set any block properties\n    editor.apply({\n      type: 'set_node',\n      path: blockPath,\n      properties: {...prevRest},\n      newProperties: nextRest,\n    })\n    // Replace the children in the block\n    // Note that children must be explicitly inserted, and can't be set with set_node\n    debug('Setting children')\n    block.children.forEach((c, cIndex) => {\n      editor.apply({\n        type: 'remove_node',\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c,\n      })\n    })\n    if (Array.isArray(children)) {\n      children.forEach((c, cIndex) => {\n        editor.apply({\n          type: 'insert_node',\n          path: blockPath.concat(cIndex),\n          node: c,\n        })\n      })\n    }\n  } else if (block && 'value' in block) {\n    const newVal = applyAll([block.value], [patch])[0]\n    Transforms.setNodes(editor, {...block, value: newVal}, {at: blockPath})\n    return true\n  }\n  debugState(editor, 'after')\n  return true\n}\n\nfunction unsetPatch(editor: PortableTextSlateEditor, patch: UnsetPatch) {\n  // Value\n  if (patch.path.length === 0) {\n    debug('Removing everything')\n    debugState(editor, 'before')\n    const previousSelection = editor.selection\n    Transforms.deselect(editor)\n    editor.children.forEach((_child, i) => {\n      Transforms.removeNodes(editor, {at: [i]})\n    })\n    Transforms.insertNodes(editor, editor.pteCreateTextBlock({decorators: []}))\n    if (previousSelection) {\n      Transforms.select(editor, {\n        anchor: {path: [0, 0], offset: 0},\n        focus: {path: [0, 0], offset: 0},\n      })\n    }\n    // call OnChange here to emit the new selection\n    editor.onChange()\n    debugState(editor, 'after')\n    return true\n  }\n  const {block, blockPath, child, childPath} = findBlockAndChildFromPath(\n    editor,\n    patch.path,\n  )\n\n  // Single blocks\n  if (patch.path.length === 1) {\n    if (!block || !blockPath) {\n      debug('Block not found')\n      return false\n    }\n    const blockIndex = blockPath[0]\n    debug(`Removing block at path [${blockIndex}]`)\n    debugState(editor, 'before')\n\n    Transforms.removeNodes(editor, {at: [blockIndex]})\n    debugState(editor, 'after')\n    return true\n  }\n\n  // Unset on text block children\n  if (\n    editor.isTextBlock(block) &&\n    patch.path[1] === 'children' &&\n    patch.path.length === 3\n  ) {\n    if (!child || !childPath) {\n      debug('Child not found')\n      return false\n    }\n    debug(`Unsetting child at path ${JSON.stringify(childPath)}`)\n    debugState(editor, 'before')\n    if (debugVerbose) {\n      debug(`Removing child at path ${JSON.stringify(childPath)}`)\n    }\n    Transforms.removeNodes(editor, {at: childPath})\n    debugState(editor, 'after')\n    return true\n  }\n  return false\n}\n\nfunction isKeyedSegment(segment: PathSegment): segment is KeyedSegment {\n  return typeof segment === 'object' && '_key' in segment\n}\n\nfunction debugState(\n  editor: Pick<\n    PortableTextSlateEditor,\n    'children' | 'isTextBlock' | 'apply' | 'selection'\n  >,\n  stateName: string,\n) {\n  if (!debugVerbose) {\n    return\n  }\n\n  debug(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2))\n  debug(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2))\n}\n\nfunction findBlockFromPath(\n  editor: Pick<\n    PortableTextSlateEditor,\n    'children' | 'isTextBlock' | 'apply' | 'selection' | 'onChange'\n  >,\n  path: Path,\n): {block?: Descendant; path?: SlatePath} {\n  let blockIndex = -1\n  const block = editor.children.find((node: Descendant, index: number) => {\n    const isMatch = isKeyedSegment(path[0])\n      ? node._key === path[0]._key\n      : index === path[0]\n    if (isMatch) {\n      blockIndex = index\n    }\n    return isMatch\n  })\n  if (!block) {\n    return {}\n  }\n  return {block, path: [blockIndex] as SlatePath}\n}\n\nfunction findBlockAndChildFromPath(\n  editor: Pick<\n    PortableTextSlateEditor,\n    'children' | 'isTextBlock' | 'apply' | 'selection' | 'onChange'\n  >,\n  path: Path,\n): {\n  child?: Descendant\n  childPath?: SlatePath\n  block?: Descendant\n  blockPath?: SlatePath\n} {\n  const {block, path: blockPath} = findBlockFromPath(editor, path)\n  if (!(Element.isElement(block) && path[1] === 'children')) {\n    return {block, blockPath, child: undefined, childPath: undefined}\n  }\n  let childIndex = -1\n  const child = block.children.find((node, index: number) => {\n    const isMatch = isKeyedSegment(path[2])\n      ? node._key === path[2]._key\n      : index === path[2]\n    if (isMatch) {\n      childIndex = index\n    }\n    return isMatch\n  })\n  if (!child) {\n    return {block, blockPath, child: undefined, childPath: undefined}\n  }\n  return {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex) as SlatePath,\n  }\n}\n","import {insert, setIfMissing, unset, type Patch} from '@portabletext/patches'\nimport {\n  Editor,\n  type Descendant,\n  type InsertNodeOperation,\n  type InsertTextOperation,\n  type MergeNodeOperation,\n  type MoveNodeOperation,\n  type Operation,\n  type RemoveNodeOperation,\n  type RemoveTextOperation,\n  type SetNodeOperation,\n  type SplitNodeOperation,\n} from 'slate'\nimport {createApplyPatch} from '../../internal-utils/applyPatch'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {fromSlateValue, isEqualToEmptyEditor} from '../../internal-utils/values'\nimport {\n  IS_PROCESSING_REMOTE_CHANGES,\n  KEY_TO_VALUE_ELEMENT,\n} from '../../internal-utils/weakMaps'\nimport {withRemoteChanges} from '../../internal-utils/withChanges'\nimport {\n  isPatching,\n  PATCHING,\n  withoutPatching,\n} from '../../internal-utils/withoutPatching'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {withoutSaving} from './createWithUndoRedo'\n\nconst debug = debugWithName('plugin:withPatches')\nconst debugVerbose = false\n\nexport interface PatchFunctions {\n  insertNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: InsertNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  insertTextPatch: (\n    editor: PortableTextSlateEditor,\n    operation: InsertTextOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  mergeNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: MergeNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  moveNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: MoveNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  removeNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: RemoveNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  removeTextPatch: (\n    editor: PortableTextSlateEditor,\n    operation: RemoveTextOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  setNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: SetNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n  splitNodePatch: (\n    editor: PortableTextSlateEditor,\n    operation: SplitNodeOperation,\n    previousChildren: Descendant[],\n  ) => Patch[]\n}\n\ninterface Options {\n  editorActor: EditorActor\n  patchFunctions: PatchFunctions\n  schemaTypes: PortableTextMemberSchemaTypes\n  subscriptions: Array<() => () => void>\n}\n\nexport function createWithPatches({\n  editorActor,\n  patchFunctions,\n  schemaTypes,\n  subscriptions,\n}: Options): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  // The previous editor children are needed to figure out the _key of deleted nodes\n  // The editor.children would no longer contain that information if the node is already deleted.\n  let previousChildren: Descendant[]\n\n  const applyPatch = createApplyPatch(schemaTypes)\n\n  return function withPatches(editor: PortableTextSlateEditor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, false)\n    PATCHING.set(editor, true)\n    previousChildren = [...editor.children]\n\n    const {apply} = editor\n    let bufferedPatches: Patch[] = []\n\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0) {\n        return\n      }\n      const patches = bufferedPatches\n      bufferedPatches = []\n      let changed = false\n      withRemoteChanges(editor, () => {\n        Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              patches.forEach((patch) => {\n                if (debug.enabled)\n                  debug(`Handling remote patch ${JSON.stringify(patch)}`)\n                changed = applyPatch(editor, patch)\n              })\n            })\n          })\n        })\n        if (changed) {\n          editor.normalize()\n          editor.onChange()\n        }\n      })\n    }\n\n    const handlePatches = ({patches}: {patches: Patch[]}) => {\n      const remotePatches = patches.filter((p) => p.origin !== 'local')\n      if (remotePatches.length === 0) {\n        return\n      }\n      bufferedPatches = bufferedPatches.concat(remotePatches)\n      handleBufferedRemotePatches()\n    }\n\n    subscriptions.push(() => {\n      debug('Subscribing to remote patches')\n      const sub = editorActor.on('patches', handlePatches)\n      return () => {\n        debug('Unsubscribing to remote patches')\n        sub.unsubscribe()\n      }\n    })\n\n    editor.apply = (operation: Operation): void | Editor => {\n      let patches: Patch[] = []\n\n      // Update previous children here before we apply\n      previousChildren = editor.children\n\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes)\n\n      // Apply the operation\n      apply(operation)\n\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes)\n\n      if (!isPatching(editor)) {\n        if (debugVerbose && debug.enabled)\n          debug(\n            `Editor is not producing patch for operation ${operation.type}`,\n            operation,\n          )\n        return editor\n      }\n\n      // If the editor was empty and now isn't, insert the placeholder into it.\n      if (\n        editorWasEmpty &&\n        !editorIsEmpty &&\n        operation.type !== 'set_selection'\n      ) {\n        patches.push(insert(previousChildren, 'before', [0]))\n      }\n\n      switch (operation.type) {\n        case 'insert_text':\n          patches = [\n            ...patches,\n            ...patchFunctions.insertTextPatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'remove_text':\n          patches = [\n            ...patches,\n            ...patchFunctions.removeTextPatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'remove_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.removeNodePatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'split_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.splitNodePatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'insert_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.insertNodePatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'set_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.setNodePatch(editor, operation, previousChildren),\n          ]\n          break\n        case 'merge_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.mergeNodePatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        case 'move_node':\n          patches = [\n            ...patches,\n            ...patchFunctions.moveNodePatch(\n              editor,\n              operation,\n              previousChildren,\n            ),\n          ]\n          break\n        default:\n        // Do nothing\n      }\n\n      // Unset the value if a operation made the editor empty\n      if (\n        !editorWasEmpty &&\n        editorIsEmpty &&\n        ['merge_node', 'set_node', 'remove_text', 'remove_node'].includes(\n          operation.type,\n        )\n      ) {\n        patches = [...patches, unset([])]\n        editorActor.send({\n          type: 'unset',\n          previousValue: fromSlateValue(\n            previousChildren,\n            schemaTypes.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          ),\n        })\n      }\n\n      // Prepend patches with setIfMissing if going from empty editor to something involving a patch.\n      if (editorWasEmpty && patches.length > 0) {\n        patches = [setIfMissing([], []), ...patches]\n      }\n\n      // Emit all patches\n      if (patches.length > 0) {\n        patches.forEach((patch) => {\n          editorActor.send({\n            type: 'patch',\n            patch: {...patch, origin: 'local'},\n          })\n        })\n      }\n      return editor\n    }\n    return editor\n  }\n}\n","import {Editor, Path} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {SlateTextBlock, VoidElement} from '../../types/slate'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPlaceholderBlock')\n\n/**\n * Keep a \"placeholder\" block present when the editor is empty\n *\n */\nexport function createWithPlaceholderBlock(\n  editorActor: EditorActor,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  return function withPlaceholderBlock(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const {apply} = editor\n\n    editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({'edit mode': 'read only'})) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      if (op.type === 'remove_node') {\n        const node = op.node as SlateTextBlock | VoidElement\n        if (op.path[0] === 0 && Editor.isVoid(editor, node)) {\n          // Check next path, if it exists, do nothing\n          const nextPath = Path.next(op.path)\n          // Is removing the first block which is a void (not a text block), add a new empty text block in it, if there is no other element in the next path\n          if (!editor.children[nextPath[0]]) {\n            debug('Adding placeholder block')\n            Editor.insertNode(\n              editor,\n              editor.pteCreateTextBlock({decorators: []}),\n            )\n          }\n        }\n      }\n      apply(op)\n    }\n    return editor\n  }\n}\n","import {Editor, Path, Text as SlateText, Transforms} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPortableTextBlockStyle')\n\nexport function createWithPortableTextBlockStyle(\n  editorActor: EditorActor,\n  types: PortableTextMemberSchemaTypes,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  const defaultStyle = types.styles[0].value\n  return function withPortableTextBlockStyle(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    // Extend Slate's default normalization to reset split node to normal style\n    // if there is no text at the right end of the split.\n    const {normalizeNode} = editor\n\n    editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry\n\n      for (const op of editor.operations) {\n        if (\n          op.type === 'split_node' &&\n          op.path.length === 1 &&\n          editor.isTextBlock(op.properties) &&\n          op.properties.style !== defaultStyle &&\n          op.path[0] === path[0] &&\n          !Path.equals(path, op.path)\n        ) {\n          const [child] = Editor.node(editor, [op.path[0] + 1, 0])\n          if (SlateText.isText(child) && child.text === '') {\n            debug(`Normalizing split node to ${defaultStyle} style`, op)\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {style: defaultStyle},\n              {at: [op.path[0] + 1], voids: false},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      normalizeNode(nodeEntry)\n    }\n\n    return editor\n  }\n}\n","function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\nexport { LIST_NEST_MODE_DIRECT, LIST_NEST_MODE_HTML, buildMarksTree, isPortableTextBlock, isPortableTextListItemBlock, isPortableTextSpan, isPortableTextToolkitList, isPortableTextToolkitSpan, isPortableTextToolkitTextNode, nestLists, sortMarksByOccurences, spanToPlainText, toPlainText };\n//# sourceMappingURL=index.js.map\n","import type {PortableTextSpan} from '@sanity/types'\nimport {Node, Path} from 'slate'\nimport type {PortableTextSlateEditor} from '../types/editor'\n\nexport function getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath,\n}: {\n  editor: PortableTextSlateEditor\n  blockPath: Path\n  spanPath: Path\n}): PortableTextSpan | undefined {\n  let previousSpan: PortableTextSpan | undefined\n\n  for (const [child, childPath] of Node.children(editor, blockPath, {\n    reverse: true,\n  })) {\n    if (!editor.isTextSpan(child)) {\n      continue\n    }\n\n    if (Path.isBefore(childPath, spanPath)) {\n      previousSpan = child\n      break\n    }\n  }\n\n  return previousSpan\n}\n\nexport function getNextSpan({\n  editor,\n  blockPath,\n  spanPath,\n}: {\n  editor: PortableTextSlateEditor\n  blockPath: Path\n  spanPath: Path\n}): PortableTextSpan | undefined {\n  let nextSpan: PortableTextSpan | undefined\n\n  for (const [child, childPath] of Node.children(editor, blockPath)) {\n    if (!editor.isTextSpan(child)) {\n      continue\n    }\n\n    if (Path.isAfter(childPath, spanPath)) {\n      nextSpan = child\n      break\n    }\n  }\n\n  return nextSpan\n}\n","/**\n *\n * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).\n *\n */\n\nimport {isPortableTextBlock, isPortableTextSpan} from '@portabletext/toolkit'\nimport type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {Editor, Element, Node, Path, Range, Text, Transforms} from 'slate'\nimport type {BehaviorActionImplementation} from '../../behavior-actions/behavior.actions'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {getNextSpan, getPreviousSpan} from '../../internal-utils/sibling-utils'\nimport {isChangingRemotely} from '../../internal-utils/withChanges'\nimport {isRedoing, isUndoing} from '../../internal-utils/withUndoRedo'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPortableTextMarkModel')\n\nexport function createWithPortableTextMarkModel(\n  editorActor: EditorActor,\n  types: PortableTextMemberSchemaTypes,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  return function withPortableTextMarkModel(editor: PortableTextSlateEditor) {\n    const {apply, normalizeNode} = editor\n    const decorators = types.decorators.map((t) => t.value)\n\n    // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks\n    editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry\n\n      if (editor.isTextBlock(node)) {\n        const children = Node.children(editor, path)\n\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1]\n\n          if (\n            editor.isTextSpan(child) &&\n            editor.isTextSpan(nextNode) &&\n            child.marks?.every((mark) => nextNode.marks?.includes(mark)) &&\n            nextNode.marks?.every((mark) => child.marks?.includes(mark))\n          ) {\n            debug(\n              'Merging spans',\n              JSON.stringify(child, null, 2),\n              JSON.stringify(nextNode, null, 2),\n            )\n            editorActor.send({type: 'normalizing'})\n            Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: true,\n            })\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      /**\n       * Add missing .markDefs to block nodes\n       */\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug('Adding .markDefs to block node')\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {markDefs: []}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      /**\n       * Add missing .marks to span nodes\n       */\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug('Adding .marks to span node')\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {marks: []}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      /**\n       * Remove annotations from empty spans\n       */\n      if (editor.isTextSpan(node)) {\n        const blockPath = Path.parent(path)\n        const [block] = Editor.node(editor, blockPath)\n        const decorators = types.decorators.map((decorator) => decorator.value)\n        const annotations = node.marks?.filter(\n          (mark) => !decorators.includes(mark),\n        )\n\n        if (editor.isTextBlock(block)) {\n          if (node.text === '' && annotations && annotations.length > 0) {\n            debug('Removing annotations from empty span node')\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {marks: node.marks?.filter((mark) => decorators.includes(mark))},\n              {at: path},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      /**\n       * Remove orphaned annotations from child spans of block nodes\n       */\n      if (editor.isTextBlock(node)) {\n        const decorators = types.decorators.map((decorator) => decorator.value)\n\n        for (const [child, childPath] of Node.children(editor, path)) {\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? []\n            const orphanedAnnotations = marks.filter((mark) => {\n              return (\n                !decorators.includes(mark) &&\n                !node.markDefs?.find((def) => def._key === mark)\n              )\n            })\n\n            if (orphanedAnnotations.length > 0) {\n              debug('Removing orphaned annotations from span node')\n              editorActor.send({type: 'normalizing'})\n              Transforms.setNodes(\n                editor,\n                {\n                  marks: marks.filter(\n                    (mark) => !orphanedAnnotations.includes(mark),\n                  ),\n                },\n                {at: childPath},\n              )\n              editorActor.send({type: 'done normalizing'})\n              return\n            }\n          }\n        }\n      }\n\n      /**\n       * Remove orphaned annotations from span nodes\n       */\n      if (editor.isTextSpan(node)) {\n        const blockPath = Path.parent(path)\n        const [block] = Editor.node(editor, blockPath)\n\n        if (editor.isTextBlock(block)) {\n          const decorators = types.decorators.map(\n            (decorator) => decorator.value,\n          )\n          const marks = node.marks ?? []\n          const orphanedAnnotations = marks.filter((mark) => {\n            return (\n              !decorators.includes(mark) &&\n              !block.markDefs?.find((def) => def._key === mark)\n            )\n          })\n\n          if (orphanedAnnotations.length > 0) {\n            debug('Removing orphaned annotations from span node')\n            editorActor.send({type: 'normalizing'})\n            Transforms.setNodes(\n              editor,\n              {\n                marks: marks.filter(\n                  (mark) => !orphanedAnnotations.includes(mark),\n                ),\n              },\n              {at: path},\n            )\n            editorActor.send({type: 'done normalizing'})\n            return\n          }\n        }\n      }\n\n      // Remove duplicate markDefs\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? []\n        const markDefKeys = new Set<string>()\n        const newMarkDefs: Array<PortableTextObject> = []\n\n        for (const markDef of markDefs) {\n          if (!markDefKeys.has(markDef._key)) {\n            markDefKeys.add(markDef._key)\n            newMarkDefs.push(markDef)\n          }\n        }\n\n        if (markDefs.length !== newMarkDefs.length) {\n          debug('Removing duplicate markDefs')\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(editor, {markDefs: newMarkDefs}, {at: path})\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n      }\n\n      // Check consistency of markDefs (unless we are merging two nodes)\n      if (\n        editor.isTextBlock(node) &&\n        !editor.operations.some(\n          (op) =>\n            op.type === 'merge_node' &&\n            'markDefs' in op.properties &&\n            op.path.length === 1,\n        )\n      ) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => {\n          return node.children.find((child) => {\n            return (\n              Text.isText(child) &&\n              Array.isArray(child.marks) &&\n              child.marks.includes(def._key)\n            )\n          })\n        })\n        if (node.markDefs && !isEqual(newMarkDefs, node.markDefs)) {\n          debug('Removing markDef not in use')\n          editorActor.send({type: 'normalizing'})\n          Transforms.setNodes(\n            editor,\n            {\n              markDefs: newMarkDefs,\n            },\n            {at: path},\n          )\n          editorActor.send({type: 'done normalizing'})\n          return\n        }\n      }\n\n      normalizeNode(nodeEntry)\n    }\n\n    editor.apply = (op) => {\n      /**\n       * We don't want to run any side effects when the editor is processing\n       * remote changes.\n       */\n      if (isChangingRemotely(editor)) {\n        apply(op)\n        return\n      }\n\n      /**\n       * We don't want to run any side effects when the editor is undoing or\n       * redoing operations.\n       */\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply(op)\n        return\n      }\n\n      if (op.type === 'set_selection') {\n        const marks = Editor.marks(editor)\n\n        if (\n          marks &&\n          op.properties &&\n          op.newProperties &&\n          op.properties.anchor &&\n          op.properties.focus &&\n          op.newProperties.anchor &&\n          op.newProperties.focus\n        ) {\n          const previousSelectionIsCollapsed = Range.isCollapsed({\n            anchor: op.properties.anchor,\n            focus: op.properties.focus,\n          })\n          const newSelectionIsCollapsed = Range.isCollapsed({\n            anchor: op.newProperties.anchor,\n            focus: op.newProperties.focus,\n          })\n\n          if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n            const focusSpan: PortableTextSpan | undefined = Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: op.properties.focus,\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0]?.[0]\n            const newFocusSpan: PortableTextSpan | undefined = Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: op.newProperties.focus,\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0]?.[0]\n            const movedToNextSpan =\n              focusSpan &&\n              newFocusSpan &&\n              op.newProperties.focus.path[0] === op.properties.focus.path[0] &&\n              op.newProperties.focus.path[1] ===\n                op.properties.focus.path[1] + 1 &&\n              focusSpan.text.length === op.properties.focus.offset &&\n              op.newProperties.focus.offset === 0\n            const movedToPreviousSpan =\n              focusSpan &&\n              newFocusSpan &&\n              op.newProperties.focus.path[0] === op.properties.focus.path[0] &&\n              op.newProperties.focus.path[1] ===\n                op.properties.focus.path[1] - 1 &&\n              op.properties.focus.offset === 0 &&\n              newFocusSpan.text.length === op.newProperties.focus.offset\n\n            // If the editor has marks and we are not visually moving the\n            // selection then we just abort. Otherwise the marks would be\n            // cleared and we can't use them for the possible subsequent insert\n            // operation.\n            if (movedToNextSpan || movedToPreviousSpan) {\n              return\n            }\n          }\n        }\n      }\n\n      if (op.type === 'insert_node') {\n        const {selection} = editor\n\n        if (selection) {\n          const [_block, blockPath] = Editor.node(editor, selection, {depth: 1})\n          const previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path,\n          })\n          const previousSpanAnnotations = previousSpan\n            ? previousSpan.marks?.filter((mark) => !decorators.includes(mark))\n            : []\n\n          const nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1],\n          })\n          const nextSpanAnnotations = nextSpan\n            ? nextSpan.marks?.filter((mark) => !decorators.includes(mark))\n            : []\n\n          const annotationsEnding =\n            previousSpanAnnotations?.filter(\n              (annotation) => !nextSpanAnnotations?.includes(annotation),\n            ) ?? []\n          const atTheEndOfAnnotation = annotationsEnding.length > 0\n\n          if (\n            atTheEndOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.some((mark) => annotationsEnding.includes(mark))\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              marks:\n                op.node.marks?.filter(\n                  (mark) => !annotationsEnding.includes(mark),\n                ) ?? [],\n            })\n            return\n          }\n\n          const annotationsStarting =\n            nextSpanAnnotations?.filter(\n              (annotation) => !previousSpanAnnotations?.includes(annotation),\n            ) ?? []\n          const atTheStartOfAnnotation = annotationsStarting.length > 0\n\n          if (\n            atTheStartOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.some((mark) => annotationsStarting.includes(mark))\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              marks:\n                op.node.marks?.filter(\n                  (mark) => !annotationsStarting.includes(mark),\n                ) ?? [],\n            })\n            return\n          }\n\n          const nextSpanDecorators =\n            nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? []\n          const decoratorStarting = nextSpanDecorators.length > 0\n\n          if (\n            decoratorStarting &&\n            atTheEndOfAnnotation &&\n            !atTheStartOfAnnotation &&\n            isPortableTextSpan(op.node) &&\n            op.node.marks?.length === 0\n          ) {\n            Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: nextSpanDecorators,\n            })\n            return\n          }\n        }\n      }\n\n      if (op.type === 'insert_text') {\n        const {selection} = editor\n        const collapsedSelection = selection\n          ? Range.isCollapsed(selection)\n          : false\n\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = Editor.node(editor, selection, {\n            depth: 1,\n          })\n\n          const [span, spanPath] =\n            Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: selection.focus,\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0] ?? ([undefined, undefined] as const)\n\n          const marks = span.marks ?? []\n          const marksWithoutAnnotations = marks.filter((mark) =>\n            decorators.includes(mark),\n          )\n          const spanHasAnnotations =\n            marks.length > marksWithoutAnnotations.length\n\n          const spanIsEmpty = span.text.length === 0\n\n          const atTheBeginningOfSpan = selection.anchor.offset === 0\n          const atTheEndOfSpan = selection.anchor.offset === span.text.length\n\n          const previousSpan = getPreviousSpan({editor, blockPath, spanPath})\n          const nextSpan = getNextSpan({editor, blockPath, spanPath})\n          const nextSpanAnnotations =\n            nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n          const spanAnnotations = marks.filter(\n            (mark) => !decorators.includes(mark),\n          )\n\n          const previousSpanHasAnnotations = previousSpan\n            ? previousSpan.marks?.some((mark) => !decorators.includes(mark))\n            : false\n          const previousSpanHasSameAnnotations = previousSpan\n            ? previousSpan.marks\n                ?.filter((mark) => !decorators.includes(mark))\n                .every((mark) => marks.includes(mark))\n            : false\n          const previousSpanHasSameAnnotation = previousSpan\n            ? previousSpan.marks?.some(\n                (mark) => !decorators.includes(mark) && marks.includes(mark),\n              )\n            : false\n\n          const previousSpanHasSameMarks = previousSpan\n            ? previousSpan.marks?.every((mark) => marks.includes(mark))\n            : false\n          const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n            nextSpanAnnotations?.includes(mark),\n          )\n\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                Transforms.insertNodes(editor, {\n                  _type: 'span',\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? [],\n                })\n                return\n              } else if (previousSpanHasSameAnnotations) {\n                Transforms.insertNodes(editor, {\n                  _type: 'span',\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? [],\n                })\n                return\n              } else if (previousSpanHasSameAnnotation) {\n                apply(op)\n                return\n              } else if (!previousSpan) {\n                Transforms.insertNodes(editor, {\n                  _type: 'span',\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: [],\n                })\n                return\n              }\n            }\n\n            if (atTheEndOfSpan) {\n              if (\n                (nextSpan &&\n                  nextSpanSharesSomeAnnotations &&\n                  nextSpanAnnotations.length < spanAnnotations.length) ||\n                !nextSpanSharesSomeAnnotations\n              ) {\n                Transforms.insertNodes(editor, {\n                  _type: 'span',\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? [],\n                })\n                return\n              }\n\n              if (!nextSpan) {\n                Transforms.insertNodes(editor, {\n                  _type: 'span',\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: [],\n                })\n                return\n              }\n            }\n          }\n\n          if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n            Transforms.insertNodes(editor, {\n              _type: 'span',\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations\n                ? []\n                : (previousSpan.marks ?? []).filter((mark) =>\n                    decorators.includes(mark),\n                  ),\n            })\n            return\n          }\n        }\n      }\n\n      if (op.type === 'remove_text') {\n        const {selection} = editor\n\n        if (selection && Range.isExpanded(selection)) {\n          const [block, blockPath] = Editor.node(editor, selection, {\n            depth: 1,\n          })\n          const [span, spanPath] =\n            Array.from(\n              Editor.nodes(editor, {\n                mode: 'lowest',\n                at: {path: op.path, offset: op.offset},\n                match: (n) => editor.isTextSpan(n),\n                voids: false,\n              }),\n            )[0] ?? ([undefined, undefined] as const)\n\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? []\n            const marks = span.marks ?? []\n            const spanHasAnnotations = marks.some((mark) =>\n              markDefs.find((markDef) => markDef._key === mark),\n            )\n            const deletingFromTheEnd =\n              op.offset + op.text.length === span.text.length\n            const deletingAllText = op.offset === 0 && deletingFromTheEnd\n\n            const previousSpan = getPreviousSpan({editor, blockPath, spanPath})\n            const nextSpan = getNextSpan({editor, blockPath, spanPath})\n\n            const previousSpanHasSameAnnotation = previousSpan\n              ? previousSpan.marks?.some(\n                  (mark) => !decorators.includes(mark) && marks.includes(mark),\n                )\n              : false\n            const nextSpanHasSameAnnotation = nextSpan\n              ? nextSpan.marks?.some(\n                  (mark) => !decorators.includes(mark) && marks.includes(mark),\n                )\n              : false\n\n            if (\n              spanHasAnnotations &&\n              deletingAllText &&\n              !previousSpanHasSameAnnotation &&\n              !nextSpanHasSameAnnotation\n            ) {\n              const marksWithoutAnnotationMarks: string[] = (\n                {\n                  ...(Editor.marks(editor) || {}),\n                }.marks || []\n              ).filter((mark) => decorators.includes(mark))\n\n              Editor.withoutNormalizing(editor, () => {\n                apply(op)\n                Transforms.setNodes(\n                  editor,\n                  {marks: marksWithoutAnnotationMarks},\n                  {at: op.path},\n                )\n              })\n\n              editor.onChange()\n              return\n            }\n          }\n        }\n      }\n\n      /**\n       * Copy over markDefs when merging blocks\n       */\n      if (\n        op.type === 'merge_node' &&\n        op.path.length === 1 &&\n        'markDefs' in op.properties &&\n        op.properties._type === types.block.name &&\n        Array.isArray(op.properties.markDefs) &&\n        op.properties.markDefs.length > 0 &&\n        op.path[0] - 1 >= 0\n      ) {\n        const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] - 1])\n\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs =\n            (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || []\n          const newMarkDefs = uniq([...oldDefs, ...op.properties.markDefs])\n\n          debug(`Copying markDefs over to merged block`, op)\n          Transforms.setNodes(\n            editor,\n            {markDefs: newMarkDefs},\n            {at: targetPath, voids: false},\n          )\n          apply(op)\n          return\n        }\n      }\n\n      apply(op)\n    }\n\n    return editor\n  }\n}\n\nexport const addDecoratorActionImplementation: BehaviorActionImplementation<\n  'decorator.add'\n> = ({action}) => {\n  const editor = action.editor\n  const mark = action.decorator\n\n  if (editor.selection) {\n    if (Range.isExpanded(editor.selection)) {\n      // Split if needed\n      Transforms.setNodes(\n        editor,\n        {},\n        {match: Text.isText, split: true, hanging: true},\n      )\n      // Use new selection\n      const splitTextNodes = Range.isRange(editor.selection)\n        ? [\n            ...Editor.nodes(editor, {\n              at: editor.selection,\n              match: Text.isText,\n            }),\n          ]\n        : []\n      const shouldRemoveMark =\n        splitTextNodes.length > 1 &&\n        splitTextNodes.every((node) => node[0].marks?.includes(mark))\n\n      if (shouldRemoveMark) {\n        editor.removeMark(mark)\n      } else {\n        splitTextNodes.forEach(([node, path]) => {\n          const marks = [\n            ...(Array.isArray(node.marks) ? node.marks : []).filter(\n              (eMark: string) => eMark !== mark,\n            ),\n            mark,\n          ]\n          Transforms.setNodes(\n            editor,\n            {marks},\n            {at: path, match: Text.isText, split: true, hanging: true},\n          )\n        })\n      }\n    } else {\n      const [block, blockPath] = Editor.node(editor, editor.selection, {\n        depth: 1,\n      })\n      const lonelyEmptySpan =\n        editor.isTextBlock(block) &&\n        block.children.length === 1 &&\n        editor.isTextSpan(block.children[0]) &&\n        block.children[0].text === ''\n          ? block.children[0]\n          : undefined\n\n      if (lonelyEmptySpan) {\n        const existingMarks = lonelyEmptySpan.marks ?? []\n        const existingMarksWithoutDecorator = existingMarks.filter(\n          (existingMark) => existingMark !== mark,\n        )\n\n        Transforms.setNodes(\n          editor,\n          {\n            marks:\n              existingMarks.length === existingMarksWithoutDecorator.length\n                ? [...existingMarks, mark]\n                : existingMarksWithoutDecorator,\n          },\n          {\n            at: blockPath,\n            match: (node) => editor.isTextSpan(node),\n          },\n        )\n      } else {\n        const existingMarks: string[] =\n          {\n            ...(Editor.marks(editor) || {}),\n          }.marks || []\n        const marks = {\n          ...(Editor.marks(editor) || {}),\n          marks: [...existingMarks, mark],\n        }\n        editor.marks = marks as Text\n      }\n    }\n\n    if (editor.selection) {\n      // Reselect\n      const selection = editor.selection\n      editor.selection = {...selection}\n    }\n  }\n}\n\nexport const removeDecoratorActionImplementation: BehaviorActionImplementation<\n  'decorator.remove'\n> = ({action}) => {\n  const editor = action.editor\n  const mark = action.decorator\n  const {selection} = editor\n\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      // Split if needed\n      Transforms.setNodes(\n        editor,\n        {},\n        {match: Text.isText, split: true, hanging: true},\n      )\n      if (editor.selection) {\n        const splitTextNodes = [\n          ...Editor.nodes(editor, {\n            at: editor.selection,\n            match: Text.isText,\n          }),\n        ]\n        splitTextNodes.forEach(([node, path]) => {\n          const block = editor.children[path[0]]\n          if (Element.isElement(block) && block.children.includes(node)) {\n            Transforms.setNodes(\n              editor,\n              {\n                marks: (Array.isArray(node.marks) ? node.marks : []).filter(\n                  (eMark: string) => eMark !== mark,\n                ),\n                _type: 'span',\n              },\n              {at: path},\n            )\n          }\n        })\n      }\n    } else {\n      const [block, blockPath] = Editor.node(editor, selection, {\n        depth: 1,\n      })\n      const lonelyEmptySpan =\n        editor.isTextBlock(block) &&\n        block.children.length === 1 &&\n        editor.isTextSpan(block.children[0]) &&\n        block.children[0].text === ''\n          ? block.children[0]\n          : undefined\n\n      if (lonelyEmptySpan) {\n        const existingMarks = lonelyEmptySpan.marks ?? []\n        const existingMarksWithoutDecorator = existingMarks.filter(\n          (existingMark) => existingMark !== mark,\n        )\n\n        Transforms.setNodes(\n          editor,\n          {\n            marks: existingMarksWithoutDecorator,\n          },\n          {\n            at: blockPath,\n            match: (node) => editor.isTextSpan(node),\n          },\n        )\n      } else {\n        const existingMarks: string[] =\n          {\n            ...(Editor.marks(editor) || {}),\n          }.marks || []\n        const marks = {\n          ...(Editor.marks(editor) || {}),\n          marks: existingMarks.filter((eMark) => eMark !== mark),\n        } as Text\n        editor.marks = {marks: marks.marks, _type: 'span'} as Text\n      }\n    }\n\n    if (editor.selection) {\n      // Reselect\n      const selection = editor.selection\n      editor.selection = {...selection}\n    }\n  }\n}\n\nexport function isDecoratorActive({\n  editor,\n  decorator,\n}: {\n  editor: PortableTextSlateEditor\n  decorator: string\n}) {\n  if (!editor.selection) {\n    return false\n  }\n\n  const selectedTextNodes = Array.from(\n    Editor.nodes(editor, {match: Text.isText, at: editor.selection}),\n  )\n\n  if (selectedTextNodes.length === 0) {\n    return false\n  }\n\n  if (Range.isExpanded(editor.selection)) {\n    return selectedTextNodes.every((n) => {\n      const [node] = n\n\n      return node.marks?.includes(decorator)\n    })\n  }\n\n  return (\n    {\n      ...(Editor.marks(editor) || {}),\n    }.marks || []\n  ).includes(decorator)\n}\n\nexport const toggleDecoratorActionImplementation: BehaviorActionImplementation<\n  'decorator.toggle'\n> = ({context, action}) => {\n  const isActive = isDecoratorActive({\n    editor: action.editor,\n    decorator: action.decorator,\n  })\n\n  if (isActive) {\n    removeDecoratorActionImplementation({\n      context,\n      action: {\n        type: 'decorator.remove',\n        editor: action.editor,\n        decorator: action.decorator,\n      },\n    })\n  } else {\n    addDecoratorActionImplementation({\n      context,\n      action: {\n        type: 'decorator.add',\n        editor: action.editor,\n        decorator: action.decorator,\n      },\n    })\n  }\n}\n","import type {BaseRange} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {\n  toPortableTextRange,\n  type ObjectWithKeyAndType,\n} from '../../internal-utils/ranges'\nimport {SLATE_TO_PORTABLE_TEXT_RANGE} from '../../internal-utils/weakMaps'\nimport type {\n  EditorSelection,\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withPortableTextSelections')\nconst debugVerbose = debug.enabled && false\n\n// This plugin will make sure that we emit a PT selection whenever the editor has changed.\nexport function createWithPortableTextSelections(\n  editorActor: EditorActor,\n  types: PortableTextMemberSchemaTypes,\n): (editor: PortableTextSlateEditor) => PortableTextSlateEditor {\n  let prevSelection: BaseRange | null = null\n  return function withPortableTextSelections(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange: EditorSelection = null\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection)\n          if (existing) {\n            ptRange = existing\n          } else {\n            const value = editor.children satisfies ObjectWithKeyAndType[]\n            ptRange = toPortableTextRange(value, editor.selection, types)\n            SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange)\n          }\n        }\n        if (debugVerbose) {\n          debug(\n            `Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(\n              editor.selection,\n            )})`,\n          )\n        }\n        if (ptRange) {\n          editorActor.send({type: 'selection', selection: ptRange})\n        } else {\n          editorActor.send({type: 'selection', selection: null})\n        }\n      }\n      prevSelection = editor.selection\n    }\n\n    const {onChange} = editor\n    editor.onChange = () => {\n      onChange()\n      if (!editorActor.getSnapshot().matches({setup: 'setting up'})) {\n        emitPortableTextSelection()\n      }\n    }\n    return editor\n  }\n}\n","import {\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {Transforms, type Element} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withSchemaTypes')\n/**\n * This plugin makes sure that schema types are recognized properly by Slate as blocks, voids, inlines\n *\n */\nexport function createWithSchemaTypes({\n  editorActor,\n  schemaTypes,\n}: {\n  editorActor: EditorActor\n  schemaTypes: PortableTextMemberSchemaTypes\n}) {\n  return function withSchemaTypes(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    editor.isTextBlock = (value: unknown): value is PortableTextTextBlock => {\n      return (\n        isPortableTextTextBlock(value) && value._type === schemaTypes.block.name\n      )\n    }\n    editor.isTextSpan = (value: unknown): value is PortableTextSpan => {\n      return isPortableTextSpan(value) && value._type === schemaTypes.span.name\n    }\n    editor.isListBlock = (value: unknown): value is PortableTextListBlock => {\n      return (\n        isPortableTextListBlock(value) && value._type === schemaTypes.block.name\n      )\n    }\n    editor.isVoid = (element: Element): boolean => {\n      return (\n        schemaTypes.block.name !== element._type &&\n        (schemaTypes.blockObjects\n          .map((obj) => obj.name)\n          .includes(element._type) ||\n          schemaTypes.inlineObjects\n            .map((obj) => obj.name)\n            .includes(element._type))\n      )\n    }\n    editor.isInline = (element: Element): boolean => {\n      const inlineSchemaTypes = schemaTypes.inlineObjects.map((obj) => obj.name)\n      return (\n        inlineSchemaTypes.includes(element._type) &&\n        '__inline' in element &&\n        element.__inline === true\n      )\n    }\n\n    // Extend Slate's default normalization\n    const {normalizeNode} = editor\n    editor.normalizeNode = (entry) => {\n      const [node, path] = entry\n\n      // If text block children node is missing _type, set it to the span type\n      if (node._type === undefined && path.length === 2) {\n        debug('Setting span type on text node without a type')\n        const span = node as PortableTextSpan\n        const key =\n          span._key || editorActor.getSnapshot().context.keyGenerator()\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(\n          editor,\n          {...span, _type: schemaTypes.span.name, _key: key},\n          {at: path},\n        )\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      // catches cases when the children are missing keys but excludes it when the normalize is running the node as the editor object\n      if (node._key === undefined && (path.length === 1 || path.length === 2)) {\n        debug('Setting missing key on child node without a key')\n        const key = editorActor.getSnapshot().context.keyGenerator()\n        editorActor.send({type: 'normalizing'})\n        Transforms.setNodes(editor, {_key: key}, {at: path})\n        editorActor.send({type: 'done normalizing'})\n        return\n      }\n\n      normalizeNode(entry)\n    }\n    return editor\n  }\n}\n","import {Editor, Range, Text, Transforms} from 'slate'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {toSlateValue} from '../../internal-utils/values'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withUtils')\n\ninterface Options {\n  editorActor: EditorActor\n  schemaTypes: PortableTextMemberSchemaTypes\n}\n/**\n * This plugin makes various util commands available in the editor\n *\n */\nexport function createWithUtils({editorActor, schemaTypes}: Options) {\n  return function withUtils(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    // Expands the the selection to wrap around the word the focus is at\n    editor.pteExpandToWord = () => {\n      const {selection} = editor\n      if (selection && !Range.isExpanded(selection)) {\n        const [textNode] = Editor.node(editor, selection.focus, {depth: 2})\n        if (!textNode || !Text.isText(textNode) || textNode.text.length === 0) {\n          debug(`pteExpandToWord: Can't expand to word here`)\n          return\n        }\n        const {focus} = selection\n        const focusOffset = focus.offset\n        const charsBefore = textNode.text.slice(0, focusOffset)\n        const charsAfter = textNode.text.slice(focusOffset, -1)\n        const isEmpty = (str: string) => str.match(/\\s/g)\n        const whiteSpaceBeforeIndex = charsBefore\n          .split('')\n          .reverse()\n          .findIndex((str) => isEmpty(str))\n        const newStartOffset =\n          whiteSpaceBeforeIndex > -1\n            ? charsBefore.length - whiteSpaceBeforeIndex\n            : 0\n        const whiteSpaceAfterIndex = charsAfter\n          .split('')\n          .findIndex((obj) => isEmpty(obj))\n        const newEndOffset =\n          charsBefore.length +\n          (whiteSpaceAfterIndex > -1\n            ? whiteSpaceAfterIndex\n            : charsAfter.length + 1)\n        if (\n          !(\n            newStartOffset === newEndOffset ||\n            Number.isNaN(newStartOffset) ||\n            Number.isNaN(newEndOffset)\n          )\n        ) {\n          debug('pteExpandToWord: Expanding to focused word')\n          Transforms.setSelection(editor, {\n            anchor: {...selection.anchor, offset: newStartOffset},\n            focus: {...selection.focus, offset: newEndOffset},\n          })\n          return\n        }\n        debug(`pteExpandToWord: Can't expand to word here`)\n      }\n    }\n\n    editor.pteCreateTextBlock = (options: {\n      decorators: Array<string>\n      listItem?: string\n      level?: number\n    }) => {\n      const block = toSlateValue(\n        [\n          {\n            _type: schemaTypes.block.name,\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n            style: schemaTypes.styles[0].value || 'normal',\n            ...(options.listItem ? {listItem: options.listItem} : {}),\n            ...(options.level ? {level: options.level} : {}),\n            markDefs: [],\n            children: [\n              {\n                _type: 'span',\n                _key: editorActor.getSnapshot().context.keyGenerator(),\n                text: '',\n                marks: options.decorators.filter((decorator) =>\n                  schemaTypes.decorators.find(({value}) => value === decorator),\n                ),\n              },\n            ],\n          },\n        ],\n        {schemaTypes},\n      )[0]\n      return block\n    }\n    return editor\n  }\n}\n","import type {BaseOperation, Editor, Node, NodeEntry} from 'slate'\nimport {createOperationToPatches} from '../../internal-utils/operationToPatches'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {createWithEventListeners} from './create-with-event-listeners'\nimport {createWithMaxBlocks} from './createWithMaxBlocks'\nimport {createWithObjectKeys} from './createWithObjectKeys'\nimport {createWithPatches} from './createWithPatches'\nimport {createWithPlaceholderBlock} from './createWithPlaceholderBlock'\nimport {createWithPortableTextBlockStyle} from './createWithPortableTextBlockStyle'\nimport {createWithPortableTextMarkModel} from './createWithPortableTextMarkModel'\nimport {createWithPortableTextSelections} from './createWithPortableTextSelections'\nimport {createWithSchemaTypes} from './createWithSchemaTypes'\nimport {createWithUndoRedo} from './createWithUndoRedo'\nimport {createWithUtils} from './createWithUtils'\n\nexport interface OriginalEditorFunctions {\n  apply: (operation: BaseOperation) => void\n  onChange: () => void\n  normalizeNode: (entry: NodeEntry<Node>) => void\n}\n\ntype PluginsOptions = {\n  editorActor: EditorActor\n  subscriptions: Array<() => () => void>\n}\n\nexport const withPlugins = <T extends Editor>(\n  editor: T,\n  options: PluginsOptions,\n): PortableTextSlateEditor => {\n  const e = editor as T & PortableTextSlateEditor\n  const {editorActor} = options\n  const schemaTypes = editorActor.getSnapshot().context.schema\n  const operationToPatches = createOperationToPatches(schemaTypes)\n  const withObjectKeys = createWithObjectKeys(editorActor, schemaTypes)\n  const withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n    schemaTypes,\n  })\n  const withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    schemaTypes,\n    subscriptions: options.subscriptions,\n  })\n  const withMaxBlocks = createWithMaxBlocks(editorActor)\n  const withUndoRedo = createWithUndoRedo({\n    editorActor,\n    blockSchemaType: schemaTypes.block,\n    subscriptions: options.subscriptions,\n  })\n  const withPortableTextMarkModel = createWithPortableTextMarkModel(\n    editorActor,\n    schemaTypes,\n  )\n  const withPortableTextBlockStyle = createWithPortableTextBlockStyle(\n    editorActor,\n    schemaTypes,\n  )\n\n  const withPlaceholderBlock = createWithPlaceholderBlock(editorActor)\n\n  const withUtils = createWithUtils({\n    editorActor,\n    schemaTypes,\n  })\n  const withPortableTextSelections = createWithPortableTextSelections(\n    editorActor,\n    schemaTypes,\n  )\n  const withEventListeners = createWithEventListeners(\n    editorActor,\n    options.subscriptions,\n  )\n\n  // Ordering is important here, selection dealing last, data manipulation in the middle and core model stuff first.\n  return withEventListeners(\n    withSchemaTypes(\n      withObjectKeys(\n        withPortableTextMarkModel(\n          withPortableTextBlockStyle(\n            withPlaceholderBlock(\n              withUtils(\n                withMaxBlocks(\n                  withUndoRedo(withPatches(withPortableTextSelections(e))),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  )\n}\n","import {createEditor, type Descendant} from 'slate'\nimport {withReact} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {\n  KEY_TO_SLATE_ELEMENT,\n  KEY_TO_VALUE_ELEMENT,\n} from '../internal-utils/weakMaps'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\nimport {withPlugins} from './plugins/with-plugins'\n\nconst debug = debugWithName('component:PortableTextEditor:SlateContainer')\n\ntype SlateEditorConfig = {\n  editorActor: EditorActor\n}\n\n/**\n * @internal\n */\nexport type SlateEditor = {\n  instance: PortableTextSlateEditor\n  initialValue: Array<Descendant>\n}\n\nconst slateEditors = new WeakMap<EditorActor, SlateEditor>()\n\nexport function createSlateEditor(config: SlateEditorConfig): SlateEditor {\n  const existingSlateEditor = slateEditors.get(config.editorActor)\n\n  if (existingSlateEditor) {\n    debug('Reusing existing Slate editor instance', config.editorActor.id)\n    return existingSlateEditor\n  }\n\n  debug('Creating new Slate editor instance', config.editorActor.id)\n\n  const unsubscriptions: Array<() => void> = []\n  const subscriptions: Array<() => () => void> = []\n\n  const instance = withPlugins(withReact(createEditor()), {\n    editorActor: config.editorActor,\n    subscriptions,\n  })\n\n  KEY_TO_VALUE_ELEMENT.set(instance, {})\n  KEY_TO_SLATE_ELEMENT.set(instance, {})\n\n  for (const subscription of subscriptions) {\n    unsubscriptions.push(subscription())\n  }\n\n  const initialValue = [instance.pteCreateTextBlock({decorators: []})]\n\n  const slateEditor: SlateEditor = {\n    instance,\n    initialValue,\n  }\n\n  slateEditors.set(config.editorActor, slateEditor)\n\n  return slateEditor\n}\n","import {Editor, Transforms} from 'slate'\nimport type {BehaviorActionImplementation} from './behavior.actions'\nimport {createGuards} from './behavior.guards'\n\nexport const toggleListItemActionImplementation: BehaviorActionImplementation<\n  'list item.toggle'\n> = ({context, action}) => {\n  const isActive = isListItemActive({\n    editor: action.editor,\n    listItem: action.listItem,\n  })\n\n  if (isActive) {\n    removeListItemActionImplementation({\n      context,\n      action: {...action, type: 'list item.remove'},\n    })\n  } else {\n    addListItemActionImplementation({\n      context,\n      action: {...action, type: 'list item.add'},\n    })\n  }\n}\n\nexport const removeListItemActionImplementation: BehaviorActionImplementation<\n  'list item.remove'\n> = ({context, action}) => {\n  if (!action.editor.selection) {\n    return\n  }\n\n  const guards = createGuards(context)\n\n  const selectedBlocks = [\n    ...Editor.nodes(action.editor, {\n      at: action.editor.selection,\n      match: (node) => guards.isListBlock(node),\n    }),\n  ]\n\n  for (const [, at] of selectedBlocks) {\n    Transforms.unsetNodes(action.editor, ['listItem', 'level'], {at})\n  }\n}\n\nexport const addListItemActionImplementation: BehaviorActionImplementation<\n  'list item.add'\n> = ({context, action}) => {\n  if (!action.editor.selection) {\n    return\n  }\n\n  const guards = createGuards(context)\n\n  const selectedBlocks = [\n    ...Editor.nodes(action.editor, {\n      at: action.editor.selection,\n      match: (node) => guards.isTextBlock(node),\n    }),\n  ]\n\n  for (const [, at] of selectedBlocks) {\n    Transforms.setNodes(\n      action.editor,\n      {\n        level: 1,\n        listItem: action.listItem,\n      },\n      {at},\n    )\n  }\n}\n\nexport function isListItemActive({\n  editor,\n  listItem,\n}: {\n  editor: Editor\n  listItem: string\n}): boolean {\n  if (!editor.selection) {\n    return false\n  }\n\n  const selectedBlocks = [\n    ...Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    }),\n  ]\n\n  if (selectedBlocks.length > 0) {\n    return selectedBlocks.every(\n      ([node]) => editor.isListBlock(node) && node.listItem === listItem,\n    )\n  }\n\n  return false\n}\n","import {Editor, Transforms} from 'slate'\nimport type {BehaviorActionImplementation} from './behavior.actions'\nimport {createGuards} from './behavior.guards'\n\nexport const toggleStyleActionImplementation: BehaviorActionImplementation<\n  'style.toggle'\n> = ({context, action}) => {\n  const isActive = isStyleActive({\n    editor: action.editor,\n    style: action.style,\n  })\n\n  if (isActive) {\n    removeStyleActionImplementation({\n      context,\n      action: {...action, type: 'style.remove'},\n    })\n  } else {\n    addStyleActionImplementation({\n      context,\n      action: {...action, type: 'style.add'},\n    })\n  }\n}\n\nexport const removeStyleActionImplementation: BehaviorActionImplementation<\n  'style.remove'\n> = ({context, action}) => {\n  if (!action.editor.selection) {\n    return\n  }\n\n  const defaultStyle = context.schema.styles[0].value\n  const guards = createGuards(context)\n\n  const selectedBlocks = [\n    ...Editor.nodes(action.editor, {\n      at: action.editor.selection,\n      match: (node) => guards.isTextBlock(node),\n    }),\n  ]\n\n  for (const [, at] of selectedBlocks) {\n    Transforms.setNodes(\n      action.editor,\n      {\n        style: defaultStyle,\n      },\n      {\n        at,\n      },\n    )\n  }\n}\n\nexport const addStyleActionImplementation: BehaviorActionImplementation<\n  'style.add'\n> = ({context, action}) => {\n  if (!action.editor.selection) {\n    return\n  }\n\n  const guards = createGuards(context)\n\n  const selectedBlocks = [\n    ...Editor.nodes(action.editor, {\n      at: action.editor.selection,\n      match: (node) => guards.isTextBlock(node),\n    }),\n  ]\n\n  for (const [, at] of selectedBlocks) {\n    Transforms.setNodes(\n      action.editor,\n      {\n        style: action.style,\n      },\n      {\n        at,\n      },\n    )\n  }\n}\n\nexport function isStyleActive({\n  editor,\n  style,\n}: {\n  editor: Editor\n  style: string\n}): boolean {\n  if (!editor.selection) {\n    return false\n  }\n\n  const selectedBlocks = [\n    ...Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    }),\n  ]\n\n  if (selectedBlocks.length > 0) {\n    return selectedBlocks.every(([node]) => node.style === style)\n  }\n\n  return false\n}\n","import {\n  isPortableTextSpan,\n  type Path,\n  type PortableTextBlock,\n  type PortableTextChild,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  Editor,\n  Node,\n  Range,\n  Element as SlateElement,\n  Path as SlatePath,\n  Text,\n  Transforms,\n} from 'slate'\nimport type {DOMNode} from 'slate-dom'\nimport {ReactEditor} from 'slate-react'\nimport {isListItemActive} from '../../behavior-actions/behavior.action.list-item'\nimport {isStyleActive} from '../../behavior-actions/behavior.action.style'\nimport type {BehaviorActionImplementation} from '../../behavior-actions/behavior.actions'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {toPortableTextRange, toSlateRange} from '../../internal-utils/ranges'\nimport {fromSlateValue, toSlateValue} from '../../internal-utils/values'\nimport {\n  KEY_TO_VALUE_ELEMENT,\n  SLATE_TO_PORTABLE_TEXT_RANGE,\n} from '../../internal-utils/weakMaps'\nimport type {\n  EditableAPI,\n  EditableAPIDeleteOptions,\n  EditorSelection,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {isDecoratorActive} from './createWithPortableTextMarkModel'\n\nconst debug = debugWithName('API:editable')\n\nexport function createEditableAPI(\n  editor: PortableTextSlateEditor,\n  editorActor: EditorActor,\n) {\n  const types = editorActor.getSnapshot().context.schema\n\n  const editableApi: EditableAPI = {\n    focus: (): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'focus',\n        },\n        editor,\n      })\n    },\n    blur: (): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'blur',\n        },\n        editor,\n      })\n    },\n    toggleMark: (mark: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'decorator.toggle',\n          decorator: mark,\n        },\n        editor,\n      })\n    },\n    toggleList: (listItem: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'list item.toggle',\n          listItem,\n        },\n        editor,\n      })\n    },\n    toggleBlockStyle: (style: string): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'style.toggle',\n          style,\n        },\n        editor,\n      })\n    },\n    isMarkActive: (mark: string): boolean => {\n      // Try/catch this, as Slate may error because the selection is currently wrong\n      // TODO: catch only relevant error from Slate\n      try {\n        return isDecoratorActive({editor, decorator: mark})\n      } catch (err) {\n        console.warn(err)\n        return false\n      }\n    },\n    marks: (): string[] => {\n      return (\n        {\n          ...(Editor.marks(editor) || {}),\n        }.marks || []\n      )\n    },\n    undo: (): void => editor.undo(),\n    redo: (): void => editor.redo(),\n    select: (selection: EditorSelection): void => {\n      const slateSelection = toSlateRange(selection, editor)\n      if (slateSelection) {\n        Transforms.select(editor, slateSelection)\n      } else {\n        Transforms.deselect(editor)\n      }\n      editor.onChange()\n    },\n    focusBlock: (): PortableTextBlock | undefined => {\n      if (editor.selection) {\n        const block = Node.descendant(\n          editor,\n          editor.selection.focus.path.slice(0, 1),\n        )\n        if (block) {\n          return fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0]\n        }\n      }\n      return undefined\n    },\n    focusChild: (): PortableTextChild | undefined => {\n      if (editor.selection) {\n        const block = Node.descendant(\n          editor,\n          editor.selection.focus.path.slice(0, 1),\n        )\n        if (block && editor.isTextBlock(block)) {\n          const ptBlock = fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0] as PortableTextTextBlock\n          return ptBlock.children[editor.selection.focus.path[1]]\n        }\n      }\n      return undefined\n    },\n    insertChild: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n      value?: {[prop: string]: any},\n    ): Path => {\n      if (type.name !== types.span.name) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'insert.inline object',\n            inlineObject: {\n              name: type.name,\n              value,\n            },\n          },\n          editor,\n        })\n\n        return (\n          toPortableTextRange(\n            fromSlateValue(\n              editor.children,\n              types.block.name,\n              KEY_TO_VALUE_ELEMENT.get(editor),\n            ),\n            editor.selection,\n            types,\n          )?.focus.path ?? []\n        )\n      }\n\n      if (!editor.selection) {\n        throw new Error('The editor has no selection')\n      }\n      const [focusBlock] = Array.from(\n        Editor.nodes(editor, {\n          at: editor.selection.focus.path.slice(0, 1),\n          match: (n) => n._type === types.block.name,\n        }),\n      )[0] || [undefined]\n      if (!focusBlock) {\n        throw new Error('No focused text block')\n      }\n      if (\n        type.name !== types.span.name &&\n        !types.inlineObjects.some((t) => t.name === type.name)\n      ) {\n        throw new Error(\n          'This type cannot be inserted as a child to a text block',\n        )\n      }\n      const block = toSlateValue(\n        [\n          {\n            _key: editorActor.getSnapshot().context.keyGenerator(),\n            _type: types.block.name,\n            children: [\n              {\n                _key: editorActor.getSnapshot().context.keyGenerator(),\n                _type: type.name,\n                ...(value ? value : {}),\n              },\n            ],\n          },\n        ],\n        {schemaTypes: editorActor.getSnapshot().context.schema},\n      )[0] as unknown as SlateElement\n      const child = block.children[0]\n      const focusChildPath = editor.selection.focus.path.slice(0, 2)\n      const isSpanNode = child._type === types.span.name\n      const focusNode = Node.get(editor, focusChildPath)\n\n      // If we are inserting a span, and currently have focus on an inline object,\n      // move the selection to the next span (guaranteed by normalizing rules) before inserting it.\n      if (isSpanNode && focusNode._type !== types.span.name) {\n        debug(\n          'Inserting span child next to inline object child, moving selection + 1',\n        )\n        editor.move({distance: 1, unit: 'character'})\n      }\n\n      Transforms.insertNodes(editor, child, {\n        select: true,\n        at: editor.selection,\n      })\n      editor.onChange()\n\n      return (\n        toPortableTextRange(\n          fromSlateValue(\n            editor.children,\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          ),\n          editor.selection,\n          types,\n        )?.focus.path || []\n      )\n    },\n    insertBlock: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n      value?: {[prop: string]: any},\n    ): Path => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'insert.block object',\n          blockObject: {\n            name: type.name,\n            value,\n          },\n          placement: 'auto',\n        },\n        editor,\n      })\n\n      return (\n        toPortableTextRange(\n          fromSlateValue(\n            editor.children,\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          ),\n          editor.selection,\n          types,\n        )?.focus.path ?? []\n      )\n    },\n    hasBlockStyle: (style: string): boolean => {\n      try {\n        return isStyleActive({editor, style})\n      } catch {\n        // This is fine.\n        return false\n      }\n    },\n    hasListStyle: (listItem: string): boolean => {\n      try {\n        return isListItemActive({editor, listItem})\n      } catch {\n        // This is fine.\n        return false\n      }\n    },\n    isVoid: (element: PortableTextBlock | PortableTextChild) => {\n      return ![types.block.name, types.span.name].includes(element._type)\n    },\n    findByPath: (\n      path: Path,\n    ): [\n      PortableTextBlock | PortableTextChild | undefined,\n      Path | undefined,\n    ] => {\n      const slatePath = toSlateRange(\n        {focus: {path, offset: 0}, anchor: {path, offset: 0}},\n        editor,\n      )\n      if (slatePath) {\n        const [block, blockPath] = Editor.node(\n          editor,\n          slatePath.focus.path.slice(0, 1),\n        )\n        if (block && blockPath && typeof block._key === 'string') {\n          if (path.length === 1 && slatePath.focus.path.length === 1) {\n            return [\n              fromSlateValue([block], types.block.name)[0],\n              [{_key: block._key}],\n            ]\n          }\n          const ptBlock = fromSlateValue(\n            [block],\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          )[0]\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]]\n            if (ptChild) {\n              return [\n                ptChild,\n                [{_key: block._key}, 'children', {_key: ptChild._key}],\n              ]\n            }\n          }\n        }\n      }\n      return [undefined, undefined]\n    },\n    findDOMNode: (\n      element: PortableTextBlock | PortableTextChild,\n    ): DOMNode | undefined => {\n      let node: DOMNode | undefined\n      try {\n        const [item] = Array.from(\n          Editor.nodes(editor, {\n            at: [],\n            match: (n) => n._key === element._key,\n          }) || [],\n        )[0] || [undefined]\n        node = ReactEditor.toDOMNode(editor, item)\n      } catch {\n        // Nothing\n      }\n      return node\n    },\n    activeAnnotations: (): PortableTextObject[] => {\n      if (!editor.selection || editor.selection.focus.path.length < 2) {\n        return []\n      }\n      try {\n        const activeAnnotations: PortableTextObject[] = []\n        const spans = Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) =>\n            Text.isText(node) &&\n            node.marks !== undefined &&\n            Array.isArray(node.marks) &&\n            node.marks.length > 0,\n        })\n        for (const [span, path] of spans) {\n          const [block] = Editor.node(editor, path, {depth: 1})\n          if (editor.isTextBlock(block)) {\n            block.markDefs?.forEach((def) => {\n              if (\n                Text.isText(span) &&\n                span.marks &&\n                Array.isArray(span.marks) &&\n                span.marks.includes(def._key)\n              ) {\n                activeAnnotations.push(def)\n              }\n            })\n          }\n        }\n        return activeAnnotations\n      } catch {\n        return []\n      }\n    },\n    isAnnotationActive: (\n      annotationType: PortableTextObject['_type'],\n    ): boolean => {\n      return isAnnotationActive({editor, annotation: {name: annotationType}})\n    },\n    addAnnotation: (type, value) => {\n      let paths: ReturnType<EditableAPI['addAnnotation']> = undefined\n\n      Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationActionImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types,\n          },\n          action: {\n            type: 'annotation.add',\n            annotation: {name: type.name, value: value ?? {}},\n            editor,\n          },\n        })\n      })\n      editor.onChange()\n\n      return paths\n    },\n    delete: (\n      selection: EditorSelection,\n      options?: EditableAPIDeleteOptions,\n    ): void => {\n      if (selection) {\n        const range = toSlateRange(selection, editor)\n        const hasRange =\n          range && range.anchor.path.length > 0 && range.focus.path.length > 0\n        if (!hasRange) {\n          throw new Error('Invalid range')\n        }\n        if (range) {\n          if (!options?.mode || options?.mode === 'selected') {\n            debug(`Deleting content in selection`)\n            Transforms.delete(editor, {\n              at: range,\n              hanging: true,\n              voids: true,\n            })\n            editor.onChange()\n            return\n          }\n          if (options?.mode === 'blocks') {\n            debug(`Deleting blocks touched by selection`)\n            Transforms.removeNodes(editor, {\n              at: range,\n              voids: true,\n              match: (node) => {\n                return (\n                  editor.isTextBlock(node) ||\n                  (!editor.isTextBlock(node) && SlateElement.isElement(node))\n                )\n              },\n            })\n          }\n          if (options?.mode === 'children') {\n            debug(`Deleting children touched by selection`)\n            Transforms.removeNodes(editor, {\n              at: range,\n              voids: true,\n              match: (node) => {\n                return (\n                  node._type === types.span.name || // Text children\n                  (!editor.isTextBlock(node) && SlateElement.isElement(node)) // inline blocks\n                )\n              },\n            })\n          }\n          // If the editor was emptied, insert a placeholder block\n          // directly into the editor's children. We don't want to do this\n          // through a Transform (because that would trigger a change event\n          // that would insert the placeholder into the actual value\n          // which should remain empty)\n          if (editor.children.length === 0) {\n            editor.children = [editor.pteCreateTextBlock({decorators: []})]\n          }\n          editor.onChange()\n        }\n      }\n    },\n    removeAnnotation: <TSchemaType extends {name: string}>(\n      type: TSchemaType,\n    ): void => {\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'annotation.remove',\n          annotation: {name: type.name},\n        },\n        editor,\n      })\n    },\n    getSelection: (): EditorSelection | null => {\n      let ptRange: EditorSelection = null\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection)\n        if (existing) {\n          return existing\n        }\n        ptRange = toPortableTextRange(\n          fromSlateValue(\n            editor.children,\n            types.block.name,\n            KEY_TO_VALUE_ELEMENT.get(editor),\n          ),\n          editor.selection,\n          types,\n        )\n        SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange)\n      }\n      return ptRange\n    },\n    getValue: () => {\n      return fromSlateValue(\n        editor.children,\n        types.block.name,\n        KEY_TO_VALUE_ELEMENT.get(editor),\n      )\n    },\n    isCollapsedSelection: () => {\n      return !!editor.selection && Range.isCollapsed(editor.selection)\n    },\n    isExpandedSelection: () => {\n      return !!editor.selection && Range.isExpanded(editor.selection)\n    },\n    insertBreak: () => {\n      editor.insertBreak()\n      editor.onChange()\n    },\n    getFragment: () => {\n      return fromSlateValue(editor.getFragment(), types.block.name)\n    },\n    isSelectionsOverlapping: (\n      selectionA: EditorSelection,\n      selectionB: EditorSelection,\n    ) => {\n      // Convert the selections to Slate ranges\n      const rangeA = toSlateRange(selectionA, editor)\n      const rangeB = toSlateRange(selectionB, editor)\n\n      // Make sure the ranges are valid\n      const isValidRanges = Range.isRange(rangeA) && Range.isRange(rangeB)\n\n      // Check if the ranges are overlapping\n      const isOverlapping = isValidRanges && Range.includes(rangeA, rangeB)\n\n      return isOverlapping\n    },\n  }\n\n  return editableApi\n}\n\nfunction isAnnotationActive({\n  editor,\n  annotation,\n}: {\n  editor: PortableTextSlateEditor\n  annotation: {\n    name: string\n  }\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2) {\n    return false\n  }\n\n  try {\n    const spans = [\n      ...Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => Text.isText(node),\n      }),\n    ]\n\n    if (spans.length === 0) {\n      return false\n    }\n\n    if (\n      spans.some(\n        ([span]) =>\n          !isPortableTextSpan(span) || !span.marks || span.marks?.length === 0,\n      )\n    )\n      return false\n\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = Editor.node(editor, path, {depth: 1})\n      if (editor.isTextBlock(block) && block.markDefs) {\n        return [...accMarkDefs, ...block.markDefs]\n      }\n      return accMarkDefs\n    }, [] as PortableTextObject[])\n\n    return spans.every(([span]) => {\n      if (!isPortableTextSpan(span)) return false\n\n      const spanMarkDefs = span.marks?.map(\n        (markKey) =>\n          selectionMarkDefs.find((def) => def?._key === markKey)?._type,\n      )\n\n      return spanMarkDefs?.includes(annotation.name)\n    })\n  } catch {\n    return false\n  }\n}\n\n/**\n * @public\n */\nexport type AddedAnnotationPaths = {\n  /**\n   * @deprecated An annotation may be applied to multiple blocks, resulting\n   * in multiple `markDef`'s being created. Use `markDefPaths` instead.\n   */\n  markDefPath: Path\n  markDefPaths: Array<Path>\n  /**\n   * @deprecated Does not return anything meaningful since an annotation\n   * can span multiple blocks and spans. If references the span closest\n   * to the focus point of the selection.\n   */\n  spanPath: Path\n}\n\nexport const addAnnotationActionImplementation: BehaviorActionImplementation<\n  'annotation.add',\n  AddedAnnotationPaths | undefined\n> = ({context, action}) => {\n  const editor = action.editor\n  const {selection: originalSelection} = editor\n  let paths: AddedAnnotationPaths | undefined = undefined\n\n  if (originalSelection) {\n    if (Range.isCollapsed(originalSelection)) {\n      editor.pteExpandToWord()\n      editor.onChange()\n    }\n\n    // If we still have a selection, add the annotation to the selected text\n    if (editor.selection) {\n      let spanPath: Path | undefined\n      let markDefPath: Path | undefined\n      const markDefPaths: Path[] = []\n\n      if (!editor.selection) {\n        return\n      }\n\n      const selectedBlocks = Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node),\n        reverse: Range.isBackward(editor.selection),\n      })\n\n      for (const [block, blockPath] of selectedBlocks) {\n        if (block.children.length === 0) {\n          continue\n        }\n\n        if (block.children.length === 1 && block.children[0].text === '') {\n          continue\n        }\n\n        const annotationKey = context.keyGenerator()\n        const markDefs = block.markDefs ?? []\n        const existingMarkDef = markDefs.find(\n          (markDef) =>\n            markDef._type === action.annotation.name &&\n            markDef._key === annotationKey,\n        )\n\n        if (existingMarkDef === undefined) {\n          Transforms.setNodes(\n            editor,\n            {\n              markDefs: [\n                ...markDefs,\n                {\n                  _type: action.annotation.name,\n                  _key: annotationKey,\n                  ...action.annotation.value,\n                },\n              ],\n            },\n            {at: blockPath},\n          )\n\n          markDefPath = [{_key: block._key}, 'markDefs', {_key: annotationKey}]\n          if (Range.isBackward(editor.selection)) {\n            markDefPaths.unshift(markDefPath)\n          } else {\n            markDefPaths.push(markDefPath)\n          }\n        }\n\n        Transforms.setNodes(editor, {}, {match: Text.isText, split: true})\n\n        const children = Node.children(editor, blockPath)\n\n        for (const [span, path] of children) {\n          if (!editor.isTextSpan(span)) {\n            continue\n          }\n\n          if (!Range.includes(editor.selection, path)) {\n            continue\n          }\n\n          const marks = span.marks ?? []\n          const existingSameTypeAnnotations = marks.filter((mark) =>\n            markDefs.some(\n              (markDef) =>\n                markDef._key === mark &&\n                markDef._type === action.annotation.name,\n            ),\n          )\n\n          Transforms.setNodes(\n            editor,\n            {\n              marks: [\n                ...marks.filter(\n                  (mark) => !existingSameTypeAnnotations.includes(mark),\n                ),\n                annotationKey,\n              ],\n            },\n            {at: path},\n          )\n          spanPath = [{_key: block._key}, 'children', {_key: span._key}]\n        }\n      }\n\n      if (markDefPath && spanPath) {\n        paths = {\n          markDefPath,\n          markDefPaths,\n          spanPath,\n        }\n      }\n    }\n  }\n  return paths\n}\n\nexport const removeAnnotationActionImplementation: BehaviorActionImplementation<\n  'annotation.remove'\n> = ({action}) => {\n  const editor = action.editor\n\n  debug('Removing annotation', action.annotation.name)\n\n  if (!editor.selection) {\n    return\n  }\n\n  if (Range.isCollapsed(editor.selection)) {\n    const [block, blockPath] = Editor.node(editor, editor.selection, {\n      depth: 1,\n    })\n\n    if (!editor.isTextBlock(block)) {\n      return\n    }\n\n    const markDefs = block.markDefs ?? []\n    const potentialAnnotations = markDefs.filter(\n      (markDef) => markDef._type === action.annotation.name,\n    )\n\n    const [selectedChild, selectedChildPath] = Editor.node(\n      editor,\n      editor.selection,\n      {\n        depth: 2,\n      },\n    )\n\n    if (!editor.isTextSpan(selectedChild)) {\n      return\n    }\n\n    const annotationToRemove = selectedChild.marks?.find((mark) =>\n      potentialAnnotations.some((markDef) => markDef._key === mark),\n    )\n\n    if (!annotationToRemove) {\n      return\n    }\n\n    const previousSpansWithSameAnnotation: Array<\n      [span: PortableTextSpan, path: SlatePath]\n    > = []\n\n    for (const [child, childPath] of Node.children(editor, blockPath, {\n      reverse: true,\n    })) {\n      if (!editor.isTextSpan(child)) {\n        continue\n      }\n\n      if (!SlatePath.isBefore(childPath, selectedChildPath)) {\n        continue\n      }\n\n      if (child.marks?.includes(annotationToRemove)) {\n        previousSpansWithSameAnnotation.push([child, childPath])\n      } else {\n        break\n      }\n    }\n\n    const nextSpansWithSameAnnotation: Array<\n      [span: PortableTextSpan, path: SlatePath]\n    > = []\n\n    for (const [child, childPath] of Node.children(editor, blockPath)) {\n      if (!editor.isTextSpan(child)) {\n        continue\n      }\n\n      if (!SlatePath.isAfter(childPath, selectedChildPath)) {\n        continue\n      }\n\n      if (child.marks?.includes(annotationToRemove)) {\n        nextSpansWithSameAnnotation.push([child, childPath])\n      } else {\n        break\n      }\n    }\n\n    for (const [child, childPath] of [\n      ...previousSpansWithSameAnnotation,\n      [selectedChild, selectedChildPath] as const,\n      ...nextSpansWithSameAnnotation,\n    ]) {\n      Transforms.setNodes(\n        editor,\n        {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove),\n        },\n        {at: childPath},\n      )\n    }\n  } else {\n    Transforms.setNodes(\n      editor,\n      {},\n      {\n        match: (node) => editor.isTextSpan(node),\n        split: true,\n        hanging: true,\n      },\n    )\n\n    const blocks = Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n    })\n\n    for (const [block, blockPath] of blocks) {\n      const children = Node.children(editor, blockPath)\n\n      for (const [child, childPath] of children) {\n        if (!editor.isTextSpan(child)) {\n          continue\n        }\n\n        if (!Range.includes(editor.selection, childPath)) {\n          continue\n        }\n\n        const markDefs = block.markDefs ?? []\n        const marks = child.marks ?? []\n        const marksWithoutAnnotation = marks.filter((mark) => {\n          const markDef = markDefs.find((markDef) => markDef._key === mark)\n          return markDef?._type !== action.annotation.name\n        })\n\n        if (marksWithoutAnnotation.length !== marks.length) {\n          Transforms.setNodes(\n            editor,\n            {\n              marks: marksWithoutAnnotation,\n            },\n            {at: childPath},\n          )\n        }\n      }\n    }\n  }\n}\n\nexport const toggleAnnotationActionImplementation: BehaviorActionImplementation<\n  'annotation.toggle',\n  AddedAnnotationPaths | undefined\n> = ({context, action}) => {\n  const isActive = isAnnotationActive({\n    editor: action.editor,\n    annotation: {name: action.annotation.name},\n  })\n\n  if (isActive) {\n    removeAnnotationActionImplementation({\n      context,\n      action: {\n        type: 'annotation.remove',\n        annotation: action.annotation,\n        editor: action.editor,\n      },\n    })\n  } else {\n    return addAnnotationActionImplementation({\n      context,\n      action: {\n        type: 'annotation.add',\n        annotation: action.annotation,\n        editor: action.editor,\n      },\n    })\n  }\n}\n","import {Editor, Transforms, type Descendant} from 'slate'\nimport type {EditorSchema} from '../editor/define-schema'\nimport {isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {PortableTextSlateEditor} from '../types/editor'\n\nexport function insertBlock({\n  block,\n  placement,\n  editor,\n  schema,\n}: {\n  block: Descendant\n  placement: 'auto' | 'after' | 'before'\n  editor: PortableTextSlateEditor\n  schema: EditorSchema\n}) {\n  if (!editor.selection) {\n    const lastBlock = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => !Editor.isEditor(n),\n        at: [],\n        reverse: true,\n      }),\n    )[0]\n\n    // If there is no selection, let's just insert the new block at the\n    // end of the document\n    Editor.insertNode(editor, block)\n\n    if (lastBlock && isEqualToEmptyEditor([lastBlock[0]], schema)) {\n      // And if the last block was an empty text block, let's remove\n      // that too\n      Transforms.removeNodes(editor, {at: lastBlock[1]})\n    }\n  } else {\n    const [focusBlock, focusBlockPath] = Array.from(\n      Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => !Editor.isEditor(n),\n      }),\n    )[0] ?? [undefined, undefined]\n\n    if (placement === 'after') {\n      const nextPath = [focusBlockPath[0] + 1]\n\n      Transforms.insertNodes(editor, block, {at: nextPath})\n      Transforms.select(editor, {\n        anchor: {path: [nextPath[0], 0], offset: 0},\n        focus: {path: [nextPath[0], 0], offset: 0},\n      })\n    } else if (placement === 'before') {\n      Transforms.insertNodes(editor, block, {at: focusBlockPath})\n    } else {\n      Editor.insertNode(editor, block)\n    }\n\n    if (focusBlock && isEqualToEmptyEditor([focusBlock], schema)) {\n      Transforms.removeNodes(editor, {at: focusBlockPath})\n    }\n  }\n}\n","import {toSlateValue} from '../internal-utils/values'\nimport {insertBlock} from './behavior.action-utils.insert-block'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const insertBlockObjectActionImplementation: BehaviorActionImplementation<\n  'insert.block object'\n> = ({context, action}) => {\n  const block = toSlateValue(\n    [\n      {\n        _key: context.keyGenerator(),\n        _type: action.blockObject.name,\n        ...(action.blockObject.value ? action.blockObject.value : {}),\n      },\n    ],\n    {schemaTypes: context.schema},\n  )[0]\n\n  insertBlock({\n    block,\n    placement: action.placement,\n    editor: action.editor,\n    schema: context.schema,\n  })\n}\n","import {isEqual} from 'lodash'\nimport {Editor, Node, Path, Range, Transforms} from 'slate'\nimport type {SlateTextBlock, VoidElement} from '../types/slate'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const insertBreakActionImplementation: BehaviorActionImplementation<\n  'insert.break'\n> = ({context, action}) => {\n  const keyGenerator = context.keyGenerator\n  const schema = context.schema\n  const editor = action.editor\n\n  if (!editor.selection) {\n    return\n  }\n\n  const [focusSpan] = Array.from(\n    Editor.nodes(editor, {\n      mode: 'lowest',\n      at: editor.selection.focus,\n      match: (n) => editor.isTextSpan(n),\n      voids: false,\n    }),\n  )[0] ?? [undefined]\n  const focusDecorators =\n    focusSpan?.marks?.filter((mark) =>\n      schema.decorators.some((decorator) => decorator.value === mark),\n    ) ?? []\n  const focusAnnotations =\n    focusSpan?.marks?.filter(\n      (mark) =>\n        !schema.decorators.some((decorator) => decorator.value === mark),\n    ) ?? []\n\n  const anchorBlockPath = editor.selection.anchor.path.slice(0, 1)\n  const focusBlockPath = editor.selection.focus.path.slice(0, 1)\n  const focusBlock = Node.descendant(editor, focusBlockPath) as\n    | SlateTextBlock\n    | VoidElement\n\n  if (editor.isTextBlock(focusBlock)) {\n    const [start, end] = Range.edges(editor.selection)\n    const lastFocusBlockChild =\n      focusBlock.children[focusBlock.children.length - 1]\n    const atTheEndOfBlock = isEqual(start, {\n      path: [...focusBlockPath, focusBlock.children.length - 1],\n      offset: editor.isTextSpan(lastFocusBlockChild)\n        ? lastFocusBlockChild.text.length\n        : 0,\n    })\n    const atTheStartOfBlock = isEqual(end, {\n      path: [...focusBlockPath, 0],\n      offset: 0,\n    })\n\n    if (atTheEndOfBlock && Range.isCollapsed(editor.selection)) {\n      Editor.insertNode(\n        editor,\n        editor.pteCreateTextBlock({\n          decorators: [],\n          listItem: focusBlock.listItem,\n          level: focusBlock.level,\n        }),\n      )\n\n      return\n    }\n\n    if (atTheStartOfBlock && Range.isCollapsed(editor.selection)) {\n      Editor.insertNode(\n        editor,\n        editor.pteCreateTextBlock({\n          decorators: focusAnnotations.length === 0 ? focusDecorators : [],\n          listItem: focusBlock.listItem,\n          level: focusBlock.level,\n        }),\n      )\n\n      const [nextBlockPath] = Path.next(focusBlockPath)\n\n      Transforms.select(editor, {\n        anchor: {path: [nextBlockPath, 0], offset: 0},\n        focus: {path: [nextBlockPath, 0], offset: 0},\n      })\n\n      return\n    }\n\n    const selectionAcrossBlocks = anchorBlockPath[0] !== focusBlockPath[0]\n\n    const isInTheMiddleOfNode = !atTheStartOfBlock && !atTheEndOfBlock\n\n    if (isInTheMiddleOfNode && !selectionAcrossBlocks) {\n      Editor.withoutNormalizing(editor, () => {\n        if (!editor.selection) {\n          return\n        }\n\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n        })\n\n        const [nextNode, nextNodePath] = Editor.node(\n          editor,\n          Path.next(focusBlockPath),\n          {depth: 1},\n        )\n\n        Transforms.setSelection(editor, {\n          anchor: {path: [...nextNodePath, 0], offset: 0},\n          focus: {path: [...nextNodePath, 0], offset: 0},\n        })\n\n        /**\n         * Assign new keys to markDefs that are now split across two blocks\n         */\n        if (\n          editor.isTextBlock(nextNode) &&\n          nextNode.markDefs &&\n          nextNode.markDefs.length > 0\n        ) {\n          const newMarkDefKeys = new Map<string, string>()\n\n          const prevNodeSpans = Array.from(\n            Node.children(editor, focusBlockPath),\n          )\n            .map((entry) => entry[0])\n            .filter((node) => editor.isTextSpan(node))\n          const children = Node.children(editor, nextNodePath)\n\n          for (const [child, childPath] of children) {\n            if (!editor.isTextSpan(child)) {\n              continue\n            }\n\n            const marks = child.marks ?? []\n\n            // Go through the marks of the span and figure out if any of\n            // them refer to annotations that are also present in the\n            // previous block\n            for (const mark of marks) {\n              if (\n                schema.decorators.some((decorator) => decorator.value === mark)\n              ) {\n                continue\n              }\n\n              if (\n                prevNodeSpans.some((prevNodeSpan) =>\n                  prevNodeSpan.marks?.includes(mark),\n                ) &&\n                !newMarkDefKeys.has(mark)\n              ) {\n                // This annotation is both present in the previous block\n                // and this block, so let's assign a new key to it\n                newMarkDefKeys.set(mark, keyGenerator())\n              }\n            }\n\n            const newMarks = marks.map(\n              (mark) => newMarkDefKeys.get(mark) ?? mark,\n            )\n\n            // No need to update the marks if they are the same\n            if (!isEqual(marks, newMarks)) {\n              Transforms.setNodes(\n                editor,\n                {marks: newMarks},\n                {\n                  at: childPath,\n                },\n              )\n            }\n          }\n\n          // Time to update all the markDefs that need a new key because\n          // they've been split across blocks\n          const newMarkDefs = nextNode.markDefs.map((markDef) => ({\n            ...markDef,\n            _key: newMarkDefKeys.get(markDef._key) ?? markDef._key,\n          }))\n\n          // No need to update the markDefs if they are the same\n          if (!isEqual(nextNode.markDefs, newMarkDefs)) {\n            Transforms.setNodes(\n              editor,\n              {markDefs: newMarkDefs},\n              {\n                at: nextNodePath,\n                match: (node) => editor.isTextBlock(node),\n              },\n            )\n          }\n        }\n      })\n      editor.onChange()\n      return\n    }\n  }\n\n  Transforms.splitNodes(editor, {always: true})\n}\n\nexport const insertSoftBreakActionImplementation: BehaviorActionImplementation<\n  'insert.soft break'\n> = ({context, action}) => {\n  // This mimics Slate's internal which also just does a regular insert break\n  // when soft-breaking\n  insertBreakActionImplementation({\n    context,\n    action: {...action, type: 'insert.break'},\n  })\n}\n","import {Editor, Transforms, type Element} from 'slate'\nimport {toSlateValue} from '../internal-utils/values'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const insertInlineObjectActionImplementation: BehaviorActionImplementation<\n  'insert.inline object'\n> = ({context, action}) => {\n  if (\n    !context.schema.inlineObjects.some(\n      (inlineObject) => inlineObject.name === action.inlineObject.name,\n    )\n  ) {\n    console.error('Unable to insert unknown inline object')\n    return\n  }\n\n  if (!action.editor.selection) {\n    console.error('Unable to insert inline object without selection')\n    return\n  }\n\n  const [focusTextBlock] = Array.from(\n    Editor.nodes(action.editor, {\n      at: action.editor.selection.focus.path,\n      match: (node) => action.editor.isTextBlock(node),\n    }),\n  ).at(0) ?? [undefined, undefined]\n\n  if (!focusTextBlock) {\n    console.error('Unable to perform action without focus text block')\n    return\n  }\n\n  const block = toSlateValue(\n    [\n      {\n        _type: context.schema.block.name,\n        _key: context.keyGenerator(),\n        children: [\n          {\n            _type: action.inlineObject.name,\n            _key: context.keyGenerator(),\n            ...(action.inlineObject.value ?? {}),\n          },\n        ],\n      },\n    ],\n    {schemaTypes: context.schema},\n  ).at(0) as unknown as Element\n  const child = block?.children.at(0)\n\n  if (!child) {\n    console.error('Unable to insert inline object')\n    return\n  }\n\n  Transforms.insertNodes(action.editor, child)\n}\n","import {Editor, Transforms} from 'slate'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const insertSpanActionImplementation: BehaviorActionImplementation<\n  'insert.span'\n> = ({context, action}) => {\n  if (!action.editor.selection) {\n    console.error('Unable to perform action without selection', action)\n    return\n  }\n\n  const [focusBlock, focusBlockPath] = Array.from(\n    Editor.nodes(action.editor, {\n      at: action.editor.selection.focus.path,\n      match: (node) => action.editor.isTextBlock(node),\n    }),\n  )[0] ?? [undefined, undefined]\n\n  if (!focusBlock || !focusBlockPath) {\n    console.error('Unable to perform action without focus block', action)\n    return\n  }\n\n  const markDefs = focusBlock.markDefs ?? []\n  const annotations = action.annotations\n    ? action.annotations.map((annotation) => ({\n        _type: annotation.name,\n        _key: context.keyGenerator(),\n        ...annotation.value,\n      }))\n    : undefined\n\n  if (annotations && annotations.length > 0) {\n    Transforms.setNodes(action.editor, {\n      markDefs: [...markDefs, ...annotations],\n    })\n  }\n\n  Transforms.insertNodes(action.editor, {\n    _type: 'span',\n    _key: context.keyGenerator(),\n    text: action.text,\n    marks: [\n      ...(annotations?.map((annotation) => annotation._key) ?? []),\n      ...(action.decorators ?? []),\n    ],\n  })\n}\n","import {Transforms} from 'slate'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const textBlockSetActionImplementation: BehaviorActionImplementation<\n  'text block.set'\n> = ({action}) => {\n  const at = toSlateRange(\n    {\n      anchor: {path: action.at, offset: 0},\n      focus: {path: action.at, offset: 0},\n    },\n    action.editor,\n  )!\n\n  Transforms.setNodes(\n    action.editor,\n    {\n      ...(action.style ? {style: action.style} : {}),\n      ...(action.listItem ? {listItem: action.listItem} : {}),\n      ...(action.level ? {level: action.level} : {}),\n    },\n    {at},\n  )\n}\n","import {Transforms} from 'slate'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport type {BehaviorActionImplementation} from './behavior.actions'\n\nexport const textBlockUnsetActionImplementation: BehaviorActionImplementation<\n  'text block.unset'\n> = ({action}) => {\n  const at = toSlateRange(\n    {\n      anchor: {path: action.at, offset: 0},\n      focus: {path: action.at, offset: 0},\n    },\n    action.editor,\n  )!\n\n  Transforms.unsetNodes(action.editor, action.props, {at})\n}\n","import {\n  deleteBackward,\n  deleteForward,\n  insertText,\n  Path,\n  Transforms,\n} from 'slate'\nimport {ReactEditor} from 'slate-react'\nimport type {\n  BehaviorAction,\n  SyntheticBehaviorEvent,\n} from '../behaviors/behavior.types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {\n  addAnnotationActionImplementation,\n  removeAnnotationActionImplementation,\n  toggleAnnotationActionImplementation,\n} from '../editor/plugins/createWithEditableAPI'\nimport {\n  addDecoratorActionImplementation,\n  removeDecoratorActionImplementation,\n  toggleDecoratorActionImplementation,\n} from '../editor/plugins/createWithPortableTextMarkModel'\nimport {toSlatePath} from '../internal-utils/paths'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {fromSlateValue, toSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {PickFromUnion} from '../type-utils'\nimport {blockOffsetToSpanSelectionPoint} from '../utils/util.block-offset'\nimport {insertBlock} from './behavior.action-utils.insert-block'\nimport {insertBlockObjectActionImplementation} from './behavior.action.insert-block-object'\nimport {\n  insertBreakActionImplementation,\n  insertSoftBreakActionImplementation,\n} from './behavior.action.insert-break'\nimport {insertInlineObjectActionImplementation} from './behavior.action.insert-inline-object'\nimport {insertSpanActionImplementation} from './behavior.action.insert-span'\nimport {\n  addListItemActionImplementation,\n  removeListItemActionImplementation,\n  toggleListItemActionImplementation,\n} from './behavior.action.list-item'\nimport {\n  addStyleActionImplementation,\n  removeStyleActionImplementation,\n  toggleStyleActionImplementation,\n} from './behavior.action.style'\nimport {textBlockSetActionImplementation} from './behavior.action.text-block.set'\nimport {textBlockUnsetActionImplementation} from './behavior.action.text-block.unset'\n\nexport type BehaviorActionImplementationContext = Pick<\n  EditorContext,\n  'keyGenerator' | 'schema'\n>\n\nexport type BehaviorActionImplementation<\n  TBehaviorActionType extends BehaviorAction['type'],\n  TReturnType = void,\n> = ({\n  context,\n  action,\n}: {\n  context: BehaviorActionImplementationContext\n  action: PickFromUnion<BehaviorAction, 'type', TBehaviorActionType>\n}) => TReturnType\n\ntype BehaviorActionImplementations = {\n  [TBehaviorActionType in BehaviorAction['type']]: BehaviorActionImplementation<TBehaviorActionType>\n}\n\nconst behaviorActionImplementations: BehaviorActionImplementations = {\n  'annotation.add': addAnnotationActionImplementation,\n  'annotation.remove': removeAnnotationActionImplementation,\n  'annotation.toggle': toggleAnnotationActionImplementation,\n  'blur': ({action}) => {\n    ReactEditor.blur(action.editor)\n  },\n  'decorator.add': addDecoratorActionImplementation,\n  'decorator.remove': removeDecoratorActionImplementation,\n  'decorator.toggle': toggleDecoratorActionImplementation,\n  'focus': ({action}) => {\n    ReactEditor.focus(action.editor)\n  },\n  'delete.backward': ({action}) => {\n    deleteBackward(action.editor, action.unit)\n  },\n  'delete.forward': ({action}) => {\n    deleteForward(action.editor, action.unit)\n  },\n  'delete.block': ({action}) => {\n    const range = toSlateRange(\n      {\n        anchor: {path: action.blockPath, offset: 0},\n        focus: {path: action.blockPath, offset: 0},\n      },\n      action.editor,\n    )\n\n    if (!range) {\n      console.error('Unable to find Slate range from selection points')\n      return\n    }\n\n    Transforms.removeNodes(action.editor, {\n      at: range,\n    })\n  },\n  'delete.text': ({context, action}) => {\n    const value = fromSlateValue(\n      action.editor.children,\n      context.schema.block.name,\n      KEY_TO_VALUE_ELEMENT.get(action.editor),\n    )\n\n    const anchor = blockOffsetToSpanSelectionPoint({\n      value,\n      blockOffset: action.anchor,\n    })\n    const focus = blockOffsetToSpanSelectionPoint({\n      value,\n      blockOffset: action.focus,\n    })\n\n    if (!anchor || !focus) {\n      console.error('Unable to find anchor or focus selection point')\n      return\n    }\n\n    const range = toSlateRange(\n      {\n        anchor,\n        focus,\n      },\n      action.editor,\n    )\n\n    if (!range) {\n      console.error('Unable to find Slate range from selection points')\n      return\n    }\n\n    Transforms.delete(action.editor, {\n      at: range,\n    })\n  },\n  'insert.block object': insertBlockObjectActionImplementation,\n  'insert.break': insertBreakActionImplementation,\n  'insert.inline object': insertInlineObjectActionImplementation,\n  'insert.soft break': insertSoftBreakActionImplementation,\n  'insert.span': insertSpanActionImplementation,\n  'insert.text': ({action}) => {\n    insertText(action.editor, action.text)\n  },\n  'insert.text block': ({context, action}) => {\n    const block = toSlateValue(\n      [\n        {\n          _key: context.keyGenerator(),\n          _type: context.schema.block.name,\n          style: context.schema.styles[0].value ?? 'normal',\n          markDefs: [],\n          children: action.textBlock?.children?.map((child) => ({\n            ...child,\n            _key: context.keyGenerator(),\n          })) ?? [\n            {\n              _type: context.schema.span.name,\n              _key: context.keyGenerator(),\n              text: '',\n            },\n          ],\n        },\n      ],\n      {schemaTypes: context.schema},\n    )[0]\n\n    insertBlock({\n      block,\n      editor: action.editor,\n      schema: context.schema,\n      placement: action.placement,\n    })\n  },\n  'effect': ({action}) => {\n    action.effect()\n  },\n  'list item.add': addListItemActionImplementation,\n  'list item.remove': removeListItemActionImplementation,\n  'list item.toggle': toggleListItemActionImplementation,\n  'move.block': ({action}) => {\n    const at = [toSlatePath(action.at, action.editor)[0]]\n    const to = [toSlatePath(action.to, action.editor)[0]]\n\n    Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: 'highest',\n    })\n  },\n  'move.block down': ({action}) => {\n    const at = [toSlatePath(action.at, action.editor)[0]]\n    const to = [Path.next(at)[0]]\n\n    Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: 'highest',\n    })\n  },\n  'move.block up': ({action}) => {\n    const at = [toSlatePath(action.at, action.editor)[0]]\n\n    if (!Path.hasPrevious(at)) {\n      return\n    }\n\n    const to = [Path.previous(at)[0]]\n\n    Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: 'highest',\n    })\n  },\n  'noop': () => {},\n  'select': ({action}) => {\n    const newSelection = toSlateRange(action.selection, action.editor)\n\n    if (newSelection) {\n      Transforms.select(action.editor, newSelection)\n    } else {\n      Transforms.deselect(action.editor)\n    }\n  },\n  'select.previous block': ({action}) => {\n    if (!action.editor.selection) {\n      console.error('Unable to select previous block without a selection')\n      return\n    }\n\n    const blockPath = action.editor.selection.focus.path.slice(0, 1)\n\n    if (!Path.hasPrevious(blockPath)) {\n      console.error(\"There's no previous block to select\")\n      return\n    }\n\n    const previousBlockPath = Path.previous(blockPath)\n\n    Transforms.select(action.editor, previousBlockPath)\n  },\n  'select.next block': ({action}) => {\n    if (!action.editor.selection) {\n      console.error('Unable to select next block without a selection')\n      return\n    }\n\n    const blockPath = action.editor.selection.focus.path.slice(0, 1)\n    const nextBlockPath = [blockPath[0] + 1]\n\n    Transforms.select(action.editor, nextBlockPath)\n  },\n  'style.toggle': toggleStyleActionImplementation,\n  'style.add': addStyleActionImplementation,\n  'style.remove': removeStyleActionImplementation,\n  'text block.set': textBlockSetActionImplementation,\n  'text block.unset': textBlockUnsetActionImplementation,\n}\n\nexport function performAction({\n  context,\n  action,\n}: {\n  context: BehaviorActionImplementationContext\n  action: BehaviorAction\n}) {\n  switch (action.type) {\n    case 'annotation.toggle': {\n      behaviorActionImplementations['annotation.toggle']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'decorator.add': {\n      behaviorActionImplementations['decorator.add']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'decorator.remove': {\n      behaviorActionImplementations['decorator.remove']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'delete.block': {\n      behaviorActionImplementations['delete.block']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'delete.text': {\n      behaviorActionImplementations['delete.text']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.span': {\n      behaviorActionImplementations['insert.span']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.text block': {\n      behaviorActionImplementations['insert.text block']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'list item.add': {\n      behaviorActionImplementations['list item.add']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'list item.remove': {\n      behaviorActionImplementations['list item.remove']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'move.block': {\n      behaviorActionImplementations['move.block']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'move.block down': {\n      behaviorActionImplementations['move.block down']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'move.block up': {\n      behaviorActionImplementations['move.block up']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'noop': {\n      behaviorActionImplementations.noop({\n        context,\n        action,\n      })\n      break\n    }\n    case 'effect': {\n      behaviorActionImplementations.effect({\n        context,\n        action,\n      })\n      break\n    }\n    case 'select': {\n      behaviorActionImplementations.select({\n        context,\n        action,\n      })\n      break\n    }\n    case 'select.previous block': {\n      behaviorActionImplementations['select.previous block']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'select.next block': {\n      behaviorActionImplementations['select.next block']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'style.add': {\n      behaviorActionImplementations['style.add']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'style.remove': {\n      behaviorActionImplementations['style.remove']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'text block.set': {\n      behaviorActionImplementations['text block.set']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'text block.unset': {\n      behaviorActionImplementations['text block.unset']({\n        context,\n        action,\n      })\n      break\n    }\n    default: {\n      performDefaultAction({context, action})\n    }\n  }\n}\n\nfunction performDefaultAction({\n  context,\n  action,\n}: {\n  context: BehaviorActionImplementationContext\n  action: PickFromUnion<BehaviorAction, 'type', SyntheticBehaviorEvent['type']>\n}) {\n  switch (action.type) {\n    case 'annotation.add': {\n      behaviorActionImplementations['annotation.add']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'annotation.remove': {\n      behaviorActionImplementations['annotation.remove']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'blur': {\n      behaviorActionImplementations.blur({\n        context,\n        action,\n      })\n      break\n    }\n    case 'decorator.toggle': {\n      behaviorActionImplementations['decorator.toggle']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'delete.backward': {\n      behaviorActionImplementations['delete.backward']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'delete.forward': {\n      behaviorActionImplementations['delete.forward']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'focus': {\n      behaviorActionImplementations.focus({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.block object': {\n      behaviorActionImplementations['insert.block object']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.inline object': {\n      behaviorActionImplementations['insert.inline object']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.break': {\n      behaviorActionImplementations['insert.break']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.soft break': {\n      behaviorActionImplementations['insert.soft break']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'insert.text': {\n      behaviorActionImplementations['insert.text']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'list item.toggle': {\n      behaviorActionImplementations['list item.toggle']({\n        context,\n        action,\n      })\n      break\n    }\n    case 'select': {\n      behaviorActionImplementations.select({\n        context,\n        action,\n      })\n      break\n    }\n    default: {\n      behaviorActionImplementations['style.toggle']({\n        context,\n        action,\n      })\n    }\n  }\n}\n","import {Editor} from 'slate'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorSchema} from './define-schema'\n\nexport function getActiveDecorators({\n  schema,\n  slateEditorInstance,\n}: {\n  schema: EditorSchema\n  slateEditorInstance: PortableTextSlateEditor\n}) {\n  const decorators = schema.decorators.map((decorator) => decorator.value)\n\n  const marks =\n    {\n      ...(Editor.marks(slateEditorInstance) ?? {}),\n    }.marks ?? []\n\n  return marks.filter((mark) => decorators.includes(mark))\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport {toPortableTextRange} from '../internal-utils/ranges'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {EditorSelection, PortableTextSlateEditor} from '../types/editor'\nimport type {EditorSchema} from './define-schema'\nimport {getActiveDecorators} from './get-active-decorators'\n\n/**\n * @public\n */\nexport type EditorContext = {\n  activeDecorators: Array<string>\n  keyGenerator: () => string\n  schema: EditorSchema\n  selection: EditorSelection\n  value: Array<PortableTextBlock>\n}\n\n/**\n * @public\n */\nexport type EditorSnapshot = {\n  context: EditorContext\n}\n\nexport function createEditorSnapshot({\n  editor,\n  keyGenerator,\n  schema,\n}: {\n  editor: PortableTextSlateEditor\n  keyGenerator: () => string\n  schema: EditorSchema\n}) {\n  const value = fromSlateValue(\n    editor.children,\n    schema.block.name,\n    KEY_TO_VALUE_ELEMENT.get(editor),\n  )\n  const selection = toPortableTextRange(value, editor.selection, schema)\n\n  const context = {\n    activeDecorators: getActiveDecorators({\n      schema,\n      slateEditorInstance: editor,\n    }),\n    keyGenerator,\n    schema,\n    selection,\n    value,\n  } satisfies EditorContext\n\n  return {\n    context,\n  } satisfies EditorSnapshot\n}\n","import type {Patch} from '@portabletext/patches'\nimport type {PortableTextBlock} from '@sanity/types'\nimport type {FocusEvent} from 'react'\nimport {Editor} from 'slate'\nimport {\n  assertEvent,\n  assign,\n  emit,\n  enqueueActions,\n  setup,\n  type ActorRefFrom,\n} from 'xstate'\nimport {performAction} from '../behavior-actions/behavior.actions'\nimport {coreBehaviors} from '../behaviors/behavior.core'\nimport {\n  isCustomBehaviorEvent,\n  type Behavior,\n  type BehaviorAction,\n  type CustomBehaviorEvent,\n  type NativeBehaviorEvent,\n  type SyntheticBehaviorEvent,\n} from '../behaviors/behavior.types'\nimport type {OmitFromUnion, PickFromUnion} from '../type-utils'\nimport type {\n  EditorSelection,\n  InvalidValueResolution,\n  PortableTextSlateEditor,\n} from '../types/editor'\nimport type {EditorSchema} from './define-schema'\nimport {createEditorSnapshot} from './editor-snapshot'\nimport {withApplyingBehaviorActions} from './with-applying-behavior-actions'\n\nexport * from 'xstate/guards'\n\n/**\n * @internal\n */\nexport type EditorActor = ActorRefFrom<typeof editorMachine>\n\n/**\n * @internal\n */\nexport type PatchEvent = {type: 'patch'; patch: Patch}\n\n/**\n * @internal\n */\nexport type PatchesEvent = {\n  type: 'patches'\n  patches: Array<Patch>\n  snapshot: Array<PortableTextBlock> | undefined\n}\n\n/**\n * @internal\n */\nexport type MutationEvent = {\n  type: 'mutation'\n  patches: Array<Patch>\n  /**\n   * @deprecated Use `value` instead\n   */\n  snapshot: Array<PortableTextBlock> | undefined\n  value: Array<PortableTextBlock> | undefined\n}\n\n/**\n * @internal\n */\nexport type InternalEditorEvent =\n  | {type: 'normalizing'}\n  | {type: 'done normalizing'}\n  | {type: 'done syncing initial value'}\n  | {\n      type: 'behavior event'\n      behaviorEvent: SyntheticBehaviorEvent | NativeBehaviorEvent\n      editor: PortableTextSlateEditor\n      defaultActionCallback?: () => void\n      nativeEvent?: {preventDefault: () => void}\n    }\n  | {\n      type: 'custom behavior event'\n      behaviorEvent: CustomBehaviorEvent\n      editor: PortableTextSlateEditor\n      nativeEvent?: {preventDefault: () => void}\n    }\n  | CustomBehaviorEvent\n  | {\n      type: 'add behavior'\n      behavior: Behavior\n    }\n  | {\n      type: 'remove behavior'\n      behavior: Behavior\n    }\n  | {\n      type: 'update readOnly'\n      readOnly: boolean\n    }\n  | {\n      type: 'update schema'\n      schema: EditorSchema\n    }\n  | {\n      type: 'update behaviors'\n      behaviors: Array<Behavior>\n    }\n  | {\n      type: 'update value'\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'update maxBlocks'\n      maxBlocks: number | undefined\n    }\n  | OmitFromUnion<\n      InternalEditorEmittedEvent,\n      'type',\n      'ready' | 'read only' | 'editable'\n    >\n\n/**\n * @public\n */\nexport type EditorEmittedEvent = PickFromUnion<\n  InternalEditorEmittedEvent,\n  'type',\n  | 'blurred'\n  | 'done loading'\n  | 'editable'\n  | 'error'\n  | 'focused'\n  | 'invalid value'\n  | 'loading'\n  | 'mutation'\n  | 'patch'\n  | 'read only'\n  | 'ready'\n  | 'selection'\n  | 'value changed'\n>\n\n/**\n * @internal\n */\nexport type InternalEditorEmittedEvent =\n  | {type: 'ready'}\n  | PatchEvent\n  | PatchesEvent\n  | MutationEvent\n  | {\n      type: 'unset'\n      previousValue: Array<PortableTextBlock>\n    }\n  | {\n      type: 'value changed'\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'invalid value'\n      resolution: InvalidValueResolution | null\n      value: Array<PortableTextBlock> | undefined\n    }\n  | {\n      type: 'error'\n      name: string\n      description: string\n      data: unknown\n    }\n  | {type: 'select'; selection: EditorSelection}\n  | {type: 'selection'; selection: EditorSelection}\n  | {type: 'blurred'; event: FocusEvent<HTMLDivElement, Element>}\n  | {type: 'focused'; event: FocusEvent<HTMLDivElement, Element>}\n  | {type: 'loading'}\n  | {type: 'done loading'}\n  | {type: 'read only'}\n  | {type: 'editable'}\n  | PickFromUnion<\n      SyntheticBehaviorEvent,\n      'type',\n      | 'annotation.add'\n      | 'annotation.remove'\n      | 'blur'\n      | 'decorator.toggle'\n      | 'insert.block object'\n      | 'insert.inline object'\n      | 'list item.toggle'\n      | 'focus'\n      | 'style.toggle'\n    >\n  | {\n      type: 'custom.*'\n      event: CustomBehaviorEvent\n    }\n\n/**\n * @internal\n */\nexport const editorMachine = setup({\n  types: {\n    context: {} as {\n      behaviors: Set<Behavior>\n      keyGenerator: () => string\n      pendingEvents: Array<PatchEvent | MutationEvent>\n      schema: EditorSchema\n      initialReadOnly: boolean\n      maxBlocks: number | undefined\n      selection: EditorSelection\n      value: Array<PortableTextBlock> | undefined\n    },\n    events: {} as InternalEditorEvent,\n    emitted: {} as InternalEditorEmittedEvent,\n    input: {} as {\n      behaviors?: Array<Behavior>\n      keyGenerator: () => string\n      maxBlocks?: number\n      readOnly?: boolean\n      schema: EditorSchema\n      value?: Array<PortableTextBlock>\n    },\n  },\n  actions: {\n    'add behavior to context': assign({\n      behaviors: ({context, event}) => {\n        assertEvent(event, 'add behavior')\n\n        return new Set([...context.behaviors, event.behavior])\n      },\n    }),\n    'remove behavior from context': assign({\n      behaviors: ({context, event}) => {\n        assertEvent(event, 'remove behavior')\n\n        context.behaviors.delete(event.behavior)\n\n        return new Set([...context.behaviors])\n      },\n    }),\n    'assign behaviors': assign({\n      behaviors: ({event}) => {\n        assertEvent(event, 'update behaviors')\n        return new Set(event.behaviors)\n      },\n    }),\n    'assign schema': assign({\n      schema: ({event}) => {\n        assertEvent(event, 'update schema')\n        return event.schema\n      },\n    }),\n    'emit patch event': emit(({event}) => {\n      assertEvent(event, 'patch')\n      return event\n    }),\n    'emit mutation event': emit(({event}) => {\n      assertEvent(event, 'mutation')\n      return event\n    }),\n    'emit read only': emit({type: 'read only'}),\n    'emit editable': emit({type: 'editable'}),\n    'defer event': assign({\n      pendingEvents: ({context, event}) => {\n        assertEvent(event, ['patch', 'mutation'])\n        return [...context.pendingEvents, event]\n      },\n    }),\n    'emit pending events': enqueueActions(({context, enqueue}) => {\n      for (const event of context.pendingEvents) {\n        enqueue(emit(event))\n      }\n    }),\n    'emit ready': emit({type: 'ready'}),\n    'clear pending events': assign({\n      pendingEvents: [],\n    }),\n    'handle behavior event': enqueueActions(({context, event, enqueue}) => {\n      assertEvent(event, ['behavior event', 'custom behavior event'])\n\n      const defaultAction =\n        event.type === 'custom behavior event' ||\n        event.behaviorEvent.type === 'copy' ||\n        event.behaviorEvent.type === 'key.down' ||\n        event.behaviorEvent.type === 'key.up' ||\n        event.behaviorEvent.type === 'paste'\n          ? undefined\n          : ({\n              ...event.behaviorEvent,\n              editor: event.editor,\n            } satisfies BehaviorAction)\n      const defaultActionCallback =\n        event.type === 'behavior event'\n          ? event.defaultActionCallback\n          : undefined\n\n      const eventBehaviors = [...context.behaviors.values()].filter(\n        (behavior) => behavior.on === event.behaviorEvent.type,\n      )\n\n      if (eventBehaviors.length === 0) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            Editor.withoutNormalizing(event.editor, () => {\n              try {\n                defaultActionCallback()\n              } catch (error) {\n                console.error(\n                  new Error(\n                    `Performing action \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n                  ),\n                )\n              }\n            })\n          })\n          return\n        }\n\n        if (!defaultAction) {\n          return\n        }\n\n        withApplyingBehaviorActions(event.editor, () => {\n          Editor.withoutNormalizing(event.editor, () => {\n            try {\n              performAction({\n                context,\n                action: defaultAction,\n              })\n            } catch (error) {\n              console.error(\n                new Error(\n                  `Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n                ),\n              )\n            }\n          })\n        })\n        event.editor.onChange()\n        return\n      }\n\n      const editorSnapshot = createEditorSnapshot({\n        editor: event.editor,\n        keyGenerator: context.keyGenerator,\n        schema: context.schema,\n      })\n\n      let behaviorOverwritten = false\n\n      for (const eventBehavior of eventBehaviors) {\n        const shouldRun =\n          eventBehavior.guard === undefined ||\n          eventBehavior.guard({\n            context: editorSnapshot.context,\n            event: event.behaviorEvent,\n          })\n\n        if (!shouldRun) {\n          continue\n        }\n\n        const actionIntendSets = eventBehavior.actions.map((actionSet) =>\n          actionSet(\n            {context: editorSnapshot.context, event: event.behaviorEvent},\n            shouldRun,\n          ),\n        )\n\n        for (const actionIntends of actionIntendSets) {\n          behaviorOverwritten =\n            behaviorOverwritten ||\n            (actionIntends.length > 0 &&\n              actionIntends.some(\n                (actionIntend) => actionIntend.type !== 'effect',\n              ))\n\n          withApplyingBehaviorActions(event.editor, () => {\n            Editor.withoutNormalizing(event.editor, () => {\n              for (const actionIntend of actionIntends) {\n                if (actionIntend.type === 'raise') {\n                  if (isCustomBehaviorEvent(actionIntend.event)) {\n                    enqueue.raise({\n                      type: 'custom behavior event',\n                      behaviorEvent: actionIntend.event as CustomBehaviorEvent,\n                      editor: event.editor,\n                    })\n                  } else {\n                    enqueue.raise({\n                      type: 'behavior event',\n                      behaviorEvent: actionIntend.event,\n                      editor: event.editor,\n                    })\n                  }\n                  continue\n                }\n\n                const action = {\n                  ...actionIntend,\n                  editor: event.editor,\n                }\n\n                try {\n                  performAction({context, action})\n                } catch (error) {\n                  console.error(\n                    new Error(\n                      `Performing action \"${action.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n                    ),\n                  )\n                  break\n                }\n              }\n            })\n          })\n          event.editor.onChange()\n        }\n\n        if (behaviorOverwritten) {\n          event.nativeEvent?.preventDefault()\n          break\n        }\n      }\n\n      if (!behaviorOverwritten) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            Editor.withoutNormalizing(event.editor, () => {\n              try {\n                defaultActionCallback()\n              } catch (error) {\n                console.error(\n                  new Error(\n                    `Performing \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n                  ),\n                )\n              }\n            })\n          })\n          return\n        }\n\n        if (!defaultAction) {\n          return\n        }\n\n        withApplyingBehaviorActions(event.editor, () => {\n          Editor.withoutNormalizing(event.editor, () => {\n            try {\n              performAction({\n                context,\n                action: defaultAction,\n              })\n            } catch (error) {\n              console.error(\n                new Error(\n                  `Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`,\n                ),\n              )\n            }\n          })\n        })\n        event.editor.onChange()\n      }\n    }),\n  },\n}).createMachine({\n  id: 'editor',\n  context: ({input}) => ({\n    behaviors: new Set(input.behaviors ?? coreBehaviors),\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? false,\n    maxBlocks: input.maxBlocks,\n    value: input.value,\n  }),\n  on: {\n    'add behavior': {actions: 'add behavior to context'},\n    'remove behavior': {actions: 'remove behavior from context'},\n    'unset': {actions: emit(({event}) => event)},\n    'value changed': {actions: emit(({event}) => event)},\n    'invalid value': {actions: emit(({event}) => event)},\n    'error': {actions: emit(({event}) => event)},\n    'selection': {\n      actions: [\n        assign({selection: ({event}) => event.selection}),\n        emit(({event}) => event),\n      ],\n    },\n    'blurred': {actions: emit(({event}) => event)},\n    'focused': {actions: emit(({event}) => event)},\n    'loading': {actions: emit({type: 'loading'})},\n    'patches': {actions: emit(({event}) => event)},\n    'done loading': {actions: emit({type: 'done loading'})},\n    'update behaviors': {actions: 'assign behaviors'},\n    'update schema': {actions: 'assign schema'},\n    'update value': {actions: assign({value: ({event}) => event.value})},\n    'update maxBlocks': {\n      actions: assign({maxBlocks: ({event}) => event.maxBlocks}),\n    },\n  },\n  type: 'parallel',\n  states: {\n    'edit mode': {\n      initial: 'read only',\n      states: {\n        'read only': {\n          initial: 'determine initial edit mode',\n          states: {\n            'determine initial edit mode': {\n              on: {\n                'done syncing initial value': [\n                  {\n                    target: '#editor.edit mode.read only.read only',\n                    guard: ({context}) => context.initialReadOnly,\n                  },\n                  {\n                    target: '#editor.edit mode.editable',\n                  },\n                ],\n              },\n            },\n            'read only': {\n              on: {\n                'update readOnly': {\n                  guard: ({event}) => !event.readOnly,\n                  target: '#editor.edit mode.editable',\n                  actions: ['emit editable'],\n                },\n              },\n            },\n          },\n        },\n        'editable': {\n          on: {\n            'update readOnly': {\n              guard: ({event}) => event.readOnly,\n              target: '#editor.edit mode.read only.read only',\n              actions: ['emit read only'],\n            },\n            'behavior event': {\n              actions: 'handle behavior event',\n            },\n            'custom behavior event': {\n              actions: 'handle behavior event',\n            },\n            'annotation.*': {\n              actions: emit(({event}) => event),\n            },\n            'blur': {\n              actions: emit(({event}) => event),\n            },\n            'custom.*': {\n              actions: emit(({event}) => ({type: 'custom.*', event})),\n            },\n            'decorator.*': {\n              actions: emit(({event}) => event),\n            },\n            'focus': {\n              actions: emit(({event}) => event),\n            },\n            'insert.*': {\n              actions: emit(({event}) => event),\n            },\n            'list item.*': {\n              actions: emit(({event}) => event),\n            },\n            'select': {\n              actions: emit(({event}) => event),\n            },\n            'style.*': {\n              actions: emit(({event}) => event),\n            },\n          },\n        },\n      },\n    },\n    'setup': {\n      initial: 'setting up',\n      states: {\n        'setting up': {\n          exit: ['emit ready'],\n          on: {\n            'patch': {\n              actions: 'defer event',\n            },\n            'mutation': {\n              actions: 'defer event',\n            },\n            'done syncing initial value': {\n              target: 'pristine',\n            },\n          },\n        },\n        'pristine': {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                normalizing: {\n                  target: 'normalizing',\n                },\n                patch: {\n                  actions: 'defer event',\n                  target: '#editor.setup.dirty',\n                },\n                mutation: {\n                  actions: 'defer event',\n                  target: '#editor.setup.dirty',\n                },\n              },\n            },\n            normalizing: {\n              on: {\n                'done normalizing': {\n                  target: 'idle',\n                },\n                'patch': {\n                  actions: 'defer event',\n                },\n                'mutation': {\n                  actions: 'defer event',\n                },\n              },\n            },\n          },\n        },\n        'dirty': {\n          entry: ['emit pending events', 'clear pending events'],\n          on: {\n            patch: {\n              actions: 'emit patch event',\n            },\n            mutation: {\n              actions: 'emit mutation event',\n            },\n          },\n        },\n      },\n    },\n  },\n})\n","import {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\nexport function getValue({\n  editorActorSnapshot,\n  slateEditorInstance,\n}: {\n  editorActorSnapshot: ReturnType<EditorActor['getSnapshot']>\n  slateEditorInstance: PortableTextSlateEditor\n}) {\n  return fromSlateValue(\n    slateEditorInstance.children,\n    editorActorSnapshot.context.schema.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditorInstance),\n  )\n}\n","import {useSelector} from '@xstate/react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {Editor} from './create-editor'\nimport type {EditorActor} from './editor-machine'\nimport type {EditorSnapshot} from './editor-snapshot'\nimport {getActiveDecorators} from './get-active-decorators'\nimport {getValue} from './get-value'\n\nfunction defaultCompare<T>(a: T, b: T) {\n  return a === b\n}\n\n/**\n * @public\n */\nexport type EditorSelector<TSelected> = (snapshot: EditorSnapshot) => TSelected\n\n/**\n * @public\n * Hook to select a value from the editor state.\n * @example\n * Pass a selector as the second argument\n * ```tsx\n * import { useEditorSelector } from '@portabletext/editor'\n *\n * function MyComponent(editor) {\n *  const value = useEditorSelector(editor, selector)\n * }\n * ```\n * @example\n * Pass an inline selector as the second argument.\n * In this case, use the editor context to obtain the schema.\n * ```tsx\n * import { useEditorSelector } from '@portabletext/editor'\n *\n * function MyComponent(editor) {\n *  const schema = useEditorSelector(editor, (snapshot) => snapshot.context.schema)\n * }\n * ```\n * @group Hooks\n */\nexport function useEditorSelector<TSelected>(\n  editor: Editor,\n  selector: EditorSelector<TSelected>,\n  compare: (a: TSelected, b: TSelected) => boolean = defaultCompare,\n) {\n  return useSelector(\n    editor._internal.editorActor,\n    (editorActorSnapshot) => {\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot,\n        slateEditorInstance: editor._internal.slateEditor.instance,\n      })\n\n      return selector(snapshot)\n    },\n    compare,\n  )\n}\n\nexport function getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance,\n}: {\n  editorActorSnapshot: ReturnType<EditorActor['getSnapshot']>\n  slateEditorInstance: PortableTextSlateEditor\n}): EditorSnapshot {\n  return {\n    context: {\n      activeDecorators: getActiveDecorators({\n        schema: editorActorSnapshot.context.schema,\n        slateEditorInstance,\n      }),\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      schema: editorActorSnapshot.context.schema,\n      selection: editorActorSnapshot.context.selection,\n      value: getValue({editorActorSnapshot, slateEditorInstance}),\n    },\n  }\n}\n","import getRandomValues from 'get-random-values-esm'\n\n/**\n * @public\n */\nexport const defaultKeyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {\n  ArrayDefinition,\n  ArraySchemaType,\n  PortableTextBlock,\n} from '@sanity/types'\nimport {useActorRef} from '@xstate/react'\nimport {useMemo} from 'react'\nimport {\n  createActor,\n  type ActorRef,\n  type EventObject,\n  type Snapshot,\n} from 'xstate'\nimport type {Behavior, CustomBehaviorEvent} from '../behaviors/behavior.types'\nimport {compileType} from '../internal-utils/schema'\nimport type {PickFromUnion} from '../type-utils'\nimport type {EditableAPI} from '../types/editor'\nimport {createEditorSchema} from './create-editor-schema'\nimport {createSlateEditor, type SlateEditor} from './create-slate-editor'\nimport {compileSchemaDefinition, type SchemaDefinition} from './define-schema'\nimport {\n  editorMachine,\n  type EditorActor,\n  type EditorEmittedEvent,\n  type InternalEditorEvent,\n} from './editor-machine'\nimport {getEditorSnapshot} from './editor-selector'\nimport type {EditorSnapshot} from './editor-snapshot'\nimport {defaultKeyGenerator} from './key-generator'\nimport {createEditableAPI} from './plugins/createWithEditableAPI'\n\n/**\n * @public\n */\nexport type EditorConfig = {\n  /**\n   * @beta\n   */\n  behaviors?: Array<Behavior>\n  keyGenerator?: () => string\n  /**\n   * @deprecated Will be removed in the next major version\n   */\n  maxBlocks?: number\n  readOnly?: boolean\n  initialValue?: Array<PortableTextBlock>\n} & (\n  | {\n      schemaDefinition: SchemaDefinition\n      schema?: undefined\n    }\n  | {\n      schemaDefinition?: undefined\n      schema: ArraySchemaType<PortableTextBlock> | ArrayDefinition\n    }\n)\n\n/**\n * @public\n */\nexport type EditorEvent =\n  | PickFromUnion<\n      InternalEditorEvent,\n      'type',\n      | 'annotation.add'\n      | 'annotation.remove'\n      | 'blur'\n      | 'decorator.toggle'\n      | 'focus'\n      | 'insert.block object'\n      | 'insert.inline object'\n      | 'list item.toggle'\n      | 'select'\n      | 'style.toggle'\n      | 'patches'\n      | 'update behaviors'\n      | 'update readOnly'\n      | 'update value'\n    >\n  | CustomBehaviorEvent\n\n/**\n * @public\n */\nexport type Editor = {\n  getSnapshot: () => EditorSnapshot\n  /**\n   * @beta\n   */\n  registerBehavior: (config: {behavior: Behavior}) => () => void\n  send: (event: EditorEvent) => void\n  on: ActorRef<Snapshot<unknown>, EventObject, EditorEmittedEvent>['on']\n  _internal: {\n    editable: EditableAPI\n    editorActor: EditorActor\n    slateEditor: SlateEditor\n  }\n}\n\nexport function createEditor(config: EditorConfig): Editor {\n  const editorActor = createActor(editorMachine, {\n    input: editorConfigToMachineInput(config),\n  })\n  editorActor.start()\n\n  return createEditorFromActor(editorActor)\n}\n\nexport function useCreateEditor(config: EditorConfig): Editor {\n  const editorActor = useActorRef(editorMachine, {\n    input: editorConfigToMachineInput(config),\n  })\n\n  return useMemo(() => createEditorFromActor(editorActor), [editorActor])\n}\n\nfunction editorConfigToMachineInput(config: EditorConfig) {\n  return {\n    behaviors: config.behaviors,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema: config.schemaDefinition\n      ? compileSchemaDefinition(config.schemaDefinition)\n      : createEditorSchema(\n          config.schema.hasOwnProperty('jsonType')\n            ? config.schema\n            : compileType(config.schema),\n        ),\n    value: config.initialValue,\n  } as const\n}\n\nfunction createEditorFromActor(editorActor: EditorActor): Editor {\n  const slateEditor = createSlateEditor({editorActor})\n  const editable = createEditableAPI(slateEditor.instance, editorActor)\n\n  return {\n    getSnapshot: () =>\n      getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor.instance,\n      }),\n    registerBehavior: (config) => {\n      editorActor.send({\n        type: 'add behavior',\n        behavior: config.behavior,\n      })\n\n      return () => {\n        editorActor.send({\n          type: 'remove behavior',\n          behavior: config.behavior,\n        })\n      }\n    },\n    send: (event) => {\n      editorActor.send(event)\n    },\n    on: (event, listener) =>\n      editorActor.on(\n        event,\n        // @ts-expect-error\n        listener,\n      ),\n    _internal: {\n      editable,\n      editorActor,\n      slateEditor,\n    },\n  }\n}\n","import {createContext} from 'react'\nimport type {EditorActor} from './editor-machine'\n\nexport const EditorActorContext = createContext<EditorActor>({} as EditorActor)\n","import {\n  createContext,\n  startTransition,\n  useContext,\n  useEffect,\n  useState,\n} from 'react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EditorSelection} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\n/**\n * A React context for sharing the editor selection.\n */\nconst PortableTextEditorSelectionContext =\n  createContext<EditorSelection | null>(null)\n\n/**\n * @deprecated Use `useEditorSelector` to get the current editor selection.\n * @public\n * Get the current editor selection from the React context.\n */\nexport const usePortableTextEditorSelection = (): EditorSelection => {\n  const selection = useContext(PortableTextEditorSelectionContext)\n\n  if (selection === undefined) {\n    throw new Error(\n      `The \\`usePortableTextEditorSelection\\` hook must be used inside the <PortableTextEditor> component's context.`,\n    )\n  }\n  return selection\n}\nconst debug = debugWithName('component:PortableTextEditor:SelectionProvider')\nconst debugVerbose = debug.enabled && false\n\n/**\n * @internal\n */\nexport function PortableTextEditorSelectionProvider(\n  props: React.PropsWithChildren<{\n    editorActor: EditorActor\n  }>,\n) {\n  const [selection, setSelection] = useState<EditorSelection>(null)\n\n  // Subscribe to, and handle changes from the editor\n  useEffect(() => {\n    debug('Subscribing to selection changes')\n    const subscription = props.editorActor.on('selection', (event) => {\n      // Set the selection state in a transition, we don't need the state immediately.\n      startTransition(() => {\n        if (debugVerbose) debug('Setting selection')\n        setSelection(event.selection)\n      })\n    })\n\n    return () => {\n      debug('Unsubscribing to selection changes')\n      subscription.unsubscribe()\n    }\n  }, [props.editorActor])\n\n  return (\n    <PortableTextEditorSelectionContext.Provider value={selection}>\n      {props.children}\n    </PortableTextEditorSelectionContext.Provider>\n  )\n}\n","import type {\n  ArrayDefinition,\n  ArraySchemaType,\n  Path,\n  PortableTextBlock,\n  PortableTextChild,\n  PortableTextObject,\n} from '@sanity/types'\nimport {\n  Component,\n  useEffect,\n  type MutableRefObject,\n  type PropsWithChildren,\n} from 'react'\nimport {Subject} from 'rxjs'\nimport {Slate} from 'slate-react'\nimport {useEffectEvent} from 'use-effect-event'\nimport {debugWithName} from '../internal-utils/debug'\nimport {compileType} from '../internal-utils/schema'\nimport type {\n  EditableAPI,\n  EditableAPIDeleteOptions,\n  EditorChange,\n  EditorChanges,\n  EditorSelection,\n  PatchObservable,\n  PortableTextMemberSchemaTypes,\n} from '../types/editor'\nimport {Synchronizer} from './components/Synchronizer'\nimport {createEditor, type Editor} from './create-editor'\nimport {createEditorSchema} from './create-editor-schema'\nimport {EditorActorContext} from './editor-actor-context'\nimport type {EditorActor} from './editor-machine'\nimport {PortableTextEditorContext} from './hooks/usePortableTextEditor'\nimport {PortableTextEditorSelectionProvider} from './hooks/usePortableTextEditorSelection'\nimport {defaultKeyGenerator} from './key-generator'\nimport type {AddedAnnotationPaths} from './plugins/createWithEditableAPI'\n\nconst debug = debugWithName('component:PortableTextEditor')\n\n/**\n * Props for the PortableTextEditor component\n *\n * @public\n * @deprecated Use `EditorProvider` instead\n */\nexport type PortableTextEditorProps<\n  TEditor extends Editor | undefined = undefined,\n> = PropsWithChildren<\n  TEditor extends Editor\n    ? {\n        /**\n         * @alpha\n         */\n        editor: TEditor\n      }\n    : {\n        editor?: undefined\n\n        /**\n         * Function that gets called when the editor changes the value\n         */\n        onChange: (change: EditorChange) => void\n\n        /**\n         * Schema type for the portable text field\n         */\n        schemaType: ArraySchemaType<PortableTextBlock> | ArrayDefinition\n\n        /**\n         * Maximum number of blocks to allow within the editor\n         */\n        maxBlocks?: number | string\n\n        /**\n         * Function used to generate keys for array items (`_key`)\n         */\n        keyGenerator?: () => string\n\n        /**\n         * Observable of local and remote patches for the edited value.\n         */\n        patches$?: PatchObservable\n\n        /**\n         * Backward compatibility (renamed to patches$).\n         */\n        incomingPatches$?: PatchObservable\n\n        /**\n         * Whether or not the editor should be in read-only mode\n         */\n        readOnly?: boolean\n\n        /**\n         * The current value of the portable text field\n         */\n        value?: PortableTextBlock[]\n\n        /**\n         * A ref to the editor instance\n         */\n        editorRef?: MutableRefObject<PortableTextEditor | null>\n      }\n>\n\n/**\n * The main Portable Text Editor component.\n * @public\n * @deprecated Use `EditorProvider` instead\n */\nexport class PortableTextEditor extends Component<\n  PortableTextEditorProps<Editor | undefined>\n> {\n  public static displayName = 'PortableTextEditor'\n  /**\n   * An observable of all the editor changes.\n   */\n  public change$: EditorChanges = new Subject()\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  public schemaTypes: PortableTextMemberSchemaTypes\n  /**\n   * The editor instance\n   */\n  private editor: Editor\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  private editable: EditableAPI\n\n  constructor(props: PortableTextEditorProps) {\n    super(props)\n\n    if (props.editor) {\n      this.editor = props.editor as Editor\n    } else {\n      this.editor = createEditor({\n        keyGenerator: props.keyGenerator ?? defaultKeyGenerator,\n        schema: props.schemaType,\n        initialValue: props.value,\n        maxBlocks:\n          props.maxBlocks === undefined\n            ? undefined\n            : Number.parseInt(props.maxBlocks.toString(), 10),\n        readOnly: props.readOnly,\n      })\n    }\n\n    this.schemaTypes =\n      this.editor._internal.editorActor.getSnapshot().context.schema\n    this.editable = this.editor._internal.editable\n  }\n\n  componentDidUpdate(prevProps: PortableTextEditorProps) {\n    // Set up the schema type lookup table again if the source schema type changes\n    if (\n      !this.props.editor &&\n      !prevProps.editor &&\n      this.props.schemaType !== prevProps.schemaType\n    ) {\n      this.schemaTypes = createEditorSchema(\n        this.props.schemaType.hasOwnProperty('jsonType')\n          ? this.props.schemaType\n          : compileType(this.props.schemaType),\n      )\n\n      this.editor._internal.editorActor.send({\n        type: 'update schema',\n        schema: this.schemaTypes,\n      })\n    }\n\n    if (!this.props.editor && !prevProps.editor) {\n      if (this.props.readOnly !== prevProps.readOnly) {\n        this.editor._internal.editorActor.send({\n          type: 'update readOnly',\n          readOnly: this.props.readOnly ?? false,\n        })\n      }\n\n      if (this.props.maxBlocks !== prevProps.maxBlocks) {\n        this.editor._internal.editorActor.send({\n          type: 'update maxBlocks',\n          maxBlocks:\n            this.props.maxBlocks === undefined\n              ? undefined\n              : Number.parseInt(this.props.maxBlocks.toString(), 10),\n        })\n      }\n\n      if (this.props.value !== prevProps.value) {\n        this.editor._internal.editorActor.send({\n          type: 'update value',\n          value: this.props.value,\n        })\n      }\n\n      if (\n        this.props.editorRef !== prevProps.editorRef &&\n        this.props.editorRef\n      ) {\n        this.props.editorRef.current = this\n      }\n    }\n  }\n\n  public setEditable = (editable: EditableAPI) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable,\n    }\n  }\n\n  render() {\n    const legacyPatches = !this.props.editor\n      ? (this.props.incomingPatches$ ?? this.props.patches$)\n      : undefined\n\n    return (\n      <>\n        {legacyPatches ? (\n          <RoutePatchesObservableToEditorActor\n            editorActor={this.editor._internal.editorActor}\n            patches$={legacyPatches}\n          />\n        ) : null}\n        <RouteEventsToChanges\n          editorActor={this.editor._internal.editorActor}\n          onChange={(change) => {\n            if (!this.props.editor) {\n              this.props.onChange(change)\n            }\n            /**\n             * For backwards compatibility, we relay all changes to the\n             * `change$` Subject as well.\n             */\n            this.change$.next(change)\n          }}\n        />\n        <Synchronizer\n          editorActor={this.editor._internal.editorActor}\n          slateEditor={this.editor._internal.slateEditor.instance}\n        />\n        <EditorActorContext.Provider value={this.editor._internal.editorActor}>\n          <Slate\n            editor={this.editor._internal.slateEditor.instance}\n            initialValue={this.editor._internal.slateEditor.initialValue}\n          >\n            <PortableTextEditorContext.Provider value={this}>\n              <PortableTextEditorSelectionProvider\n                editorActor={this.editor._internal.editorActor}\n              >\n                {this.props.children}\n              </PortableTextEditorSelectionProvider>\n            </PortableTextEditorContext.Provider>\n          </Slate>\n        </EditorActorContext.Provider>\n      </>\n    )\n  }\n\n  // Static API methods\n  static activeAnnotations = (\n    editor: PortableTextEditor,\n  ): PortableTextObject[] => {\n    return editor && editor.editable ? editor.editable.activeAnnotations() : []\n  }\n  static isAnnotationActive = (\n    editor: PortableTextEditor,\n    annotationType: PortableTextObject['_type'],\n  ): boolean => {\n    return editor && editor.editable\n      ? editor.editable.isAnnotationActive(annotationType)\n      : false\n  }\n  static addAnnotation = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): AddedAnnotationPaths | undefined =>\n    editor.editable?.addAnnotation(type, value)\n  static blur = (editor: PortableTextEditor): void => {\n    debug('Host blurred')\n    editor.editable?.blur()\n  }\n  static delete = (\n    editor: PortableTextEditor,\n    selection: EditorSelection,\n    options?: EditableAPIDeleteOptions,\n  ) => editor.editable?.delete(selection, options)\n  static findDOMNode = (\n    editor: PortableTextEditor,\n    element: PortableTextBlock | PortableTextChild,\n  ) => {\n    return editor.editable?.findDOMNode(element)\n  }\n  static findByPath = (editor: PortableTextEditor, path: Path) => {\n    return editor.editable?.findByPath(path) || []\n  }\n  static focus = (editor: PortableTextEditor): void => {\n    debug('Host requesting focus')\n    editor.editable?.focus()\n  }\n  static focusBlock = (editor: PortableTextEditor) => {\n    return editor.editable?.focusBlock()\n  }\n  static focusChild = (\n    editor: PortableTextEditor,\n  ): PortableTextChild | undefined => {\n    return editor.editable?.focusChild()\n  }\n  static getSelection = (editor: PortableTextEditor) => {\n    return editor.editable ? editor.editable.getSelection() : null\n  }\n  static getValue = (editor: PortableTextEditor) => {\n    return editor.editable?.getValue()\n  }\n  static hasBlockStyle = (editor: PortableTextEditor, blockStyle: string) => {\n    return editor.editable?.hasBlockStyle(blockStyle)\n  }\n  static hasListStyle = (editor: PortableTextEditor, listStyle: string) => {\n    return editor.editable?.hasListStyle(listStyle)\n  }\n  static isCollapsedSelection = (editor: PortableTextEditor) =>\n    editor.editable?.isCollapsedSelection()\n  static isExpandedSelection = (editor: PortableTextEditor) =>\n    editor.editable?.isExpandedSelection()\n  static isMarkActive = (editor: PortableTextEditor, mark: string) =>\n    editor.editable?.isMarkActive(mark)\n  static insertChild = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): Path | undefined => {\n    debug(`Host inserting child`)\n    return editor.editable?.insertChild(type, value)\n  }\n  static insertBlock = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n    value?: {[prop: string]: unknown},\n  ): Path | undefined => {\n    return editor.editable?.insertBlock(type, value)\n  }\n  static insertBreak = (editor: PortableTextEditor): void => {\n    return editor.editable?.insertBreak()\n  }\n  static isVoid = (\n    editor: PortableTextEditor,\n    element: PortableTextBlock | PortableTextChild,\n  ) => {\n    return editor.editable?.isVoid(element)\n  }\n  static isObjectPath = (_editor: PortableTextEditor, path: Path): boolean => {\n    if (!path || !Array.isArray(path)) return false\n    const isChildObjectEditPath = path.length > 3 && path[1] === 'children'\n    const isBlockObjectEditPath = path.length > 1 && path[1] !== 'children'\n    return isBlockObjectEditPath || isChildObjectEditPath\n  }\n  static marks = (editor: PortableTextEditor) => {\n    return editor.editable?.marks()\n  }\n  static select = (\n    editor: PortableTextEditor,\n    selection: EditorSelection | null,\n  ) => {\n    debug(`Host setting selection`, selection)\n    editor.editable?.select(selection)\n  }\n  static removeAnnotation = <TSchemaType extends {name: string}>(\n    editor: PortableTextEditor,\n    type: TSchemaType,\n  ) => editor.editable?.removeAnnotation(type)\n  static toggleBlockStyle = (\n    editor: PortableTextEditor,\n    blockStyle: string,\n  ) => {\n    debug(`Host is toggling block style`)\n    return editor.editable?.toggleBlockStyle(blockStyle)\n  }\n  static toggleList = (editor: PortableTextEditor, listStyle: string): void => {\n    return editor.editable?.toggleList(listStyle)\n  }\n  static toggleMark = (editor: PortableTextEditor, mark: string): void => {\n    debug(`Host toggling mark`, mark)\n    editor.editable?.toggleMark(mark)\n  }\n  static getFragment = (\n    editor: PortableTextEditor,\n  ): PortableTextBlock[] | undefined => {\n    debug(`Host getting fragment`)\n    return editor.editable?.getFragment()\n  }\n  static undo = (editor: PortableTextEditor): void => {\n    debug('Host undoing')\n    editor.editable?.undo()\n  }\n  static redo = (editor: PortableTextEditor): void => {\n    debug('Host redoing')\n    editor.editable?.redo()\n  }\n  static isSelectionsOverlapping = (\n    editor: PortableTextEditor,\n    selectionA: EditorSelection,\n    selectionB: EditorSelection,\n  ) => {\n    return editor.editable?.isSelectionsOverlapping(selectionA, selectionB)\n  }\n}\n\nfunction RoutePatchesObservableToEditorActor(props: {\n  editorActor: EditorActor\n  patches$: PatchObservable\n}) {\n  useEffect(() => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: 'patches',\n        ...payload,\n      })\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [props.editorActor, props.patches$])\n\n  return null\n}\n\nexport function RouteEventsToChanges(props: {\n  editorActor: EditorActor\n  onChange: (change: EditorChange) => void\n}) {\n  // We want to ensure that _when_ `props.onChange` is called, it uses the current value.\n  // But we don't want to have the `useEffect` run setup + teardown + setup every time the prop might change, as that's unnecessary.\n  // So we use our own polyfill that lets us use an upcoming React hook that solves this exact problem.\n  // https://19.react.dev/learn/separating-events-from-effects#declaring-an-effect-event\n  const handleChange = useEffectEvent((change: EditorChange) =>\n    props.onChange(change),\n  )\n\n  useEffect(() => {\n    debug('Subscribing to editor changes')\n    const sub = props.editorActor.on('*', (event) => {\n      switch (event.type) {\n        case 'blurred': {\n          handleChange({type: 'blur', event: event.event})\n          break\n        }\n        case 'patch':\n          handleChange(event)\n          break\n        case 'loading': {\n          handleChange({type: 'loading', isLoading: true})\n          break\n        }\n        case 'done loading': {\n          handleChange({type: 'loading', isLoading: false})\n          break\n        }\n        case 'focused': {\n          handleChange({type: 'focus', event: event.event})\n          break\n        }\n        case 'value changed': {\n          handleChange({type: 'value', value: event.value})\n          break\n        }\n        case 'invalid value': {\n          handleChange({\n            type: 'invalidValue',\n            resolution: event.resolution,\n            value: event.value,\n          })\n          break\n        }\n        case 'error': {\n          handleChange({\n            ...event,\n            level: 'warning',\n          })\n          break\n        }\n        case 'mutation': {\n          handleChange(event)\n          break\n        }\n        case 'ready': {\n          handleChange(event)\n          break\n        }\n        case 'selection': {\n          handleChange(event)\n          break\n        }\n        case 'unset': {\n          handleChange(event)\n          break\n        }\n      }\n    })\n    return () => {\n      debug('Unsubscribing to changes')\n      sub.unsubscribe()\n    }\n  }, [props.editorActor, handleChange])\n\n  return null\n}\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {DefaultAnnotation} from '../nodes/DefaultAnnotation'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blur', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focus', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = (\n                <DefaultAnnotation annotation={annotation}>\n                  <span ref={spanRef}>{returnedChildren}</span>\n                </DefaultAnnotation>\n              )\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import {htmlToBlocks} from '@portabletext/block-tools'\nimport type {PortableTextBlock, PortableTextChild} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {Editor, Range, Transforms, type Descendant, type Node} from 'slate'\nimport {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {validateValue} from '../../internal-utils/validateValue'\nimport {\n  fromSlateValue,\n  isEqualToEmptyEditor,\n  toSlateValue,\n} from '../../internal-utils/values'\nimport type {\n  PortableTextMemberSchemaTypes,\n  PortableTextSlateEditor,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\n\nconst debug = debugWithName('plugin:withInsertData')\n\n/**\n * This plugin handles copy/paste in the editor\n *\n */\nexport function createWithInsertData(\n  editorActor: EditorActor,\n  schemaTypes: PortableTextMemberSchemaTypes,\n) {\n  return function withInsertData(\n    editor: PortableTextSlateEditor,\n  ): PortableTextSlateEditor {\n    const blockTypeName = schemaTypes.block.name\n    const spanTypeName = schemaTypes.span.name\n    const whitespaceOnPasteMode =\n      schemaTypes.block.options.unstable_whitespaceOnPasteMode\n\n    const toPlainText = (blocks: PortableTextBlock[]) => {\n      return blocks\n        .map((block) => {\n          if (editor.isTextBlock(block)) {\n            return block.children\n              .map((child: PortableTextChild) => {\n                if (child._type === spanTypeName) {\n                  return child.text\n                }\n                return `[${\n                  schemaTypes.inlineObjects.find((t) => t.name === child._type)\n                    ?.title || 'Object'\n                }]`\n              })\n              .join('')\n          }\n          return `[${\n            schemaTypes.blockObjects.find((t) => t.name === block._type)\n              ?.title || 'Object'\n          }]`\n        })\n        .join('\\n\\n')\n    }\n\n    editor.setFragmentData = (data: DataTransfer, originEvent) => {\n      const {selection} = editor\n\n      if (!selection) {\n        return\n      }\n\n      const [start, end] = Range.edges(selection)\n      const startVoid = Editor.void(editor, {at: start.path})\n      const endVoid = Editor.void(editor, {at: end.path})\n\n      if (Range.isCollapsed(selection) && !startVoid) {\n        return\n      }\n\n      // Create a fake selection so that we can add a Base64-encoded copy of the\n      // fragment to the HTML, to decode on future pastes.\n      const domRange = ReactEditor.toDOMRange(editor, selection)\n      let contents = domRange.cloneContents()\n      // COMPAT: If the end node is a void node, we need to move the end of the\n      // range from the void node's spacer span, to the end of the void node's\n      // content, since the spacer is before void's content in the DOM.\n      if (endVoid) {\n        const [voidNode] = endVoid\n        const r = domRange.cloneRange()\n        const domNode = ReactEditor.toDOMNode(editor, voidNode)\n        r.setEndAfter(domNode)\n        contents = r.cloneContents()\n      }\n      // Remove any zero-width space spans from the cloned DOM so that they don't\n      // show up elsewhere when pasted.\n      Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(\n        (zw) => {\n          const isNewline = zw.getAttribute('data-slate-zero-width') === 'n'\n          zw.textContent = isNewline ? '\\n' : ''\n        },\n      )\n      // Clean up the clipboard HTML for editor spesific attributes\n      Array.from(contents.querySelectorAll('*')).forEach((elm) => {\n        elm.removeAttribute('contentEditable')\n        elm.removeAttribute('data-slate-inline')\n        elm.removeAttribute('data-slate-leaf')\n        elm.removeAttribute('data-slate-node')\n        elm.removeAttribute('data-slate-spacer')\n        elm.removeAttribute('data-slate-string')\n        elm.removeAttribute('data-slate-zero-width')\n        elm.removeAttribute('draggable')\n        for (const key in elm.attributes) {\n          if (elm.hasAttribute(key)) {\n            elm.removeAttribute(key)\n          }\n        }\n      })\n      const div = contents.ownerDocument.createElement('div')\n      div.appendChild(contents)\n      div.setAttribute('hidden', 'true')\n      contents.ownerDocument.body.appendChild(div)\n      const asHTML = div.innerHTML\n      contents.ownerDocument.body.removeChild(div)\n      const fragment = editor.getFragment()\n      const portableText = fromSlateValue(fragment, blockTypeName)\n\n      const asJSON = JSON.stringify(portableText)\n      const asPlainText = toPlainText(portableText)\n      data.clearData()\n      data.setData('text/plain', asPlainText)\n      data.setData('text/html', asHTML)\n      data.setData('application/json', asJSON)\n      data.setData('application/x-portable-text', asJSON)\n      debug('text', asPlainText)\n      data.setData(\n        'application/x-portable-text-event-origin',\n        originEvent || 'external',\n      )\n      debug('Set fragment data', asJSON, asHTML)\n    }\n\n    editor.insertPortableTextData = (data: DataTransfer): boolean => {\n      if (!editor.selection) {\n        return false\n      }\n      const pText = data.getData('application/x-portable-text')\n      const origin = data.getData('application/x-portable-text-event-origin')\n      debug(`Inserting portable text from ${origin} event`, pText)\n      if (pText) {\n        const parsed = JSON.parse(pText) as PortableTextBlock[]\n        if (Array.isArray(parsed) && parsed.length > 0) {\n          const slateValue = _regenerateKeys(\n            editor,\n            toSlateValue(parsed, {schemaTypes}),\n            editorActor.getSnapshot().context.keyGenerator,\n            spanTypeName,\n            schemaTypes,\n          )\n          // Validate the result\n          const validation = validateValue(\n            parsed,\n            schemaTypes,\n            editorActor.getSnapshot().context.keyGenerator,\n          )\n          // Bail out if it's not valid\n          if (!validation.valid && !validation.resolution?.autoResolve) {\n            const errorDescription = `${validation.resolution?.description}`\n            editorActor.send({\n              type: 'error',\n              name: 'pasteError',\n              description: errorDescription,\n              data: validation,\n            })\n            debug('Invalid insert result', validation)\n            return false\n          }\n          _insertFragment(editor, slateValue, schemaTypes)\n          return true\n        }\n      }\n      return false\n    }\n\n    editor.insertTextOrHTMLData = (data: DataTransfer): boolean => {\n      if (!editor.selection) {\n        debug('No selection, not inserting')\n        return false\n      }\n      const html = data.getData('text/html')\n      const text = data.getData('text/plain')\n\n      if (html || text) {\n        debug('Inserting data', data)\n        let portableText: PortableTextBlock[]\n        let fragment: Node[]\n        let insertedType: string | undefined\n\n        if (html) {\n          portableText = htmlToBlocks(html, schemaTypes.portableText, {\n            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode,\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n          }) as PortableTextBlock[]\n          fragment = toSlateValue(portableText, {schemaTypes})\n          insertedType = 'HTML'\n\n          if (portableText.length === 0) {\n            return false\n          }\n        } else {\n          // plain text\n          const blocks = escapeHtml(text)\n            .split(/\\n{2,}/)\n            .map((line) =>\n              line\n                ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>')}</p>`\n                : '<p></p>',\n            )\n            .join('')\n          const textToHtml = `<html><body>${blocks}</body></html>`\n          portableText = htmlToBlocks(textToHtml, schemaTypes.portableText, {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n          }) as PortableTextBlock[]\n          fragment = toSlateValue(portableText, {\n            schemaTypes,\n          })\n          insertedType = 'text'\n        }\n\n        // Validate the result\n        const validation = validateValue(\n          portableText,\n          schemaTypes,\n          editorActor.getSnapshot().context.keyGenerator,\n        )\n\n        // Bail out if it's not valid\n        if (!validation.valid) {\n          const errorDescription = `Could not validate the resulting portable text to insert.\\n${validation.resolution?.description}\\nTry to insert as plain text (shift-paste) instead.`\n          editorActor.send({\n            type: 'error',\n            name: 'pasteError',\n            description: errorDescription,\n            data: validation,\n          })\n          debug('Invalid insert result', validation)\n          return false\n        }\n        debug(\n          `Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`,\n        )\n        _insertFragment(editor, fragment, schemaTypes)\n        return true\n      }\n      return false\n    }\n\n    editor.insertData = (data: DataTransfer) => {\n      if (!editor.insertPortableTextData(data)) {\n        editor.insertTextOrHTMLData(data)\n      }\n    }\n\n    editor.insertFragmentData = (data: DataTransfer): boolean => {\n      const fragment = data.getData('application/x-portable-text')\n      if (fragment) {\n        const parsed = JSON.parse(fragment)\n        editor.insertFragment(parsed)\n        return true\n      }\n      return false\n    }\n\n    return editor\n  }\n}\n\nconst entityMap: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;',\n}\nfunction escapeHtml(str: string) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s: string) => entityMap[s])\n}\n\n/**\n * Shared helper function to regenerate the keys on a fragment.\n *\n * @internal\n */\nfunction _regenerateKeys(\n  editor: Pick<PortableTextSlateEditor, 'isTextBlock' | 'isTextSpan'>,\n  fragment: Descendant[],\n  keyGenerator: () => string,\n  spanTypeName: string,\n  editorTypes: Pick<PortableTextMemberSchemaTypes, 'annotations'>,\n): Descendant[] {\n  return fragment.map((node) => {\n    const newNode: Descendant = {...node}\n    // Ensure the copy has new keys\n    if (editor.isTextBlock(newNode)) {\n      const annotations = editorTypes.annotations.map((t) => t.name)\n\n      // Ensure that if there are no annotations, we remove the markDefs\n      if (annotations.length === 0) {\n        const {markDefs, ...NewNodeNoDefs} = newNode\n\n        return {...NewNodeNoDefs, _key: keyGenerator()}\n      }\n\n      // Ensure that all annotations are allowed\n      const hasForbiddenAnnotations = (newNode.markDefs || []).some((def) => {\n        return !annotations.includes(def._type)\n      })\n\n      // if they have forbidden annotations, we remove them and keep the rest\n      if (hasForbiddenAnnotations) {\n        const allowedAnnotations = (newNode.markDefs || []).filter((def) => {\n          return annotations.includes(def._type)\n        })\n\n        return {...newNode, markDefs: allowedAnnotations, _key: keyGenerator()}\n      }\n\n      newNode.markDefs = (newNode.markDefs || []).map((def) => {\n        const oldKey = def._key\n        const newKey = keyGenerator()\n        newNode.children = newNode.children.map((child) =>\n          child._type === spanTypeName && editor.isTextSpan(child)\n            ? {\n                ...child,\n                marks:\n                  child.marks && child.marks.includes(oldKey)\n                    ? [...child.marks]\n                        .filter((mark) => mark !== oldKey)\n                        .concat(newKey)\n                    : child.marks,\n              }\n            : child,\n        )\n        return {...def, _key: newKey}\n      })\n    }\n    const nodeWithNewKeys = {...newNode, _key: keyGenerator()}\n    if (editor.isTextBlock(nodeWithNewKeys)) {\n      nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({\n        ...child,\n        _key: keyGenerator(),\n      }))\n    }\n    return nodeWithNewKeys as Descendant\n  })\n}\n\n/**\n * Shared helper function to insert the final fragment into the editor\n *\n * @internal\n */\nfunction _insertFragment(\n  editor: PortableTextSlateEditor,\n  fragment: Descendant[],\n  schemaTypes: PortableTextMemberSchemaTypes,\n) {\n  editor.withoutNormalizing(() => {\n    if (!editor.selection) {\n      return\n    }\n    // Ensure that markDefs for any annotations inside this fragment are copied over to the focused text block.\n    const [focusBlock, focusPath] = Editor.node(editor, editor.selection, {\n      depth: 1,\n    })\n    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n      const {markDefs} = focusBlock\n      debug(\n        'Mixing markDefs of focusBlock and fragments[0] block',\n        markDefs,\n        fragment[0].markDefs,\n      )\n      if (!isEqual(markDefs, fragment[0].markDefs)) {\n        Transforms.setNodes(\n          editor,\n          {\n            markDefs: uniq([\n              ...(fragment[0].markDefs || []),\n              ...(markDefs || []),\n            ]),\n          },\n          {at: focusPath, mode: 'lowest', voids: false},\n        )\n      }\n    }\n\n    const isPasteToEmptyEditor = isEqualToEmptyEditor(\n      editor.children,\n      schemaTypes,\n    )\n\n    if (isPasteToEmptyEditor) {\n      // Special case for pasting directly into an empty editor (a placeholder block).\n      // When pasting content starting with multiple empty blocks,\n      // `editor.insertFragment` can potentially duplicate the keys of\n      // the placeholder block because of operations that happen\n      // inside `editor.insertFragment` (involves an `insert_node` operation).\n      // However by splitting the placeholder block first in this situation we are good.\n      Transforms.splitNodes(editor, {at: [0, 0]})\n      editor.insertFragment(fragment)\n      Transforms.removeNodes(editor, {at: [0]})\n    } else {\n      // All other inserts\n      editor.insertFragment(fragment)\n    }\n  })\n\n  editor.onChange()\n}\n\n/**\n * functions we don't want to export but want to test\n * @internal\n */\nexport const exportedForTesting = {\n  _regenerateKeys,\n}\n","import type {BaseEditor, Operation} from 'slate'\nimport type {ReactEditor} from 'slate-react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\n// React Compiler considers `slateEditor` as immutable, and opts-out if we do this inline in a useEffect, doing it in a function moves it out of the scope, and opts-in again for the rest of the component.\nexport function withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations,\n}: {\n  editorActor: EditorActor\n  slateEditor: BaseEditor & ReactEditor & PortableTextSlateEditor\n  syncRangeDecorations: (operation?: Operation) => void\n}) {\n  const originalApply = slateEditor.apply\n\n  slateEditor.apply = (op: Operation) => {\n    originalApply(op)\n\n    if (\n      !editorActor.getSnapshot().matches({'edit mode': 'read only'}) &&\n      op.type !== 'set_selection'\n    ) {\n      syncRangeDecorations(op)\n    }\n  }\n\n  return () => {\n    slateEditor.apply = originalApply\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {isEqual, noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {\n  Editor,\n  Node,\n  Path,\n  Range as SlateRange,\n  Transforms,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n  type Text,\n} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {debugWithName} from '../internal-utils/debug'\nimport {\n  moveRangeByOperation,\n  toPortableTextRange,\n  toSlateRange,\n} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {\n  fromSlateValue,\n  isEqualToEmptyEditor,\n  toSlateValue,\n} from '../internal-utils/values'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport type {SlateTextBlock, VoidElement} from '../types/slate'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {createWithInsertData} from './plugins/createWithInsertData'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {withSyncRangeDecorations} from './withSyncRangeDecorations'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\ninterface BaseRangeWithDecoration extends BaseRange {\n  rangeDecoration: RangeDecoration\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EventProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n  const [rangeDecorationState, setRangeDecorationsState] = useState<\n    BaseRangeWithDecoration[]\n  >([])\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const rangeDecorationsRef = useRef(rangeDecorations)\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    const withInsertData = createWithInsertData(editorActor, schemaTypes)\n\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return withInsertData(slateEditor)\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withInsertData(withHotKeys(slateEditor))\n  }, [\n    editorActor,\n    hotkeys,\n    portableTextEditor,\n    readOnly,\n    schemaTypes,\n    slateEditor,\n  ])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  const syncRangeDecorations = useCallback(\n    (operation?: Operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges: BaseRangeWithDecoration[] = []\n        rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(\n            rangeDecorationItem.selection,\n            slateEditor,\n          )\n          if (!SlateRange.isRange(slateRange)) {\n            if (rangeDecorationItem.onMoved) {\n              rangeDecorationItem.onMoved({\n                newSelection: null,\n                rangeDecoration: rangeDecorationItem,\n                origin: 'local',\n              })\n            }\n            return\n          }\n          let newRange: BaseRange | null | undefined\n          if (operation) {\n            newRange = moveRangeByOperation(slateRange, operation)\n            if (\n              (newRange && newRange !== slateRange) ||\n              (newRange === null && slateRange)\n            ) {\n              const value = PortableTextEditor.getValue(portableTextEditor)\n              const newRangeSelection = toPortableTextRange(\n                value,\n                newRange,\n                schemaTypes,\n              )\n              if (rangeDecorationItem.onMoved) {\n                rangeDecorationItem.onMoved({\n                  newSelection: newRangeSelection,\n                  rangeDecoration: rangeDecorationItem,\n                  origin: 'local',\n                })\n              }\n            }\n          }\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            newSlateRanges.push({\n              ...(newRange || slateRange),\n              rangeDecoration: rangeDecorationItem,\n            })\n          }\n        })\n        if (newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges)\n          return\n        }\n      }\n      setRangeDecorationsState((rangeDecorationState) => {\n        // If there's state then we want to reset\n        if (rangeDecorationState.length > 0) {\n          return []\n        }\n        // Otherwise we no-op, React will skip a state update if what we return has reference equality to the previous state\n        return rangeDecorationState\n      })\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor],\n  )\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      syncRangeDecorations()\n      restoreSelectionFromProps()\n    })\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(false)\n  useEffect(() => {\n    if (!syncedRangeDecorations) {\n      // We only want this to run once, on mount\n      setSyncedRangeDecorations(true)\n      syncRangeDecorations()\n    }\n  }, [syncRangeDecorations, syncedRangeDecorations])\n\n  useEffect(() => {\n    if (!isEqual(rangeDecorations, rangeDecorationsRef.current)) {\n      syncRangeDecorations()\n    }\n    rangeDecorationsRef.current = rangeDecorations\n  }, [rangeDecorations, syncRangeDecorations])\n\n  // Sync range decorations after an operation is applied\n  useEffect(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations,\n    })\n    return () => teardown()\n  }, [editorActor, slateEditor, syncRangeDecorations])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'copy',\n            data: event.nativeEvent.clipboardData,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = toPortableTextRange(\n        value,\n        slateEditor.selection,\n        schemaTypes,\n      )\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              slateEditor.insertData(event.clipboardData)\n            } else if (result.insert) {\n              slateEditor.insertFragment(\n                toSlateValue(result.insert as PortableTextBlock[], {\n                  schemaTypes,\n                }),\n              )\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.error(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'paste',\n            data: event.nativeEvent.clipboardData,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      const focusBlockPath = slateEditor.selection\n        ? slateEditor.selection.focus.path.slice(0, 1)\n        : undefined\n      const focusBlock = focusBlockPath\n        ? (Node.descendant(slateEditor, focusBlockPath) as\n            | SlateTextBlock\n            | VoidElement)\n        : undefined\n      const [_, lastNodePath] = Node.last(slateEditor, [])\n      const lastBlockPath = lastNodePath.slice(0, 1)\n      const lastNodeFocused = focusBlockPath\n        ? Path.equals(lastBlockPath, focusBlockPath)\n        : false\n      const lastBlockIsVoid = focusBlock\n        ? !slateEditor.isTextBlock(focusBlock)\n        : false\n      const collapsedSelection =\n        slateEditor.selection && SlateRange.isCollapsed(slateEditor.selection)\n\n      if (collapsedSelection && lastNodeFocused && lastBlockIsVoid) {\n        Transforms.insertNodes(\n          slateEditor,\n          slateEditor.pteCreateTextBlock({decorators: []}),\n        )\n        slateEditor.onChange()\n      }\n    },\n    [onClick, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'key.down',\n            keyboardEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'key.up',\n            keyboardEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  const decorate: (entry: NodeEntry) => BaseRange[] = useCallback(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0,\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0,\n            },\n            placeholder: true,\n          },\n        ]\n      }\n      // Editor node has a path length of 0 (should never be decorated)\n      if (path.length === 0) {\n        return []\n      }\n      const result = rangeDecorationState.filter((item) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (SlateRange.isCollapsed(item)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          if (path.length !== 2) {\n            return false\n          }\n          return (\n            Path.equals(item.focus.path, path) &&\n            Path.equals(item.anchor.path, path)\n          )\n        }\n        // Include decorations that either include or intersects with this path\n        return (\n          SlateRange.intersection(item, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || SlateRange.includes(item, path)\n        )\n      })\n      if (result.length > 0) {\n        return result\n      }\n      return []\n    },\n    [slateEditor, schemaTypes, rangeDecorationState],\n  )\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  if (!portableTextEditor) {\n    return null\n  }\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import React, {useMemo} from 'react'\nimport {Slate} from 'slate-react'\nimport {Synchronizer} from './components/Synchronizer'\nimport {useCreateEditor, type Editor, type EditorConfig} from './create-editor'\nimport {EditorActorContext} from './editor-actor-context'\nimport {PortableTextEditorContext} from './hooks/usePortableTextEditor'\nimport {PortableTextEditorSelectionProvider} from './hooks/usePortableTextEditorSelection'\nimport {\n  PortableTextEditor,\n  RouteEventsToChanges,\n  type PortableTextEditorProps,\n} from './PortableTextEditor'\n\nconst EditorContext = React.createContext<Editor | undefined>(undefined)\n\n/**\n * @public\n */\nexport type EditorProviderProps = {\n  initialConfig: EditorConfig\n  children?: React.ReactNode\n}\n\n/**\n * @public\n * The EditorProvider component is used to set up the editor context and configure the Portable Text Editor.\n * @example\n * ```tsx\n * import {EditorProvider} from '@portabletext/editor'\n *\n * function App() {\n *  return (\n *    <EditorProvider initialConfig={{ ... }} >\n *      ...\n *    </EditorProvider>\n *  )\n * }\n *\n * ```\n * @group Components\n */\nexport function EditorProvider(props: EditorProviderProps) {\n  const editor = useCreateEditor(props.initialConfig)\n  const editorActor = editor._internal.editorActor\n  const slateEditor = editor._internal.slateEditor\n  const portableTextEditor = useMemo(\n    () =>\n      new PortableTextEditor({\n        editor,\n      } as unknown as PortableTextEditorProps),\n    [editor],\n  )\n\n  return (\n    <EditorContext.Provider value={editor}>\n      <RouteEventsToChanges\n        editorActor={editorActor}\n        onChange={(change) => {\n          portableTextEditor.change$.next(change)\n        }}\n      />\n      <Synchronizer\n        editorActor={editorActor}\n        slateEditor={slateEditor.instance}\n      />\n      <EditorActorContext.Provider value={editorActor}>\n        <Slate\n          editor={slateEditor.instance}\n          initialValue={slateEditor.initialValue}\n        >\n          <PortableTextEditorContext.Provider value={portableTextEditor}>\n            <PortableTextEditorSelectionProvider editorActor={editorActor}>\n              {props.children}\n            </PortableTextEditorSelectionProvider>\n          </PortableTextEditorContext.Provider>\n        </Slate>\n      </EditorActorContext.Provider>\n    </EditorContext.Provider>\n  )\n}\n\n/**\n * @public\n * Get the current editor context from the `EditorProvider`.\n * Must be used inside the `EditorProvider` component.\n * @returns The current editor object.\n * @example\n * ```tsx\n * import { useEditor } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  const editor = useEditor()\n * }\n * ```\n * @group Hooks\n */\nexport function useEditor() {\n  const editor = React.useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error('No Editor set. Use EditorProvider to set one.')\n  }\n\n  return editor\n}\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor-machine'\nimport {useEditor} from './editor-provider'\n\n/**\n * @public\n * Listen for events emitted by the editor. Must be used inside `EditorProvider`. Events available include:\n *  - 'blurred'\n *  - 'done loading'\n *  - 'editable'\n *  - 'error'\n *  - 'focused'\n *  - 'invalid value'\n *  - 'loading'\n *  - 'mutation'\n *  - 'patch'\n *  - 'read only'\n *  - 'ready'\n *  - 'selection'\n *  - 'value changed'\n *\n * @example\n * Listen and log events.\n * ```tsx\n * import {EditorEventListener, EditorProvider} from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *  <EditorProvider>\n *   <EditorEventListener\n *    on={(event) => {\n *     console.log(event)\n *    }\n *   } />\n *   { ... }\n * </EditorProvider>\n *  )\n * }\n * ```\n * @example\n * Handle events when there is a mutation.\n * ```tsx\n * <EditorEventListener\n *  on={(event) => {\n *    if (event.type === 'mutation') {\n *      console.log('Value changed:', event.snapshot)\n *    }\n *  }}\n * />\n * ```\n * @group Components\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor, on])\n\n  return null\n}\n"],"names":["createEditorSchema","portableTextType","Error","blockType","of","find","findBlockType","childrenField","fields","field","name","ofType","type","spanType","memberType","inlineObjectTypes","filter","blockObjectTypes","styles","resolveEnabledStyles","decorators","resolveEnabledDecorators","lists","resolveEnabledListItems","block","span","portableText","inlineObjects","blockObjects","annotations","styleField","btField","textStyles","options","list","style","value","length","listField","listItems","defineSchema","definition","compileSchemaDefinition","map","blockObject","defineType","title","undefined","inlineObject","portableTextSchema","defineField","marks","decorator","startCase","annotation","schema","SanitySchema","compile","types","get","pteSchema","rootName","debug","debugWithName","namespace","enabled","createKeyedPath","point","blockPath","path","keyedBlockPath","_key","_type","keyedChildPath","childPath","slice","child","Array","isArray","children","toSlatePath","editor","from","Editor","nodes","at","match","n","isKeySegment","Element","isElement","isVoid","childIndex","findIndex","isEqual","concat","toPortableTextRange","range","anchor","focus","anchorPath","offset","focusPath","backward","Boolean","Range","isRange","isBackward","toSlateRange","selection","moveRangeByOperation","operation","Point","transform","equals","normalizePoint","newPath","newOffset","blockKey","childKey","blk","push","cld","text","normalizeSelection","newAnchor","newFocus","EMPTY_MARKDEFS","VOID_CHILD_KEY","keepObjectEquality","object","keyMap","toSlateValue","schemaTypes","rest","voidChildren","textBlock","hasInlines","hasMissingStyle","hasMissingMarkDefs","markDefs","hasMissingChildren","cType","cKey","cRest","__inline","fromSlateValue","textBlockType","_cType","v","k","t","_i","_c","blockValue","isEqualToEmptyEditor","Text","isText","join","IS_PROCESSING_REMOTE_CHANGES","WeakMap","IS_DRAGGING","IS_DRAGGING_BLOCK_ELEMENT","IS_DRAGGING_ELEMENT_TARGET","IS_DRAGGING_BLOCK_TARGET_POSITION","KEY_TO_SLATE_ELEMENT","KEY_TO_VALUE_ELEMENT","SLATE_TO_PORTABLE_TEXT_RANGE","DefaultObject","props","$","t0","Symbol","for","userSelect","t1","displayName","DraggableBlock","element","readOnly","blockRef","useSlateStatic","dragGhostRef","useRef","isDragOver","setIsDragOver","useState","t2","t3","t4","isInline","blockElement","setBlockElement","t5","t6","current","ReactEditor","toDOMNode","useEffect","t7","event","isMyDragOver","preventDefault","dataTransfer","dropEffect","set","elementRect","getBoundingClientRect","top","height","Y","pageY","loc","Math","abs","handleDragOver","t8","handleDragLeave","t9","event_0","targetBlock","stopPropagation","delete","document","body","removeChild","dragPosition","targetPath","findPath","myPath","isBefore","Path","originalPath","JSON","stringify","originalPath_0","Transforms","moveNodes","to","onChange","handleDragEnd","t10","event_1","handleDrop","t11","event_2","target","HTMLElement","opacity","handleDrag","t12","event_3","setData","effectAllowed","dragGhost","cloneNode","customGhost","querySelector","setAttribute","position","left","boxSizing","appendChild","rect","x","clientX","y","clientY","width","setDragImage","handleDragStart","t13","isDraggingOverFirstBlock","t14","isDraggingOverLastBlock","dragPosition_0","isDraggingOverTop","isDraggingOverBottom","t15","t16","borderBottom","zIndex","dropIndicator","t17","t18","t19","EMPTY_ANNOTATIONS","inlineBlockStyle","display","attributes","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","selected","useSelected","inlineBlockObjectRef","focused","isCollapsed","useMemo","renderedBlock","className","node","depth","schemaType","SlateElement","elmPath","debugRenders","ObjectNode","editorElementRef","isListItem","blockStyleType","item","level","listItem","isListBlock","listType","renderProps","Object","defineProperty","enumerable","warn","propsOrDefaultRendered","renderedBlockFromProps","_props","PortableTextEditorContext","createContext","usePortableTextEditor","useContext","DefaultAnnotation","alert","handleClick","color","compileType","rawType","Schema","FLUSH_PATCHES_THROTTLED_MS","process","env","NODE_ENV","mutationMachine","setup","context","events","input","emitted","actions","emit","patches","pendingPatches","snapshot","slateEditor","assign","patch","guards","slate is normalizing","isNormalizing","createMachine","id","initial","states","on","after","guard","reenter","validateValue","keyGenerator","resolution","valid","validChildTypes","validBlockTypes","unset","description","action","i18n","some","index","isPlainObject","String","values","includes","currentBlockTypeName","key","expectedTypeName","isPortableTextTextBlock","typeName","newSpan","autoResolve","setIfMissing","insert","allUsedMarks","uniq","flatten","unusedMarkDefs","def","markDefKey","m","toString","orphanedMarks","mark","dec","spanChildren","orphaned","cMrk","cIndex","newChild","childType","withRemoteChanges","fn","prev","isChangingRemotely","PATCHING","withoutPatching","isPatching","cloneDiff","diff2","IS_UDOING","IS_REDOING","withUndoing","isUndoing","setIsUndoing","withRedoing","isRedoing","setIsRedoing","SAVING","REMOTE_PATCHES","UNDO_STEP_LIMIT","isSaving","state","getRemotePatches","createWithUndoRedo","editorActor","blockSchemaType","previousSnapshot","remotePatches","subscriptions","sub","reset","forEach","origin","history","undos","redos","splice","time","Date","unsubscribe","apply","op","getSnapshot","matches","operations","step","lastOp","overwrite","shouldOverwrite","save","merge","shouldMerge","newStep","createSelectOperation","timestamp","shift","shouldClear","undo","otherPatches","transformedOperations","transformOperation","reversedOperations","Operation","inverse","reverse","withoutNormalizing","withoutSaving","normalize","err","deselect","pop","redo","transformedOperation","insertBlockIndex","items","adjustBlockPath","unsetBlockIndex","operationTargetBlock","findOperationTargetBlock","parsePatch","diffPatch","adjustOffsetBy","changedOffset","utf8Start1","diffs","diff","diffType","DIFF_INSERT","DIFF_DELETE","DIFF_EQUAL","every","dType","currentFocus","properties","currentAnchor","newProperties","blockIndex","syncValueCallback","sendBack","streamBlocks","syncValueLogic","fromCallback","syncMachine","initialValueSynced","assertEvent","pendingValue","previousValue","initial value synced","is busy","isProcessingLocalChanges","value changed while syncing","pending value equals previous value","actors","always","entry","idle","busy","syncing","invoke","src","updateValue","isChanged","isValid","hadSelection","childrenLength","_","removeNodes","insertNodes","pteCreateTextBlock","select","slateValueFromProps","Promise","resolve","i","currentBlock","currentBlockIndex","getBlocks","slateValue","blockChanged","blockValid","syncBlock","error","setTimeout","oldBlock","hasChanges","validationValue","validation","console","_updateBlock","_replaceBlock","currentSelection","selectionFocusOnBlock","setNodes","isTextBlock","oldBlockChildrenLength","currentBlockChild","currentBlockChildIndex","oldBlockChild","isChildChanged","isTextChanged","isSpanNode","insertText","voids","Synchronizer","useSelector","_temp","_temp2","syncActorRef","useActorRef","mutationActorRef","subscription","send","subscription_0","s_0","s","createOperationToPatches","textBlockName","insertTextPatch","beforeValue","textChild","isTextSpan","prevBlock","prevChild","prevText","diffMatchPatch","removeTextPatch","beforeBlock","prevTextChild","setNodePatch","setNode","omitBy","isUndefined","keys","keyName","val","indexOf","insertNodePatch","targetKey","splitNodePatch","splitBlock","targetValue","splitSpan","targetSpans","removeNodePatch","spanToRemove","mergeNodePatch","updatedBlock","newBlock","updatedSpan","removedSpan","moveNodePatch","targetChild","childToInsert","IS_APPLYING_BEHAVIOR_ACTIONS","withApplyingBehaviorActions","isApplyingBehaviorActions","createWithEventListeners","maxBlocks","behaviorEvent","placement","deleteBackward","deleteForward","insertBreak","insertSoftBreak","unit","defaultActionCallback","location","createWithMaxBlocks","rows","createWithObjectKeys","normalizeNode","isEditor","Node","debugVerbose","createApplyPatch","changed","insertPatch","unsetPatch","setPatch","findBlockAndChildFromPath","newValue","diffMatchPatchApplyPatches","allowExceedingIndices","cleanupEfficiency","makeDiff","debugState","targetBlockPath","targetChildPath","blocksToInsert","targetBlockIndex","normalizedIdx","childrenToInsert","targetChildIndex","childInsertPath","newText","nextRest","prevChildren","prevRest","c","newVal","applyAll","previousSelection","_child","isKeyedSegment","segment","stateName","findBlockFromPath","isMatch","createWithPatches","patchFunctions","previousChildren","applyPatch","bufferedPatches","handleBufferedRemotePatches","handlePatches","p","editorWasEmpty","editorIsEmpty","createWithPlaceholderBlock","nextPath","next","insertNode","createWithPortableTextBlockStyle","defaultStyle","nodeEntry","SlateText","isPortableTextSpan","isPortableTextBlock","getPreviousSpan","spanPath","previousSpan","getNextSpan","nextSpan","isAfter","createWithPortableTextMarkModel","nextNode","mergeNodes","parent","orphanedAnnotations","markDefKeys","Set","newMarkDefs","markDef","has","add","previousSelectionIsCollapsed","newSelectionIsCollapsed","focusSpan","mode","newFocusSpan","movedToNextSpan","movedToPreviousSpan","_block","previousSpanAnnotations","nextSpanAnnotations","annotationsEnding","atTheEndOfAnnotation","annotationsStarting","atTheStartOfAnnotation","nextSpanDecorators","collapsedSelection","marksWithoutAnnotations","spanHasAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","previousSpanHasSameAnnotation","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","isExpanded","deletingFromTheEnd","deletingAllText","nextSpanHasSameAnnotation","marksWithoutAnnotationMarks","oldDefs","addDecoratorActionImplementation","split","hanging","splitTextNodes","removeMark","eMark","lonelyEmptySpan","existingMarks","existingMarksWithoutDecorator","existingMark","removeDecoratorActionImplementation","isDecoratorActive","selectedTextNodes","toggleDecoratorActionImplementation","createWithPortableTextSelections","prevSelection","emitPortableTextSelection","ptRange","existing","createWithSchemaTypes","isPortableTextListBlock","obj","createWithUtils","pteExpandToWord","textNode","focusOffset","charsBefore","charsAfter","isEmpty","str","whiteSpaceBeforeIndex","newStartOffset","whiteSpaceAfterIndex","newEndOffset","Number","isNaN","setSelection","withPlugins","e","operationToPatches","withObjectKeys","withSchemaTypes","withPatches","withMaxBlocks","withUndoRedo","withPortableTextMarkModel","withPortableTextBlockStyle","withPlaceholderBlock","withUtils","withPortableTextSelections","slateEditors","createSlateEditor","config","existingSlateEditor","unsubscriptions","instance","withReact","createEditor","initialValue","toggleListItemActionImplementation","isListItemActive","removeListItemActionImplementation","addListItemActionImplementation","createGuards","selectedBlocks","unsetNodes","toggleStyleActionImplementation","isStyleActive","removeStyleActionImplementation","addStyleActionImplementation","createEditableAPI","blur","toggleMark","toggleList","toggleBlockStyle","isMarkActive","slateSelection","focusBlock","descendant","focusChild","insertChild","focusChildPath","focusNode","move","distance","insertBlock","hasBlockStyle","hasListStyle","findByPath","slatePath","ptBlock","ptChild","findDOMNode","activeAnnotations","spans","isAnnotationActive","annotationType","addAnnotation","paths","addAnnotationActionImplementation","removeAnnotation","getSelection","getValue","isCollapsedSelection","isExpandedSelection","getFragment","isSelectionsOverlapping","selectionA","selectionB","rangeA","rangeB","selectionMarkDefs","reduce","accMarkDefs","markKey","originalSelection","markDefPath","markDefPaths","annotationKey","unshift","existingSameTypeAnnotations","removeAnnotationActionImplementation","potentialAnnotations","selectedChild","selectedChildPath","annotationToRemove","previousSpansWithSameAnnotation","SlatePath","nextSpansWithSameAnnotation","blocks","marksWithoutAnnotation","toggleAnnotationActionImplementation","focusBlockPath","lastBlock","insertBlockObjectActionImplementation","insertBreakActionImplementation","focusDecorators","focusAnnotations","anchorBlockPath","start","end","edges","lastFocusBlockChild","atTheEndOfBlock","atTheStartOfBlock","nextBlockPath","selectionAcrossBlocks","splitNodes","nextNodePath","newMarkDefKeys","Map","prevNodeSpans","prevNodeSpan","newMarks","insertSoftBreakActionImplementation","insertInlineObjectActionImplementation","focusTextBlock","insertSpanActionImplementation","textBlockSetActionImplementation","textBlockUnsetActionImplementation","behaviorActionImplementations","delete.backward","delete.forward","delete.block","delete.text","blockOffsetToSpanSelectionPoint","blockOffset","insert.text","insert.text block","effect","move.block","move.block down","move.block up","hasPrevious","previous","noop","newSelection","select.previous block","previousBlockPath","select.next block","performAction","performDefaultAction","getActiveDecorators","slateEditorInstance","createEditorSnapshot","activeDecorators","editorMachine","behaviors","behavior","pendingEvents","enqueueActions","enqueue","defaultAction","eventBehaviors","message","editorSnapshot","behaviorOverwritten","eventBehavior","shouldRun","actionIntendSets","actionSet","actionIntends","actionIntend","isCustomBehaviorEvent","raise","nativeEvent","coreBehaviors","initialReadOnly","exit","normalizing","mutation","editorActorSnapshot","defaultCompare","a","b","useEditorSelector","selector","compare","_internal","getEditorSnapshot","defaultKeyGenerator","randomKey","getByteHexTable","table","whatwgRNG","rnds8","Uint8Array","getRandomValues","createActor","editorConfigToMachineInput","createEditorFromActor","useCreateEditor","schemaDefinition","hasOwnProperty","editable","registerBehavior","listener","EditorActorContext","PortableTextEditorSelectionContext","usePortableTextEditorSelection","PortableTextEditorSelectionProvider","startTransition","PortableTextEditor","Component","change$","Subject","constructor","parseInt","componentDidUpdate","prevProps","editorRef","setEditable","render","legacyPatches","incomingPatches$","patches$","change","blockStyle","listStyle","isObjectPath","_editor","isChildObjectEditPath","RoutePatchesObservableToEditorActor","subscribe","payload","RouteEventsToChanges","handleChange","useEffectEvent","bb5","isLoading","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","blockSelected","setFocused","setSelected","decoratorValues","annotationMarks","shouldTrackSelectionAndFocus","sel","setSelectedFromRange","useCallback","winSelection","window","rangeCount","getRangeAt","intersectsNode","onBlur","onFocus","onSelection","content","returnedChildren","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","cat","hotkey","isHotkey","possibleMark","possibleCommand","command","createWithInsertData","blockTypeName","spanTypeName","whitespaceOnPasteMode","unstable_whitespaceOnPasteMode","toPlainText","setFragmentData","data","originEvent","startVoid","void","endVoid","domRange","toDOMRange","contents","cloneContents","voidNode","r","cloneRange","domNode","setEndAfter","querySelectorAll","zw","isNewline","getAttribute","textContent","elm","removeAttribute","hasAttribute","div","ownerDocument","createElement","asHTML","innerHTML","fragment","asJSON","asPlainText","clearData","insertPortableTextData","pText","getData","parsed","parse","_regenerateKeys","errorDescription","insertTextOrHTMLData","html","insertedType","htmlToBlocks","textToHtml","escapeHtml","line","replace","_insertFragment","insertData","insertFragmentData","insertFragment","entityMap","editorTypes","newNode","NewNodeNoDefs","allowedAnnotations","oldKey","newKey","nodeWithNewKeys","withSyncRangeDecorations","syncRangeDecorations","originalApply","PLACEHOLDER_STYLE","pointerEvents","right","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onClick","rangeDecorations","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","rangeDecorationState","setRangeDecorationsState","rangeDecorationsRef","useSlate","withInsertData","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","placeholder","decoration","rangeDecoration","component","restoreSelectionFromProps","normalizedSelection","slateRange","o","newSlateRanges","rangeDecorationItem","SlateRange","onMoved","newRange","newRangeSelection","onReady","onInvalidValue","onValueChanged","syncedRangeDecorations","setSyncedRangeDecorations","teardown","handleCopy","clipboardData","handlePaste","onPasteResult","then","result","catch","finally","handleOnFocus","isDefaultPrevented","lastNodePath","last","lastBlockPath","lastNodeFocused","lastBlockIsVoid","handleOnBlur","isPropagationStopped","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","getWindow","existingDOMRange","newDOMRange","startOffset","endOffset","removeAllRanges","addRange","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","keyboardEvent","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","decorate","intersection","SlateEditable","EditorContext","React","EditorProvider","initialConfig","useEditor","EditorEventListener"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]}},
    {"offset": {"line": 8736, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8742, "column": 0}, "map": {"version":3,"file":"util.reverse-selection.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.get-block-start-point.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/utils/util.reverse-selection.ts"],"sourcesContent":["import {\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  node,\n  path,\n}: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelectionPoint {\n  if (isPortableTextTextBlock(node)) {\n    return {\n      path: [...path, 'children', {_key: node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path,\n    offset: 0,\n  }\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection(\n  selection: NonNullable<EditorSelection>,\n): NonNullable<EditorSelection> {\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    }\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  }\n}\n"],"names":["getBlockStartPoint","node","path","isPortableTextTextBlock","_key","children","offset","reverseSelection","selection","backward","anchor","focus"],"mappings":";;;;;;AAUO,SAASA,mBAAmB,EACjCC,IAAAA,EACAC,IAAAA,EAIF,EAAyB;IACnBC,iKAAAA,0BAAAA,EAAwBF,IAAI,IACvB;QACLC,MAAM,CAAC;eAAGA;YAAM;YAAY;gBAACE,MAAMH,KAAKI,QAAAA,CAAS,CAAC,CAAA,CAAED,IAAAA;YAAAA,CAAK;SAAA;QACzDE,QAAQ;IAAA,IAIL;QACLJ;QACAI,QAAQ;IACV;AACF;ACvBO,SAASC,iBACdC,SAAAA,EAC8B;IAC9B,OAAIA,UAAUC,QAAAA,GACL;QACLC,QAAQF,UAAUG,KAAAA;QAClBA,OAAOH,UAAUE,MAAAA;QACjBD,UAAU,CAAA;IAAA,IAIP;QACLC,QAAQF,UAAUG,KAAAA;QAClBA,OAAOH,UAAUE,MAAAA;QACjBD,UAAU,CAAA;IACZ;AACF","ignoreList":[0,1]}},
    {"offset": {"line": 8776, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8782, "column": 0}, "map": {"version":3,"file":"selector.get-text-before.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-text.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/selectors/selector.get-text-before.ts"],"sourcesContent":["import {isPortableTextSpan, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = ({context}) => {\n  let text = ''\n\n  const {value, selection} = context\n\n  if (!value || !selection) {\n    return text\n  }\n\n  const forwardSelection = selection.backward\n    ? reverseSelection(selection)\n    : selection\n\n  if (!forwardSelection) {\n    return text\n  }\n\n  for (const block of value) {\n    if (\n      isKeyedSegment(forwardSelection.anchor.path[0]) &&\n      block._key !== forwardSelection.anchor.path[0]._key\n    ) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (isPortableTextSpan(child)) {\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key &&\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text =\n            text +\n            child.text.slice(\n              forwardSelection.anchor.offset,\n              forwardSelection.focus.offset,\n            )\n\n          break\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key\n        ) {\n          text = text + child.text.slice(forwardSelection.anchor.offset)\n          continue\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text = text + child.text.slice(0, forwardSelection.focus.offset)\n          break\n        }\n\n        if (text.length > 0) {\n          text = text + child.text\n        }\n      }\n    }\n\n    if (\n      isKeyedSegment(forwardSelection.focus.path[0]) &&\n      block._key === forwardSelection.focus.path[0]._key\n    ) {\n      break\n    }\n  }\n\n  return text\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextBefore: EditorSelector<string> = ({context}) => {\n  if (!context.selection) {\n    return ''\n  }\n\n  const selection = context.selection.backward\n    ? reverseSelection(context.selection)\n    : context.selection\n  const point = selection.anchor\n  const key = isKeyedSegment(point.path[0]) ? point.path[0]._key : undefined\n\n  const block = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  if (!block) {\n    return ''\n  }\n\n  const startOfBlock = getBlockStartPoint({\n    node: block,\n    path: [{_key: block._key}],\n  })\n\n  return getSelectionText({\n    context: {\n      ...context,\n      value: context.value,\n      selection: {\n        anchor: startOfBlock,\n        focus: point,\n      },\n    },\n  })\n}\n"],"names":["getSelectionText","context","text","value","selection","forwardSelection","backward","reverseSelection","block","isKeyedSegment","anchor","path","_key","isPortableTextTextBlock","child","children","isPortableTextSpan","focus","slice","offset","length","getBlockTextBefore","point","key","undefined","find","startOfBlock","getBlockStartPoint","node"],"mappings":"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","ignoreList":[0,1]}},
    {"offset": {"line": 8842, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8848, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.code-editor.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.emoji-picker.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/internal-utils/looks-like-url.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.links.ts","file://D%3A/e-com-hackathon/node_modules/%40portabletext/editor/src/behaviors/behavior.markdown.ts"],"sourcesContent":["import {isHotkey} from '../internal-utils/is-hotkey'\nimport * as selectors from '../selectors'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type CodeEditorBehaviorsConfig = {\n  moveBlockUpShortcut: string\n  moveBlockDownShortcut: string\n}\n\n/**\n * @beta\n */\nexport function createCodeEditorBehaviors(config: CodeEditorBehaviorsConfig) {\n  return [\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const isMoveUpShortcut = isHotkey(\n          config.moveBlockUpShortcut,\n          event.keyboardEvent,\n        )\n        const firstBlock = selectors.getFirstBlock({context})\n        const selectedBlocks = selectors.getSelectedBlocks({context})\n        const blocksAbove =\n          firstBlock?.node._key !== selectedBlocks[0]?.node._key\n\n        if (!isMoveUpShortcut || !blocksAbove) {\n          return false\n        }\n\n        return {paths: selectedBlocks.map((block) => block.path)}\n      },\n      actions: [\n        (_, {paths}) =>\n          paths.map((at) => ({\n            type: 'move.block up',\n            at,\n          })),\n      ],\n    }),\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const isMoveDownShortcut = isHotkey(\n          config.moveBlockDownShortcut,\n          event.keyboardEvent,\n        )\n        const lastBlock = selectors.getLastBlock({context})\n        const selectedBlocks = selectors.getSelectedBlocks({context})\n        const blocksBelow =\n          lastBlock?.node._key !==\n          selectedBlocks[selectedBlocks.length - 1]?.node._key\n\n        if (!isMoveDownShortcut || !blocksBelow) {\n          return false\n        }\n\n        return {paths: selectedBlocks.map((block) => block.path).reverse()}\n      },\n      actions: [\n        (_, {paths}) =>\n          paths.map((at) => ({\n            type: 'move.block down',\n            at,\n          })),\n      ],\n    }),\n  ]\n}\n","import {assertEvent, assign, createActor, setup} from 'xstate'\nimport {isHotkey} from '../internal-utils/is-hotkey'\nimport * as selectors from '../selectors'\nimport {defineBehavior} from './behavior.types'\n\nconst emojiCharRegEx = /^[a-zA-Z-_0-9]{1}$/\nconst incompleteEmojiRegEx = /:([a-zA-Z-_0-9]+)$/\nconst emojiRegEx = /:([a-zA-Z-_0-9]+):$/\n\n/**\n * @beta\n */\nexport type EmojiPickerBehaviorsConfig<TEmojiMatch> = {\n  /**\n   * Match emojis by keyword.\n   */\n  matchEmojis: ({keyword}: {keyword: string}) => Array<TEmojiMatch>\n  onMatchesChanged: ({matches}: {matches: Array<TEmojiMatch>}) => void\n  onSelectedIndexChanged: ({selectedIndex}: {selectedIndex: number}) => void\n  /**\n   * Parse an emoji match to a string that will be inserted into the editor.\n   */\n  parseMatch: ({match}: {match: TEmojiMatch}) => string | undefined\n}\n\n/**\n * @beta\n */\nexport function createEmojiPickerBehaviors<TEmojiMatch>(\n  config: EmojiPickerBehaviorsConfig<TEmojiMatch>,\n) {\n  const emojiPickerActor = createActor(createEmojiPickerMachine<TEmojiMatch>())\n  emojiPickerActor.start()\n  emojiPickerActor.subscribe((state) => {\n    config.onMatchesChanged({matches: state.context.matches})\n    config.onSelectedIndexChanged({selectedIndex: state.context.selectedIndex})\n  })\n\n  return [\n    defineBehavior({\n      on: 'insert.text',\n      guard: ({context, event}) => {\n        if (event.text === ':') {\n          return false\n        }\n\n        const isEmojiChar = emojiCharRegEx.test(event.text)\n\n        if (!isEmojiChar) {\n          return {emojis: []}\n        }\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = `${textBefore}${event.text}`.match(\n          incompleteEmojiRegEx,\n        )?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return {emojis: []}\n        }\n\n        const emojis = config.matchEmojis({keyword: emojiKeyword})\n\n        return {emojis}\n      },\n      actions: [\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({\n                type: 'emojis found',\n                matches: params.emojis,\n              })\n            },\n          },\n        ],\n      ],\n    }),\n    defineBehavior({\n      on: 'insert.text',\n      guard: ({context, event}) => {\n        const isColon = event.text === ':'\n\n        if (!isColon) {\n          return false\n        }\n\n        const matches = emojiPickerActor.getSnapshot().context.matches\n        const selectedIndex =\n          emojiPickerActor.getSnapshot().context.selectedIndex\n        const emoji = matches[selectedIndex]\n          ? config.parseMatch({match: matches[selectedIndex]})\n          : undefined\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = `${textBefore}:`.match(emojiRegEx)?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return false\n        }\n\n        const emojiStringLength = emojiKeyword.length + 2\n\n        if (emoji) {\n          return {\n            focusBlock,\n            emoji,\n            emojiStringLength,\n            textBeforeLength: textBefore.length + 1,\n          }\n        }\n\n        return false\n      },\n      actions: [\n        () => [\n          {\n            type: 'insert.text',\n            text: ':',\n          },\n        ],\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({type: 'select'})\n            },\n          },\n          {\n            type: 'delete.text',\n            anchor: {\n              path: params.focusBlock.path,\n              offset: params.textBeforeLength - params.emojiStringLength,\n            },\n            focus: {\n              path: params.focusBlock.path,\n              offset: params.textBeforeLength,\n            },\n          },\n          {\n            type: 'insert.text',\n            text: params.emoji,\n          },\n        ],\n      ],\n    }),\n    defineBehavior({\n      on: 'key.down',\n      guard: ({context, event}) => {\n        const matches = emojiPickerActor.getSnapshot().context.matches\n\n        if (matches.length === 0) {\n          return false\n        }\n\n        const isEscape = isHotkey('Escape', event.keyboardEvent)\n\n        if (isEscape) {\n          return {action: 'reset' as const}\n        }\n\n        const isEnter = isHotkey('Enter', event.keyboardEvent)\n        const isTab = isHotkey('Tab', event.keyboardEvent)\n\n        if (isEnter || isTab) {\n          const selectedIndex =\n            emojiPickerActor.getSnapshot().context.selectedIndex\n\n          const emoji = matches[selectedIndex]\n            ? config.parseMatch({match: matches[selectedIndex]})\n            : undefined\n\n          if (!emoji) {\n            return false\n          }\n\n          const focusBlock = selectors.getFocusTextBlock({context})\n          const textBefore = selectors.getBlockTextBefore({context})\n          const emojiKeyword = textBefore.match(incompleteEmojiRegEx)?.[1]\n\n          if (!focusBlock || emojiKeyword === undefined) {\n            return false\n          }\n\n          const emojiStringLength = emojiKeyword.length + 1\n\n          if (emoji) {\n            return {\n              action: 'select' as const,\n              focusBlock,\n              emoji,\n              emojiStringLength,\n              textBeforeLength: textBefore.length,\n            }\n          }\n\n          return false\n        }\n\n        const isArrowDown = isHotkey('ArrowDown', event.keyboardEvent)\n        const isArrowUp = isHotkey('ArrowUp', event.keyboardEvent)\n\n        if (isArrowDown && matches.length > 0) {\n          return {action: 'navigate down' as const}\n        }\n\n        if (isArrowUp && matches.length > 0) {\n          return {action: 'navigate up' as const}\n        }\n\n        return false\n      },\n      actions: [\n        (_, params) => {\n          if (params.action === 'select') {\n            return [\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'select'})\n                },\n              },\n              {\n                type: 'delete.text',\n                anchor: {\n                  path: params.focusBlock.path,\n                  offset: params.textBeforeLength - params.emojiStringLength,\n                },\n                focus: {\n                  path: params.focusBlock.path,\n                  offset: params.textBeforeLength,\n                },\n              },\n              {\n                type: 'insert.text',\n                text: params.emoji,\n              },\n            ]\n          }\n\n          if (params.action === 'navigate up') {\n            return [\n              // If we are navigating then we want to hijack the key event and\n              // turn it into a noop.\n              {\n                type: 'noop',\n              },\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'navigate up'})\n                },\n              },\n            ]\n          }\n\n          if (params.action === 'navigate down') {\n            return [\n              // If we are navigating then we want to hijack the key event and\n              // turn it into a noop.\n              {\n                type: 'noop',\n              },\n              {\n                type: 'effect',\n                effect: () => {\n                  emojiPickerActor.send({type: 'navigate down'})\n                },\n              },\n            ]\n          }\n\n          return [\n            {\n              type: 'effect',\n              effect: () => {\n                emojiPickerActor.send({type: 'reset'})\n              },\n            },\n          ]\n        },\n      ],\n    }),\n    defineBehavior({\n      on: 'delete.backward',\n      guard: ({context, event}) => {\n        if (event.unit !== 'character') {\n          return false\n        }\n\n        const matches = emojiPickerActor.getSnapshot().context.matches\n\n        if (matches.length === 0) {\n          return false\n        }\n\n        const focusBlock = selectors.getFocusTextBlock({context})\n        const textBefore = selectors.getBlockTextBefore({context})\n        const emojiKeyword = textBefore\n          .slice(0, textBefore.length - 1)\n          .match(incompleteEmojiRegEx)?.[1]\n\n        if (!focusBlock || emojiKeyword === undefined) {\n          return {emojis: []}\n        }\n\n        const emojis = config.matchEmojis({keyword: emojiKeyword})\n\n        return {emojis}\n      },\n      actions: [\n        (_, params) => [\n          {\n            type: 'effect',\n            effect: () => {\n              emojiPickerActor.send({\n                type: 'emojis found',\n                matches: params.emojis,\n              })\n            },\n          },\n        ],\n      ],\n    }),\n  ]\n}\n\nfunction createEmojiPickerMachine<TEmojiSearchResult>() {\n  return setup({\n    types: {\n      context: {} as {\n        matches: Array<TEmojiSearchResult>\n        selectedIndex: number\n      },\n      events: {} as\n        | {\n            type: 'emojis found'\n            matches: Array<TEmojiSearchResult>\n          }\n        | {\n            type: 'navigate down' | 'navigate up' | 'select' | 'reset'\n          },\n    },\n    actions: {\n      'assign matches': assign({\n        matches: ({event}) => {\n          assertEvent(event, 'emojis found')\n          return event.matches\n        },\n      }),\n      'reset matches': assign({\n        matches: [],\n      }),\n      'reset selected index': assign({\n        selectedIndex: 0,\n      }),\n      'increment selected index': assign({\n        selectedIndex: ({context}) => {\n          if (context.selectedIndex === context.matches.length - 1) {\n            return 0\n          }\n          return context.selectedIndex + 1\n        },\n      }),\n      'decrement selected index': assign({\n        selectedIndex: ({context}) => {\n          if (context.selectedIndex === 0) {\n            return context.matches.length - 1\n          }\n          return context.selectedIndex - 1\n        },\n      }),\n    },\n    guards: {\n      'no matches': ({context}) => context.matches.length === 0,\n    },\n  }).createMachine({\n    id: 'emoji picker',\n    context: {\n      matches: [],\n      selectedIndex: 0,\n    },\n    initial: 'idle',\n    states: {\n      'idle': {\n        on: {\n          'emojis found': {\n            actions: 'assign matches',\n            target: 'showing matches',\n          },\n        },\n      },\n      'showing matches': {\n        always: {\n          guard: 'no matches',\n          target: 'idle',\n        },\n        exit: ['reset selected index'],\n        on: {\n          'emojis found': {\n            actions: 'assign matches',\n          },\n          'navigate down': {\n            actions: 'increment selected index',\n          },\n          'navigate up': {\n            actions: 'decrement selected index',\n          },\n          'reset': {\n            target: 'idle',\n            actions: ['reset selected index', 'reset matches'],\n          },\n          'select': {\n            target: 'idle',\n            actions: ['reset selected index', 'reset matches'],\n          },\n        },\n      },\n    },\n  })\n}\n","export function looksLikeUrl(text: string) {\n  let looksLikeUrl = false\n  try {\n    const url = new URL(text)\n\n    if (!sensibleProtocols.includes(url.protocol)) {\n      return false\n    }\n\n    looksLikeUrl = true\n  } catch {}\n  return looksLikeUrl\n}\n\nconst sensibleProtocols = ['http:', 'https:', 'mailto:', 'tel:']\n","import type {EditorSchema} from '../editor/define-schema'\nimport {looksLikeUrl} from '../internal-utils/looks-like-url'\nimport * as selectors from '../selectors'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type LinkBehaviorsConfig = {\n  linkAnnotation?: (context: {\n    schema: EditorSchema\n    url: string\n  }) => {name: string; value: {[prop: string]: unknown}} | undefined\n}\n\n/**\n * @beta\n */\nexport function createLinkBehaviors(config: LinkBehaviorsConfig) {\n  const pasteLinkOnSelection = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const text = event.data.getData('text/plain')\n      const url = looksLikeUrl(text) ? text : undefined\n      const annotation =\n        url !== undefined\n          ? config.linkAnnotation?.({url, schema: context.schema})\n          : undefined\n\n      if (annotation && !selectionCollapsed) {\n        return {annotation}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {annotation}) => [\n        {\n          type: 'annotation.add',\n          annotation,\n        },\n      ],\n    ],\n  })\n  const pasteLinkAtCaret = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const focusSpan = selectors.getFocusSpan({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!focusSpan || !selectionCollapsed) {\n        return false\n      }\n\n      const text = event.data.getData('text/plain')\n      const url = looksLikeUrl(text) ? text : undefined\n      const annotation =\n        url !== undefined\n          ? config.linkAnnotation?.({url, schema: context.schema})\n          : undefined\n\n      if (url && annotation && selectionCollapsed) {\n        return {focusSpan, annotation, url}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {annotation, url}) => [\n        {\n          type: 'insert.span',\n          text: url,\n          annotations: [annotation],\n        },\n      ],\n    ],\n  })\n\n  const linkBehaviors = [pasteLinkOnSelection, pasteLinkAtCaret]\n\n  return linkBehaviors\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport * as selectors from '../selectors'\nimport {getBlockTextBefore} from '../selectors/selector.get-text-before'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getTextBlockText} from '../utils/util.get-text-block-text'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n * Create markdown behaviors for common markdown actions such as converting ### to headings, --- to HRs, and more.\n *\n * @example\n * Configure the bundled markdown behaviors\n * ```ts\n * import {EditorProvider} from '@portabletext/editor'\n * import {createMarkdownBehaviors, coreBehaviors} from '@portabletext/editor/behaviors'\n *\n * function App() {\n *  return (\n *   <EditorProvider\n *    initialConfig={{\n *    behaviors: [\n *    ...coreBehaviors,\n *    ...createMarkdownBehaviors({\n *        horizontalRuleObject: ({schema}) => {\n *          const name = schema.blockObjects.find(\n *            (object) => object.name === 'break',\n *          )?.name\n *          return name ? {name} : undefined\n *        },\n *        defaultStyle: ({schema}) => schema.styles[0].value,\n *        headingStyle: ({schema, level}) =>\n *          schema.styles.find((style) => style.value === `h${level}`)\n *            ?.value,\n *        blockquoteStyle: ({schema}) =>\n *          schema.styles.find((style) => style.value === 'blockquote')\n *            ?.value,\n *        unorderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'bullet')?.value,\n *        orderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'number')?.value,\n *      }),\n *      ]\n *    }}\n *    >\n *    {...}\n *    </EditorProvider>\n *  )\n * }\n * ```\n *\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        {\n          type: 'insert.text',\n          text: ' ',\n        },\n      ],\n      (_, {focusTextBlock, style}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: 2,\n          },\n        },\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusTextBlock({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const textBefore = getBlockTextBefore({context})\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (textBefore === `${hrCharacter}${hrCharacter}`) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacter,\n        },\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        {\n          type: 'insert.block object',\n          placement: 'before',\n          blockObject: hrObject,\n        },\n        {\n          type: 'delete.text',\n          ...hrBlockOffsets,\n        },\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const text = event.data.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusBlock({context})\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacters,\n        },\n      ],\n      (_, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              {\n                type: 'insert.text block',\n                textBlock: {children: focusBlock.node.children},\n                placement: 'after',\n              },\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n              {type: 'delete.block', blockPath: focusBlock.path},\n            ]\n          : [\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (!caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, level}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: level + 1,\n          },\n        },\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({context}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        {\n          type: 'text block.set',\n          style: defaultStyle,\n          at: focusTextBlock.path,\n        },\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        {\n          type: 'text block.set',\n          listItem,\n          level: 1,\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: listItemLength + 1,\n          },\n        },\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createCodeEditorBehaviors","config","defineBehavior","on","guard","context","event","isMoveUpShortcut","isHotkey","moveBlockUpShortcut","keyboardEvent","firstBlock","selectors","selectedBlocks","blocksAbove","node","_key","paths","map","block","path","actions","_","at","type","isMoveDownShortcut","moveBlockDownShortcut","lastBlock","blocksBelow","length","reverse","emojiCharRegEx","incompleteEmojiRegEx","emojiRegEx","createEmojiPickerBehaviors","emojiPickerActor","createActor","createEmojiPickerMachine","start","subscribe","state","onMatchesChanged","matches","onSelectedIndexChanged","selectedIndex","text","test","emojis","focusBlock","emojiKeyword","match","undefined","matchEmojis","keyword","params","effect","send","getSnapshot","emoji","parseMatch","textBefore","emojiStringLength","textBeforeLength","anchor","offset","focus","action","isEnter","isTab","isArrowDown","isArrowUp","unit","slice","setup","types","events","assign","assertEvent","guards","no matches","createMachine","id","initial","states","target","always","exit","looksLikeUrl","url","URL","sensibleProtocols","includes","protocol","createLinkBehaviors","pasteLinkOnSelection","selectionCollapsed","data","getData","annotation","linkAnnotation","schema","pasteLinkAtCaret","focusSpan","annotations","createMarkdownBehaviors","automaticBlockquoteOnSpace","focusTextBlock","blockOffset","spanSelectionPointToBlockOffset","value","selectionPoint","selection","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","blockquoteStyle","style","props","automaticHr","hrCharacter","hrObject","horizontalRuleObject","getBlockTextBefore","hrBlockOffsets","placement","blockObject","automaticHrOnPaste","hrRegExp","hrCharacters","isPortableTextTextBlock","textBlock","children","blockPath","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","headingStyle","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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","ignoreList":[0,1,2,3,4]}},
    {"offset": {"line": 9634, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}